
uip.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002e3c  00000000  00000000  00000094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000276  00800060  00002e3c  00002ed0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000055c  008002d6  008002d6  00003146  2**0
                  ALLOC
  3 .noinit       00000000  00800832  00800832  00003146  2**0
                  CONTENTS
  4 .eeprom       00000000  00810000  00810000  00003146  2**0
                  CONTENTS
  5 .stab         0000036c  00000000  00000000  00003148  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .stabstr      00000084  00000000  00000000  000034b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_aranges 000000f0  00000000  00000000  00003538  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 0000063e  00000000  00000000  00003628  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00002e26  00000000  00000000  00003c66  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00000f9b  00000000  00000000  00006a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   000026a7  00000000  00000000  00007a27  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000b5f  00000000  00000000  0000a0ce  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54 <__ctors_end>
       4:	0c 94 f8 12 	jmp	0x25f0 <__vector_1>
       8:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      1c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      20:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      28:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      2c:	0c 94 8d 12 	jmp	0x251a <__vector_11>
      30:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      34:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      38:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      3c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>
      50:	0c 94 45 00 	jmp	0x8a <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	12 e0       	ldi	r17, 0x02	; 2
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e3       	ldi	r30, 0x3C	; 60
      68:	fe e2       	ldi	r31, 0x2E	; 46
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a6 3d       	cpi	r26, 0xD6	; 214
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a6 ed       	ldi	r26, 0xD6	; 214
      7a:	b2 e0       	ldi	r27, 0x02	; 2
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a2 33       	cpi	r26, 0x32	; 50
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0c 94 5a 00 	jmp	0xb4 <main>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0x0 <__vectors>

0000008e <Target_Init>:
;*****************************************************************************************************
;*/
void Target_Init(void)
{
	RS232_Init(9600);
      8e:	60 e8       	ldi	r22, 0x80	; 128
      90:	75 e2       	ldi	r23, 0x25	; 37
      92:	80 e0       	ldi	r24, 0x00	; 0
      94:	90 e0       	ldi	r25, 0x00	; 0
      96:	0e 94 4e 15 	call	0x2a9c <RS232_Init>

	RS232_Printf("hello world!\n");	
      9a:	80 e6       	ldi	r24, 0x60	; 96
      9c:	90 e0       	ldi	r25, 0x00	; 0
      9e:	9f 93       	push	r25
      a0:	8f 93       	push	r24
      a2:	0e 94 b4 15 	call	0x2b68 <RS232_Printf>
	
	UIP_Clock_Init(); 
      a6:	0e 94 a6 12 	call	0x254c <UIP_Clock_Init>
	
    sei();
      aa:	78 94       	sei
      ac:	0f 90       	pop	r0
      ae:	0f 90       	pop	r0
      b0:	08 95       	ret

000000b2 <uip_appcall>:
}


void uip_appcall(void)
{
      b2:	08 95       	ret

000000b4 <main>:

}
 

#define BUF ((struct uip_eth_hdr *)&uip_buf[0])
	
/*
;*****************************************************************************************************
;* 函数名称 : main
;* 描    述 : 主函数
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
#if UIP_FIXEDETHADDR == 0
struct uip_eth_addr ethaddr;
char avr_mac[] = {'A', 'V', 'R', 'N', 'E', 'T'};
#endif

int main(void)
{	  
      b4:	c7 e5       	ldi	r28, 0x57	; 87
      b6:	d8 e0       	ldi	r29, 0x08	; 8
      b8:	de bf       	out	0x3e, r29	; 62
      ba:	cd bf       	out	0x3d, r28	; 61
	int i;
	uip_ipaddr_t ipaddr;
	struct timer periodic_timer, arp_timer;

/* 
 * 芯片初始化 
*/ 
	Target_Init();
      bc:	0e 94 47 00 	call	0x8e <Target_Init>
	
/* 
 * 定时器初始化 
*/ 
	timer_set(&periodic_timer, CLOCK_SECOND / 2);
      c0:	62 e3       	ldi	r22, 0x32	; 50
      c2:	70 e0       	ldi	r23, 0x00	; 0
      c4:	ce 01       	movw	r24, r28
      c6:	01 96       	adiw	r24, 0x01	; 1
      c8:	0e 94 c1 0c 	call	0x1982 <timer_set>
	timer_set(&arp_timer, CLOCK_SECOND * 10);
      cc:	68 ee       	ldi	r22, 0xE8	; 232
      ce:	73 e0       	ldi	r23, 0x03	; 3
      d0:	ce 01       	movw	r24, r28
      d2:	05 96       	adiw	r24, 0x05	; 5
      d4:	0e 94 c1 0c 	call	0x1982 <timer_set>
 
/* 
 * 网络设备初始化 
*/ 
	tapdev_init();
      d8:	0e 94 b4 12 	call	0x2568 <tapdev_init>

/* 
 * UIP初始化 
*/ 
	uip_init();
      dc:	0e 94 3e 04 	call	0x87c <uip_init>
  
/* 
 * ARP初始化 
*/ 
	uip_arp_init();
      e0:	0e 94 00 0d 	call	0x1a00 <uip_arp_init>
	
/* 
 * 本机IP初始化 
*/ 
#if UIP_FIXEDADDR == 0
	uip_ipaddr(ipaddr, UIP_IPADDR0,UIP_IPADDR1,UIP_IPADDR2,UIP_IPADDR3);
	uip_sethostaddr(ipaddr);
	uip_ipaddr(ipaddr, UIP_DRIPADDR0,UIP_DRIPADDR1,UIP_DRIPADDR2,UIP_DRIPADDR3);
	uip_setdraddr(ipaddr);
	uip_ipaddr(ipaddr, UIP_NETMASK0,UIP_NETMASK1,UIP_NETMASK2,UIP_NETMASK3);
	uip_setnetmask(ipaddr);
#endif 

/* 
 * 本机MAC初始化 
*/ 
#if UIP_FIXEDETHADDR == 0
	for (i = 0; i < 6; i++)
  		ethaddr.addr[i] = avr_mac[i];
  	uip_setethaddr(ethaddr);
#endif

telnetd_init();
      e4:	0e 94 94 01 	call	0x328 <telnetd_init>

/* 
 * 循环
*/ 
	while(1) 
	{
		uip_len = tapdev_read();
      e8:	0e 94 dd 12 	call	0x25ba <tapdev_read>
      ec:	90 93 6c 03 	sts	0x036C, r25
      f0:	80 93 6b 03 	sts	0x036B, r24
		
		if (uip_len > 0) 
      f4:	89 2b       	or	r24, r25
      f6:	b1 f1       	breq	.+108    	; 0x164 <main+0xb0>
		{
		   if(BUF->type == htons(UIP_ETHTYPE_IP)) 
      f8:	80 e0       	ldi	r24, 0x00	; 0
      fa:	98 e0       	ldi	r25, 0x08	; 8
      fc:	0e 94 f1 03 	call	0x7e2 <htons>
     100:	20 91 8c 06 	lds	r18, 0x068C
     104:	30 91 8d 06 	lds	r19, 0x068D
     108:	28 17       	cp	r18, r24
     10a:	39 07       	cpc	r19, r25
     10c:	61 f4       	brne	.+24     	; 0x126 <main+0x72>
		   {
				uip_arp_ipin();
				uip_input();
     10e:	81 e0       	ldi	r24, 0x01	; 1
     110:	0e 94 50 05 	call	0xaa0 <uip_process>
				if(uip_len > 0) 
     114:	80 91 6b 03 	lds	r24, 0x036B
     118:	90 91 6c 03 	lds	r25, 0x036C
     11c:	89 2b       	or	r24, r25
     11e:	21 f3       	breq	.-56     	; 0xe8 <main+0x34>
				{
					uip_arp_out();
     120:	0e 94 92 0e 	call	0x1d24 <uip_arp_out>
     124:	13 c0       	rjmp	.+38     	; 0x14c <main+0x98>
					tapdev_send();
				}
			} 
			else 
			if(BUF->type == htons(UIP_ETHTYPE_ARP)) 
     126:	86 e0       	ldi	r24, 0x06	; 6
     128:	98 e0       	ldi	r25, 0x08	; 8
     12a:	0e 94 f1 03 	call	0x7e2 <htons>
     12e:	20 91 8c 06 	lds	r18, 0x068C
     132:	30 91 8d 06 	lds	r19, 0x068D
     136:	28 17       	cp	r18, r24
     138:	39 07       	cpc	r19, r25
     13a:	59 f4       	brne	.+22     	; 0x152 <main+0x9e>
			{
				uip_arp_arpin();
     13c:	0e 94 db 0d 	call	0x1bb6 <uip_arp_arpin>
				if(uip_len > 0) 
     140:	80 91 6b 03 	lds	r24, 0x036B
     144:	90 91 6c 03 	lds	r25, 0x036C
     148:	89 2b       	or	r24, r25
     14a:	71 f2       	breq	.-100    	; 0xe8 <main+0x34>
				{
					tapdev_send();
     14c:	0e 94 24 13 	call	0x2648 <tapdev_send>
     150:	cb cf       	rjmp	.-106    	; 0xe8 <main+0x34>
				}
			}
			else
			{
				RS232_Printf("packet type error\n");
     152:	8e e6       	ldi	r24, 0x6E	; 110
     154:	90 e0       	ldi	r25, 0x00	; 0
     156:	9f 93       	push	r25
     158:	8f 93       	push	r24
     15a:	0e 94 b4 15 	call	0x2b68 <RS232_Printf>
     15e:	0f 90       	pop	r0
     160:	0f 90       	pop	r0
     162:	c2 cf       	rjmp	.-124    	; 0xe8 <main+0x34>
			}
		} 
		else 
		if(timer_expired(&periodic_timer)) 
     164:	ce 01       	movw	r24, r28
     166:	01 96       	adiw	r24, 0x01	; 1
     168:	0e 94 e4 0c 	call	0x19c8 <timer_expired>
     16c:	89 2b       	or	r24, r25
     16e:	09 f4       	brne	.+2      	; 0x172 <main+0xbe>
     170:	bb cf       	rjmp	.-138    	; 0xe8 <main+0x34>
		{
			timer_reset(&periodic_timer);
     172:	ce 01       	movw	r24, r28
     174:	01 96       	adiw	r24, 0x01	; 1
     176:	0e 94 cf 0c 	call	0x199e <timer_reset>
     17a:	08 e7       	ldi	r16, 0x78	; 120
     17c:	13 e0       	ldi	r17, 0x03	; 3
			for(i = 0; i < UIP_CONNS; i++) 
			{
				uip_periodic(i);
     17e:	10 93 77 03 	sts	0x0377, r17
     182:	00 93 76 03 	sts	0x0376, r16
     186:	82 e0       	ldi	r24, 0x02	; 2
     188:	0e 94 50 05 	call	0xaa0 <uip_process>
				if(uip_len > 0) 
     18c:	80 91 6b 03 	lds	r24, 0x036B
     190:	90 91 6c 03 	lds	r25, 0x036C
     194:	89 2b       	or	r24, r25
     196:	21 f0       	breq	.+8      	; 0x1a0 <main+0xec>
				{
					uip_arp_out();
     198:	0e 94 92 0e 	call	0x1d24 <uip_arp_out>
					tapdev_send();
     19c:	0e 94 24 13 	call	0x2648 <tapdev_send>
     1a0:	07 5b       	subi	r16, 0xB7	; 183
     1a2:	1f 4f       	sbci	r17, 0xFF	; 255
     1a4:	86 e0       	ldi	r24, 0x06	; 6
     1a6:	09 30       	cpi	r16, 0x09	; 9
     1a8:	18 07       	cpc	r17, r24
     1aa:	49 f3       	breq	.-46     	; 0x17e <main+0xca>
     1ac:	44 f3       	brlt	.-48     	; 0x17e <main+0xca>
				}
			}

			#if UIP_UDP
			for(i = 0; i < UIP_UDP_CONNS; i++) 
			{
				uip_udp_periodic(i);
				if(uip_len > 0) 
				{
					uip_arp_out();
					tapdev_send();
				}
			}
			#endif /* UIP_UDP */
      
			/* Call the ARP timer function every 10 seconds. */
			if(timer_expired(&arp_timer)) 
     1ae:	ce 01       	movw	r24, r28
     1b0:	05 96       	adiw	r24, 0x05	; 5
     1b2:	0e 94 e4 0c 	call	0x19c8 <timer_expired>
     1b6:	89 2b       	or	r24, r25
     1b8:	09 f4       	brne	.+2      	; 0x1bc <main+0x108>
     1ba:	96 cf       	rjmp	.-212    	; 0xe8 <main+0x34>
			{
				timer_reset(&arp_timer);
     1bc:	ce 01       	movw	r24, r28
     1be:	05 96       	adiw	r24, 0x05	; 5
     1c0:	0e 94 cf 0c 	call	0x199e <timer_reset>
				uip_arp_timer();
     1c4:	0e 94 11 0d 	call	0x1a22 <uip_arp_timer>
     1c8:	8f cf       	rjmp	.-226    	; 0xe8 <main+0x34>

000001ca <uip_log>:
			}
		}
	}
	return 0;
}

/*
;*****************************************************************************************************
;* 函数名称 : uip_log
;* 描    述 : 辅助函数
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void uip_log(char *m)
{
	RS232_Printf("uIP log message: %s\n", m);
     1ca:	9f 93       	push	r25
     1cc:	8f 93       	push	r24
     1ce:	81 e8       	ldi	r24, 0x81	; 129
     1d0:	90 e0       	ldi	r25, 0x00	; 0
     1d2:	9f 93       	push	r25
     1d4:	8f 93       	push	r24
     1d6:	0e 94 b4 15 	call	0x2b68 <RS232_Printf>
     1da:	0f 90       	pop	r0
     1dc:	0f 90       	pop	r0
     1de:	0f 90       	pop	r0
     1e0:	0f 90       	pop	r0
     1e2:	08 95       	ret

000001e4 <alloc_line>:
/*---------------------------------------------------------------------------*/
static char *
alloc_line(void)
{
  return memb_alloc(&linemem);
     1e4:	86 e9       	ldi	r24, 0x96	; 150
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	0e 94 32 12 	call	0x2464 <memb_alloc>
     1ec:	08 95       	ret

000001ee <dealloc_line>:
}
/*---------------------------------------------------------------------------*/
static void
dealloc_line(char *line)
{
  memb_free(&linemem, line);
     1ee:	bc 01       	movw	r22, r24
     1f0:	86 e9       	ldi	r24, 0x96	; 150
     1f2:	90 e0       	ldi	r25, 0x00	; 0
     1f4:	0e 94 5e 12 	call	0x24bc <memb_free>
     1f8:	08 95       	ret

000001fa <shell_quit>:
}
/*---------------------------------------------------------------------------*/
void
shell_quit(char *str)
{
  s.state = STATE_CLOSE;
     1fa:	86 e0       	ldi	r24, 0x06	; 6
     1fc:	80 93 3d 03 	sts	0x033D, r24
     200:	08 95       	ret

00000202 <sendline>:
}
/*---------------------------------------------------------------------------*/
static void
sendline(char *line)
{
     202:	ac 01       	movw	r20, r24
  static unsigned int i;
  
  for(i = 0; i < TELNETD_CONF_NUMLINES; ++i) {
     204:	10 92 d7 02 	sts	0x02D7, r1
     208:	10 92 d6 02 	sts	0x02D6, r1
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	30 e0       	ldi	r19, 0x00	; 0
    if(s.lines[i] == NULL) {
     210:	f9 01       	movw	r30, r18
     212:	e2 0f       	add	r30, r18
     214:	f3 1f       	adc	r31, r19
     216:	ef 5e       	subi	r30, 0xEF	; 239
     218:	fc 4f       	sbci	r31, 0xFC	; 252
     21a:	80 81       	ld	r24, Z
     21c:	91 81       	ldd	r25, Z+1	; 0x01
     21e:	89 2b       	or	r24, r25
     220:	19 f4       	brne	.+6      	; 0x228 <sendline+0x26>
      s.lines[i] = line;
     222:	51 83       	std	Z+1, r21	; 0x01
     224:	40 83       	st	Z, r20
      break;
     226:	03 c0       	rjmp	.+6      	; 0x22e <sendline+0x2c>
     228:	2f 5f       	subi	r18, 0xFF	; 255
     22a:	3f 4f       	sbci	r19, 0xFF	; 255
     22c:	89 f3       	breq	.-30     	; 0x210 <sendline+0xe>
     22e:	30 93 d7 02 	sts	0x02D7, r19
     232:	20 93 d6 02 	sts	0x02D6, r18
    }
  }
  if(i == TELNETD_CONF_NUMLINES) {
     236:	21 30       	cpi	r18, 0x01	; 1
     238:	31 05       	cpc	r19, r1
     23a:	19 f4       	brne	.+6      	; 0x242 <sendline+0x40>
    dealloc_line(line);
     23c:	ca 01       	movw	r24, r20
     23e:	0e 94 f7 00 	call	0x1ee <dealloc_line>
     242:	08 95       	ret

00000244 <shell_prompt>:
  }
}
/*---------------------------------------------------------------------------*/
void
shell_prompt(char *str)
{
     244:	0f 93       	push	r16
     246:	1f 93       	push	r17
     248:	cf 93       	push	r28
     24a:	df 93       	push	r29
     24c:	8c 01       	movw	r16, r24
  char *line;
  line = alloc_line();
     24e:	0e 94 f2 00 	call	0x1e4 <alloc_line>
     252:	ec 01       	movw	r28, r24
  if(line != NULL) {
     254:	00 97       	sbiw	r24, 0x00	; 0
     256:	41 f0       	breq	.+16     	; 0x268 <shell_prompt+0x24>
    strncpy(line, str, TELNETD_CONF_LINELEN);
     258:	48 e2       	ldi	r20, 0x28	; 40
     25a:	50 e0       	ldi	r21, 0x00	; 0
     25c:	b8 01       	movw	r22, r16
     25e:	0e 94 b2 16 	call	0x2d64 <strncpy>
    /*    petsciiconv_toascii(line, TELNETD_CONF_LINELEN);*/
    sendline(line);
     262:	ce 01       	movw	r24, r28
     264:	0e 94 01 01 	call	0x202 <sendline>
     268:	df 91       	pop	r29
     26a:	cf 91       	pop	r28
     26c:	1f 91       	pop	r17
     26e:	0f 91       	pop	r16
     270:	08 95       	ret

00000272 <shell_output>:
  }
}
/*---------------------------------------------------------------------------*/
void
shell_output(char *str1, char *str2)
{
     272:	ef 92       	push	r14
     274:	ff 92       	push	r15
     276:	0f 93       	push	r16
     278:	1f 93       	push	r17
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
     27e:	8c 01       	movw	r16, r24
     280:	7b 01       	movw	r14, r22
  static unsigned len;
  char *line;

  line = alloc_line();
     282:	0e 94 f2 00 	call	0x1e4 <alloc_line>
     286:	ec 01       	movw	r28, r24
  if(line != NULL) {
     288:	00 97       	sbiw	r24, 0x00	; 0
     28a:	09 f4       	brne	.+2      	; 0x28e <shell_output+0x1c>
     28c:	46 c0       	rjmp	.+140    	; 0x31a <shell_output+0xa8>
    len = strlen(str1);
     28e:	f8 01       	movw	r30, r16
     290:	01 90       	ld	r0, Z+
     292:	00 20       	and	r0, r0
     294:	e9 f7       	brne	.-6      	; 0x290 <shell_output+0x1e>
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	e0 1b       	sub	r30, r16
     29a:	f1 0b       	sbc	r31, r17
     29c:	f0 93 d9 02 	sts	0x02D9, r31
     2a0:	e0 93 d8 02 	sts	0x02D8, r30
    strncpy(line, str1, TELNETD_CONF_LINELEN);
     2a4:	48 e2       	ldi	r20, 0x28	; 40
     2a6:	50 e0       	ldi	r21, 0x00	; 0
     2a8:	b8 01       	movw	r22, r16
     2aa:	0e 94 b2 16 	call	0x2d64 <strncpy>
    if(len < TELNETD_CONF_LINELEN) {
     2ae:	20 91 d8 02 	lds	r18, 0x02D8
     2b2:	30 91 d9 02 	lds	r19, 0x02D9
     2b6:	28 32       	cpi	r18, 0x28	; 40
     2b8:	31 05       	cpc	r19, r1
     2ba:	58 f4       	brcc	.+22     	; 0x2d2 <shell_output+0x60>
      strncpy(line + len, str2, TELNETD_CONF_LINELEN - len);
     2bc:	88 e2       	ldi	r24, 0x28	; 40
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	82 1b       	sub	r24, r18
     2c2:	93 0b       	sbc	r25, r19
     2c4:	ac 01       	movw	r20, r24
     2c6:	b7 01       	movw	r22, r14
     2c8:	ce 01       	movw	r24, r28
     2ca:	82 0f       	add	r24, r18
     2cc:	93 1f       	adc	r25, r19
     2ce:	0e 94 b2 16 	call	0x2d64 <strncpy>
    }
    len = strlen(line);
     2d2:	fe 01       	movw	r30, r28
     2d4:	01 90       	ld	r0, Z+
     2d6:	00 20       	and	r0, r0
     2d8:	e9 f7       	brne	.-6      	; 0x2d4 <shell_output+0x62>
     2da:	31 97       	sbiw	r30, 0x01	; 1
     2dc:	ec 1b       	sub	r30, r28
     2de:	fd 0b       	sbc	r31, r29
     2e0:	f0 93 d9 02 	sts	0x02D9, r31
     2e4:	e0 93 d8 02 	sts	0x02D8, r30
    if(len < TELNETD_CONF_LINELEN - 2) {
     2e8:	e6 32       	cpi	r30, 0x26	; 38
     2ea:	f1 05       	cpc	r31, r1
     2ec:	98 f4       	brcc	.+38     	; 0x314 <shell_output+0xa2>
      line[len] = ISO_cr;
     2ee:	ec 0f       	add	r30, r28
     2f0:	fd 1f       	adc	r31, r29
     2f2:	8d e0       	ldi	r24, 0x0D	; 13
     2f4:	80 83       	st	Z, r24
      line[len+1] = ISO_nl;
     2f6:	e0 91 d8 02 	lds	r30, 0x02D8
     2fa:	f0 91 d9 02 	lds	r31, 0x02D9
     2fe:	ec 0f       	add	r30, r28
     300:	fd 1f       	adc	r31, r29
     302:	8a e0       	ldi	r24, 0x0A	; 10
     304:	81 83       	std	Z+1, r24	; 0x01
      line[len+2] = 0;
     306:	e0 91 d8 02 	lds	r30, 0x02D8
     30a:	f0 91 d9 02 	lds	r31, 0x02D9
     30e:	ec 0f       	add	r30, r28
     310:	fd 1f       	adc	r31, r29
     312:	12 82       	std	Z+2, r1	; 0x02
    }
    /*    petsciiconv_toascii(line, TELNETD_CONF_LINELEN);*/
    sendline(line);
     314:	ce 01       	movw	r24, r28
     316:	0e 94 01 01 	call	0x202 <sendline>
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	08 95       	ret

00000328 <telnetd_init>:
  }
}
/*---------------------------------------------------------------------------*/
void
telnetd_init(void)
{
  uip_listen(HTONS(23));
     328:	80 e0       	ldi	r24, 0x00	; 0
     32a:	97 e1       	ldi	r25, 0x17	; 23
     32c:	0e 94 14 05 	call	0xa28 <uip_listen>
  memb_init(&linemem);
     330:	86 e9       	ldi	r24, 0x96	; 150
     332:	90 e0       	ldi	r25, 0x00	; 0
     334:	0e 94 10 12 	call	0x2420 <memb_init>
  shell_init();
     338:	0e 94 4c 03 	call	0x698 <shell_init>
     33c:	08 95       	ret

0000033e <get_char>:
}
/*---------------------------------------------------------------------------*/
static void
acked(void)
{
  static unsigned int i;
  
  while(s.numsent > 0) {
    dealloc_line(s.lines[0]);
    for(i = 1; i < TELNETD_CONF_NUMLINES; ++i) {
      s.lines[i - 1] = s.lines[i];
    }
    s.lines[TELNETD_CONF_NUMLINES - 1] = NULL;
    --s.numsent;
  }
}
/*---------------------------------------------------------------------------*/
static void
senddata(void)
{
  static char *bufptr, *lineptr;
  static int buflen, linelen;
  
  bufptr = uip_appdata;
  buflen = 0;
  for(s.numsent = 0; s.numsent < TELNETD_CONF_NUMLINES &&
	s.lines[s.numsent] != NULL ; ++s.numsent) {
    lineptr = s.lines[s.numsent];
    linelen = strlen(lineptr);
    if(linelen > TELNETD_CONF_LINELEN) {
      linelen = TELNETD_CONF_LINELEN;
    }
    if(buflen + linelen < uip_mss()) {
      memcpy(bufptr, lineptr, linelen);
      bufptr += linelen;
      buflen += linelen;
    } else {
      break;
    }
  }
  uip_send(uip_appdata, buflen);
}
/*---------------------------------------------------------------------------*/
static void
closed(void)
{
  static unsigned int i;
  
  for(i = 0; i < TELNETD_CONF_NUMLINES; ++i) {
    if(s.lines[i] != NULL) {
      dealloc_line(s.lines[i]);
    }
  }
}
/*---------------------------------------------------------------------------*/
static void
get_char(u8_t c)
{
  if(c == ISO_cr) {
     33e:	8d 30       	cpi	r24, 0x0D	; 13
     340:	b9 f0       	breq	.+46     	; 0x370 <get_char+0x32>
    return;
  }
  
  s.buf[(int)s.bufptr] = c;
     342:	90 91 3b 03 	lds	r25, 0x033B
     346:	e9 2f       	mov	r30, r25
     348:	ff 27       	eor	r31, r31
     34a:	ef 5e       	subi	r30, 0xEF	; 239
     34c:	fc 4f       	sbci	r31, 0xFC	; 252
     34e:	82 83       	std	Z+2, r24	; 0x02
  if(s.buf[(int)s.bufptr] == ISO_nl ||
     350:	8a 30       	cpi	r24, 0x0A	; 10
     352:	11 f0       	breq	.+4      	; 0x358 <get_char+0x1a>
     354:	97 32       	cpi	r25, 0x27	; 39
     356:	49 f4       	brne	.+18     	; 0x36a <get_char+0x2c>
     s.bufptr == sizeof(s.buf) - 1) {
    if(s.bufptr > 0) {
     358:	91 11       	cpse	r25, r1
      s.buf[(int)s.bufptr] = 0;
     35a:	12 82       	std	Z+2, r1	; 0x02
      /*      petsciiconv_topetscii(s.buf, TELNETD_CONF_LINELEN);*/
    }
    shell_input(s.buf);
     35c:	83 e1       	ldi	r24, 0x13	; 19
     35e:	93 e0       	ldi	r25, 0x03	; 3
     360:	0e 94 5e 03 	call	0x6bc <shell_input>
    s.bufptr = 0;
     364:	10 92 3b 03 	sts	0x033B, r1
     368:	08 95       	ret
  } else {
    ++s.bufptr;
     36a:	9f 5f       	subi	r25, 0xFF	; 255
     36c:	90 93 3b 03 	sts	0x033B, r25
     370:	08 95       	ret

00000372 <sendopt>:
  }
}
/*---------------------------------------------------------------------------*/
static void
sendopt(u8_t option, u8_t value)
{
     372:	1f 93       	push	r17
     374:	cf 93       	push	r28
     376:	c8 2f       	mov	r28, r24
     378:	16 2f       	mov	r17, r22
  char *line;
  line = alloc_line();
     37a:	0e 94 f2 00 	call	0x1e4 <alloc_line>
     37e:	fc 01       	movw	r30, r24
  if(line != NULL) {
     380:	89 2b       	or	r24, r25
     382:	41 f0       	breq	.+16     	; 0x394 <sendopt+0x22>
    line[0] = TELNET_IAC;
     384:	8f ef       	ldi	r24, 0xFF	; 255
     386:	80 83       	st	Z, r24
    line[1] = option;
     388:	c1 83       	std	Z+1, r28	; 0x01
    line[2] = value;
     38a:	12 83       	std	Z+2, r17	; 0x02
    line[3] = 0;
     38c:	13 82       	std	Z+3, r1	; 0x03
    sendline(line);
     38e:	cf 01       	movw	r24, r30
     390:	0e 94 01 01 	call	0x202 <sendline>
     394:	cf 91       	pop	r28
     396:	1f 91       	pop	r17
     398:	08 95       	ret

0000039a <telnetd_appcall>:
  }
}
/*---------------------------------------------------------------------------*/
static void
newdata(void)
{
  u16_t len;
  u8_t c;
  char *dataptr;
    
  
  len = uip_datalen();
  dataptr = (char *)uip_appdata;
  
  while(len > 0 && s.bufptr < sizeof(s.buf)) {
    c = *dataptr;
    ++dataptr;
    --len;
    switch(s.state) {
    case STATE_IAC:
      if(c == TELNET_IAC) {
	get_char(c);
	s.state = STATE_NORMAL;
      } else {
	switch(c) {
	case TELNET_WILL:
	  s.state = STATE_WILL;
	  break;
	case TELNET_WONT:
	  s.state = STATE_WONT;
	  break;
	case TELNET_DO:
	  s.state = STATE_DO;
	  break;
	case TELNET_DONT:
	  s.state = STATE_DONT;
	  break;
	default:
	  s.state = STATE_NORMAL;
	  break;
	}
      }
      break;
    case STATE_WILL:
      /* Reply with a DONT */
      sendopt(TELNET_DONT, c);
      s.state = STATE_NORMAL;
      break;
      
    case STATE_WONT:
      /* Reply with a DONT */
      sendopt(TELNET_DONT, c);
      s.state = STATE_NORMAL;
      break;
    case STATE_DO:
      /* Reply with a WONT */
      sendopt(TELNET_WONT, c);
      s.state = STATE_NORMAL;
      break;
    case STATE_DONT:
      /* Reply with a WONT */
      sendopt(TELNET_WONT, c);
      s.state = STATE_NORMAL;
      break;
    case STATE_NORMAL:
      if(c == TELNET_IAC) {
	s.state = STATE_IAC;
      } else {
	get_char(c);
      }
      break;
    }

    
  }
  
}
/*---------------------------------------------------------------------------*/
void
telnetd_appcall(void)
{
     39a:	0f 93       	push	r16
     39c:	1f 93       	push	r17
     39e:	cf 93       	push	r28
     3a0:	df 93       	push	r29
  static unsigned int i;
  if(uip_connected()) {
     3a2:	80 91 73 03 	lds	r24, 0x0373
     3a6:	86 ff       	sbrs	r24, 6
     3a8:	18 c0       	rjmp	.+48     	; 0x3da <telnetd_appcall+0x40>
    /*    tcp_markconn(uip_conn, &s);*/
    for(i = 0; i < TELNETD_CONF_NUMLINES; ++i) {
     3aa:	10 92 db 02 	sts	0x02DB, r1
     3ae:	10 92 da 02 	sts	0x02DA, r1
     3b2:	e1 e1       	ldi	r30, 0x11	; 17
     3b4:	f3 e0       	ldi	r31, 0x03	; 3
      s.lines[i] = NULL;
     3b6:	11 92       	st	Z+, r1
     3b8:	11 92       	st	Z+, r1
     3ba:	83 e0       	ldi	r24, 0x03	; 3
     3bc:	e1 31       	cpi	r30, 0x11	; 17
     3be:	f8 07       	cpc	r31, r24
     3c0:	d1 f3       	breq	.-12     	; 0x3b6 <telnetd_appcall+0x1c>
     3c2:	81 e0       	ldi	r24, 0x01	; 1
     3c4:	90 e0       	ldi	r25, 0x00	; 0
     3c6:	90 93 db 02 	sts	0x02DB, r25
     3ca:	80 93 da 02 	sts	0x02DA, r24
    }
    s.bufptr = 0;
     3ce:	10 92 3b 03 	sts	0x033B, r1
    s.state = STATE_NORMAL;
     3d2:	10 92 3d 03 	sts	0x033D, r1

    shell_start();
     3d6:	0e 94 4d 03 	call	0x69a <shell_start>
  }

  if(s.state == STATE_CLOSE) {
     3da:	80 91 3d 03 	lds	r24, 0x033D
     3de:	86 30       	cpi	r24, 0x06	; 6
     3e0:	31 f4       	brne	.+12     	; 0x3ee <telnetd_appcall+0x54>
    s.state = STATE_NORMAL;
     3e2:	10 92 3d 03 	sts	0x033D, r1
    uip_close();
     3e6:	80 e1       	ldi	r24, 0x10	; 16
     3e8:	80 93 73 03 	sts	0x0373, r24
    return;
     3ec:	27 c1       	rjmp	.+590    	; 0x63c <telnetd_appcall+0x2a2>
  }
  
  if(uip_closed() ||
     3ee:	20 91 73 03 	lds	r18, 0x0373
     3f2:	82 2f       	mov	r24, r18
     3f4:	99 27       	eor	r25, r25
     3f6:	84 fd       	sbrc	r24, 4
     3f8:	04 c0       	rjmp	.+8      	; 0x402 <telnetd_appcall+0x68>
     3fa:	85 fd       	sbrc	r24, 5
     3fc:	02 c0       	rjmp	.+4      	; 0x402 <telnetd_appcall+0x68>
     3fe:	22 23       	and	r18, r18
     400:	ec f4       	brge	.+58     	; 0x43c <telnetd_appcall+0xa2>
     402:	10 92 dd 02 	sts	0x02DD, r1
     406:	10 92 dc 02 	sts	0x02DC, r1
     40a:	e0 91 dc 02 	lds	r30, 0x02DC
     40e:	f0 91 dd 02 	lds	r31, 0x02DD
     412:	ee 0f       	add	r30, r30
     414:	ff 1f       	adc	r31, r31
     416:	ef 5e       	subi	r30, 0xEF	; 239
     418:	fc 4f       	sbci	r31, 0xFC	; 252
     41a:	80 81       	ld	r24, Z
     41c:	91 81       	ldd	r25, Z+1	; 0x01
     41e:	00 97       	sbiw	r24, 0x00	; 0
     420:	11 f0       	breq	.+4      	; 0x426 <telnetd_appcall+0x8c>
     422:	0e 94 f7 00 	call	0x1ee <dealloc_line>
     426:	80 91 dc 02 	lds	r24, 0x02DC
     42a:	90 91 dd 02 	lds	r25, 0x02DD
     42e:	01 96       	adiw	r24, 0x01	; 1
     430:	90 93 dd 02 	sts	0x02DD, r25
     434:	80 93 dc 02 	sts	0x02DC, r24
     438:	89 2b       	or	r24, r25
     43a:	39 f3       	breq	.-50     	; 0x40a <telnetd_appcall+0x70>
     uip_aborted() ||
     uip_timedout()) {
    closed();
  }
  
  if(uip_acked()) {
     43c:	80 91 73 03 	lds	r24, 0x0373
     440:	80 ff       	sbrs	r24, 0
     442:	1a c0       	rjmp	.+52     	; 0x478 <telnetd_appcall+0xde>
     444:	80 91 3c 03 	lds	r24, 0x033C
     448:	88 23       	and	r24, r24
     44a:	b1 f0       	breq	.+44     	; 0x478 <telnetd_appcall+0xde>
     44c:	80 91 11 03 	lds	r24, 0x0311
     450:	90 91 12 03 	lds	r25, 0x0312
     454:	0e 94 f7 00 	call	0x1ee <dealloc_line>
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	90 93 df 02 	sts	0x02DF, r25
     460:	80 93 de 02 	sts	0x02DE, r24
     464:	10 92 12 03 	sts	0x0312, r1
     468:	10 92 11 03 	sts	0x0311, r1
     46c:	80 91 3c 03 	lds	r24, 0x033C
     470:	81 50       	subi	r24, 0x01	; 1
     472:	80 93 3c 03 	sts	0x033C, r24
     476:	e8 cf       	rjmp	.-48     	; 0x448 <telnetd_appcall+0xae>
    acked();
  }
  
  if(uip_newdata()) {
     478:	80 91 73 03 	lds	r24, 0x0373
     47c:	81 ff       	sbrs	r24, 1
     47e:	5d c0       	rjmp	.+186    	; 0x53a <telnetd_appcall+0x1a0>
     480:	c0 91 6b 03 	lds	r28, 0x036B
     484:	d0 91 6c 03 	lds	r29, 0x036C
     488:	00 91 74 03 	lds	r16, 0x0374
     48c:	10 91 75 03 	lds	r17, 0x0375
     490:	51 c0       	rjmp	.+162    	; 0x534 <telnetd_appcall+0x19a>
     492:	80 91 3b 03 	lds	r24, 0x033B
     496:	88 32       	cpi	r24, 0x28	; 40
     498:	08 f0       	brcs	.+2      	; 0x49c <telnetd_appcall+0x102>
     49a:	4f c0       	rjmp	.+158    	; 0x53a <telnetd_appcall+0x1a0>
     49c:	f8 01       	movw	r30, r16
     49e:	61 91       	ld	r22, Z+
     4a0:	8f 01       	movw	r16, r30
     4a2:	21 97       	sbiw	r28, 0x01	; 1
     4a4:	80 91 3d 03 	lds	r24, 0x033D
     4a8:	99 27       	eor	r25, r25
     4aa:	82 30       	cpi	r24, 0x02	; 2
     4ac:	91 05       	cpc	r25, r1
     4ae:	89 f1       	breq	.+98     	; 0x512 <telnetd_appcall+0x178>
     4b0:	83 30       	cpi	r24, 0x03	; 3
     4b2:	91 05       	cpc	r25, r1
     4b4:	2c f4       	brge	.+10     	; 0x4c0 <telnetd_appcall+0x126>
     4b6:	00 97       	sbiw	r24, 0x00	; 0
     4b8:	a1 f1       	breq	.+104    	; 0x522 <telnetd_appcall+0x188>
     4ba:	01 97       	sbiw	r24, 0x01	; 1
     4bc:	51 f0       	breq	.+20     	; 0x4d2 <telnetd_appcall+0x138>
     4be:	3a c0       	rjmp	.+116    	; 0x534 <telnetd_appcall+0x19a>
     4c0:	84 30       	cpi	r24, 0x04	; 4
     4c2:	91 05       	cpc	r25, r1
     4c4:	41 f1       	breq	.+80     	; 0x516 <telnetd_appcall+0x17c>
     4c6:	84 30       	cpi	r24, 0x04	; 4
     4c8:	91 05       	cpc	r25, r1
     4ca:	1c f1       	brlt	.+70     	; 0x512 <telnetd_appcall+0x178>
     4cc:	05 97       	sbiw	r24, 0x05	; 5
     4ce:	19 f1       	breq	.+70     	; 0x516 <telnetd_appcall+0x17c>
     4d0:	31 c0       	rjmp	.+98     	; 0x534 <telnetd_appcall+0x19a>
     4d2:	6f 3f       	cpi	r22, 0xFF	; 255
     4d4:	21 f4       	brne	.+8      	; 0x4de <telnetd_appcall+0x144>
     4d6:	86 2f       	mov	r24, r22
     4d8:	0e 94 9f 01 	call	0x33e <get_char>
     4dc:	1f c0       	rjmp	.+62     	; 0x51c <telnetd_appcall+0x182>
     4de:	77 27       	eor	r23, r23
     4e0:	6c 3f       	cpi	r22, 0xFC	; 252
     4e2:	71 05       	cpc	r23, r1
     4e4:	81 f0       	breq	.+32     	; 0x506 <telnetd_appcall+0x16c>
     4e6:	6d 3f       	cpi	r22, 0xFD	; 253
     4e8:	71 05       	cpc	r23, r1
     4ea:	24 f4       	brge	.+8      	; 0x4f4 <telnetd_appcall+0x15a>
     4ec:	6b 3f       	cpi	r22, 0xFB	; 251
     4ee:	71 05       	cpc	r23, r1
     4f0:	41 f0       	breq	.+16     	; 0x502 <telnetd_appcall+0x168>
     4f2:	14 c0       	rjmp	.+40     	; 0x51c <telnetd_appcall+0x182>
     4f4:	6d 3f       	cpi	r22, 0xFD	; 253
     4f6:	71 05       	cpc	r23, r1
     4f8:	41 f0       	breq	.+16     	; 0x50a <telnetd_appcall+0x170>
     4fa:	6e 3f       	cpi	r22, 0xFE	; 254
     4fc:	71 05       	cpc	r23, r1
     4fe:	39 f0       	breq	.+14     	; 0x50e <telnetd_appcall+0x174>
     500:	0d c0       	rjmp	.+26     	; 0x51c <telnetd_appcall+0x182>
     502:	82 e0       	ldi	r24, 0x02	; 2
     504:	11 c0       	rjmp	.+34     	; 0x528 <telnetd_appcall+0x18e>
     506:	83 e0       	ldi	r24, 0x03	; 3
     508:	0f c0       	rjmp	.+30     	; 0x528 <telnetd_appcall+0x18e>
     50a:	84 e0       	ldi	r24, 0x04	; 4
     50c:	0d c0       	rjmp	.+26     	; 0x528 <telnetd_appcall+0x18e>
     50e:	85 e0       	ldi	r24, 0x05	; 5
     510:	0b c0       	rjmp	.+22     	; 0x528 <telnetd_appcall+0x18e>
     512:	8e ef       	ldi	r24, 0xFE	; 254
     514:	01 c0       	rjmp	.+2      	; 0x518 <telnetd_appcall+0x17e>
     516:	8c ef       	ldi	r24, 0xFC	; 252
     518:	0e 94 b9 01 	call	0x372 <sendopt>
     51c:	10 92 3d 03 	sts	0x033D, r1
     520:	09 c0       	rjmp	.+18     	; 0x534 <telnetd_appcall+0x19a>
     522:	6f 3f       	cpi	r22, 0xFF	; 255
     524:	21 f4       	brne	.+8      	; 0x52e <telnetd_appcall+0x194>
     526:	81 e0       	ldi	r24, 0x01	; 1
     528:	80 93 3d 03 	sts	0x033D, r24
     52c:	03 c0       	rjmp	.+6      	; 0x534 <telnetd_appcall+0x19a>
     52e:	86 2f       	mov	r24, r22
     530:	0e 94 9f 01 	call	0x33e <get_char>
     534:	20 97       	sbiw	r28, 0x00	; 0
     536:	09 f0       	breq	.+2      	; 0x53a <telnetd_appcall+0x1a0>
     538:	ac cf       	rjmp	.-168    	; 0x492 <telnetd_appcall+0xf8>
    newdata();
  }
  
  if(uip_rexmit() ||
     53a:	80 91 73 03 	lds	r24, 0x0373
     53e:	99 27       	eor	r25, r25
     540:	82 fd       	sbrc	r24, 2
     542:	08 c0       	rjmp	.+16     	; 0x554 <telnetd_appcall+0x1ba>
     544:	81 fd       	sbrc	r24, 1
     546:	06 c0       	rjmp	.+12     	; 0x554 <telnetd_appcall+0x1ba>
     548:	80 fd       	sbrc	r24, 0
     54a:	04 c0       	rjmp	.+8      	; 0x554 <telnetd_appcall+0x1ba>
     54c:	86 fd       	sbrc	r24, 6
     54e:	02 c0       	rjmp	.+4      	; 0x554 <telnetd_appcall+0x1ba>
     550:	83 ff       	sbrs	r24, 3
     552:	74 c0       	rjmp	.+232    	; 0x63c <telnetd_appcall+0x2a2>
     554:	80 91 74 03 	lds	r24, 0x0374
     558:	90 91 75 03 	lds	r25, 0x0375
     55c:	90 93 e1 02 	sts	0x02E1, r25
     560:	80 93 e0 02 	sts	0x02E0, r24
     564:	10 92 e5 02 	sts	0x02E5, r1
     568:	10 92 e4 02 	sts	0x02E4, r1
     56c:	10 92 3c 03 	sts	0x033C, r1
     570:	80 91 11 03 	lds	r24, 0x0311
     574:	90 91 12 03 	lds	r25, 0x0312
     578:	89 2b       	or	r24, r25
     57a:	09 f4       	brne	.+2      	; 0x57e <telnetd_appcall+0x1e4>
     57c:	55 c0       	rjmp	.+170    	; 0x628 <telnetd_appcall+0x28e>
     57e:	a0 91 11 03 	lds	r26, 0x0311
     582:	b0 91 12 03 	lds	r27, 0x0312
     586:	b0 93 e3 02 	sts	0x02E3, r27
     58a:	a0 93 e2 02 	sts	0x02E2, r26
     58e:	fd 01       	movw	r30, r26
     590:	01 90       	ld	r0, Z+
     592:	00 20       	and	r0, r0
     594:	e9 f7       	brne	.-6      	; 0x590 <telnetd_appcall+0x1f6>
     596:	31 97       	sbiw	r30, 0x01	; 1
     598:	ea 1b       	sub	r30, r26
     59a:	fb 0b       	sbc	r31, r27
     59c:	f0 93 e7 02 	sts	0x02E7, r31
     5a0:	e0 93 e6 02 	sts	0x02E6, r30
     5a4:	b9 97       	sbiw	r30, 0x29	; 41
     5a6:	34 f0       	brlt	.+12     	; 0x5b4 <telnetd_appcall+0x21a>
     5a8:	88 e2       	ldi	r24, 0x28	; 40
     5aa:	90 e0       	ldi	r25, 0x00	; 0
     5ac:	90 93 e7 02 	sts	0x02E7, r25
     5b0:	80 93 e6 02 	sts	0x02E6, r24
     5b4:	80 91 e4 02 	lds	r24, 0x02E4
     5b8:	90 91 e5 02 	lds	r25, 0x02E5
     5bc:	40 91 e6 02 	lds	r20, 0x02E6
     5c0:	50 91 e7 02 	lds	r21, 0x02E7
     5c4:	84 0f       	add	r24, r20
     5c6:	95 1f       	adc	r25, r21
     5c8:	e0 91 76 03 	lds	r30, 0x0376
     5cc:	f0 91 77 03 	lds	r31, 0x0377
     5d0:	22 89       	ldd	r18, Z+18	; 0x12
     5d2:	33 89       	ldd	r19, Z+19	; 0x13
     5d4:	82 17       	cp	r24, r18
     5d6:	93 07       	cpc	r25, r19
     5d8:	38 f5       	brcc	.+78     	; 0x628 <telnetd_appcall+0x28e>
     5da:	bd 01       	movw	r22, r26
     5dc:	80 91 e0 02 	lds	r24, 0x02E0
     5e0:	90 91 e1 02 	lds	r25, 0x02E1
     5e4:	0e 94 8d 16 	call	0x2d1a <memcpy>
     5e8:	80 91 e0 02 	lds	r24, 0x02E0
     5ec:	90 91 e1 02 	lds	r25, 0x02E1
     5f0:	20 91 e6 02 	lds	r18, 0x02E6
     5f4:	30 91 e7 02 	lds	r19, 0x02E7
     5f8:	82 0f       	add	r24, r18
     5fa:	93 1f       	adc	r25, r19
     5fc:	90 93 e1 02 	sts	0x02E1, r25
     600:	80 93 e0 02 	sts	0x02E0, r24
     604:	80 91 e4 02 	lds	r24, 0x02E4
     608:	90 91 e5 02 	lds	r25, 0x02E5
     60c:	82 0f       	add	r24, r18
     60e:	93 1f       	adc	r25, r19
     610:	90 93 e5 02 	sts	0x02E5, r25
     614:	80 93 e4 02 	sts	0x02E4, r24
     618:	80 91 3c 03 	lds	r24, 0x033C
     61c:	8f 5f       	subi	r24, 0xFF	; 255
     61e:	80 93 3c 03 	sts	0x033C, r24
     622:	88 23       	and	r24, r24
     624:	09 f4       	brne	.+2      	; 0x628 <telnetd_appcall+0x28e>
     626:	a4 cf       	rjmp	.-184    	; 0x570 <telnetd_appcall+0x1d6>
     628:	60 91 e4 02 	lds	r22, 0x02E4
     62c:	70 91 e5 02 	lds	r23, 0x02E5
     630:	80 91 74 03 	lds	r24, 0x0374
     634:	90 91 75 03 	lds	r25, 0x0375
     638:	0e 94 ad 0c 	call	0x195a <uip_send>
     63c:	df 91       	pop	r29
     63e:	cf 91       	pop	r28
     640:	1f 91       	pop	r17
     642:	0f 91       	pop	r16
     644:	08 95       	ret

00000646 <help>:
/*---------------------------------------------------------------------------*/
static void
help(char *str)
{
  shell_output("Available commands:", "");
     646:	6d ec       	ldi	r22, 0xCD	; 205
     648:	70 e0       	ldi	r23, 0x00	; 0
     64a:	8e ec       	ldi	r24, 0xCE	; 206
     64c:	90 e0       	ldi	r25, 0x00	; 0
     64e:	0e 94 39 01 	call	0x272 <shell_output>
  shell_output("stats   - show network statistics", "");
     652:	6d ec       	ldi	r22, 0xCD	; 205
     654:	70 e0       	ldi	r23, 0x00	; 0
     656:	82 ee       	ldi	r24, 0xE2	; 226
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	0e 94 39 01 	call	0x272 <shell_output>
  shell_output("conn    - show TCP connections", "");
     65e:	6d ec       	ldi	r22, 0xCD	; 205
     660:	70 e0       	ldi	r23, 0x00	; 0
     662:	84 e0       	ldi	r24, 0x04	; 4
     664:	91 e0       	ldi	r25, 0x01	; 1
     666:	0e 94 39 01 	call	0x272 <shell_output>
  shell_output("help, ? - show help", "");
     66a:	6d ec       	ldi	r22, 0xCD	; 205
     66c:	70 e0       	ldi	r23, 0x00	; 0
     66e:	83 e2       	ldi	r24, 0x23	; 35
     670:	91 e0       	ldi	r25, 0x01	; 1
     672:	0e 94 39 01 	call	0x272 <shell_output>
  shell_output("exit    - exit shell", "");
     676:	6d ec       	ldi	r22, 0xCD	; 205
     678:	70 e0       	ldi	r23, 0x00	; 0
     67a:	87 e3       	ldi	r24, 0x37	; 55
     67c:	91 e0       	ldi	r25, 0x01	; 1
     67e:	0e 94 39 01 	call	0x272 <shell_output>
     682:	08 95       	ret

00000684 <unknown>:
}
/*---------------------------------------------------------------------------*/
static void
unknown(char *str)
{
     684:	fc 01       	movw	r30, r24
  if(strlen(str) > 0) {
     686:	80 81       	ld	r24, Z
     688:	88 23       	and	r24, r24
     68a:	29 f0       	breq	.+10     	; 0x696 <unknown+0x12>
    shell_output("Unknown command: ", str);
     68c:	bf 01       	movw	r22, r30
     68e:	8c e4       	ldi	r24, 0x4C	; 76
     690:	91 e0       	ldi	r25, 0x01	; 1
     692:	0e 94 39 01 	call	0x272 <shell_output>
     696:	08 95       	ret

00000698 <shell_init>:
  }
}
/*---------------------------------------------------------------------------*/
static struct ptentry parsetab[] =
  {{"stats", help},
   {"conn", help},
   {"help", help},
   {"exit", shell_quit},
   {"?", help},

   /* Default action */
   {NULL, unknown}};
/*---------------------------------------------------------------------------*/
void
shell_init(void)
{
     698:	08 95       	ret

0000069a <shell_start>:
}
/*---------------------------------------------------------------------------*/
void
shell_start(void)
{
  shell_output("uIP command shell", "");
     69a:	6d ec       	ldi	r22, 0xCD	; 205
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	8e e5       	ldi	r24, 0x5E	; 94
     6a0:	91 e0       	ldi	r25, 0x01	; 1
     6a2:	0e 94 39 01 	call	0x272 <shell_output>
  shell_output("Type '?' and return for help", "");
     6a6:	6d ec       	ldi	r22, 0xCD	; 205
     6a8:	70 e0       	ldi	r23, 0x00	; 0
     6aa:	80 e7       	ldi	r24, 0x70	; 112
     6ac:	91 e0       	ldi	r25, 0x01	; 1
     6ae:	0e 94 39 01 	call	0x272 <shell_output>
  shell_prompt(SHELL_PROMPT);
     6b2:	8d e8       	ldi	r24, 0x8D	; 141
     6b4:	91 e0       	ldi	r25, 0x01	; 1
     6b6:	0e 94 22 01 	call	0x244 <shell_prompt>
     6ba:	08 95       	ret

000006bc <shell_input>:
}
/*---------------------------------------------------------------------------*/
void
shell_input(char *cmd)
{
     6bc:	0f 93       	push	r16
     6be:	1f 93       	push	r17
     6c0:	cf 93       	push	r28
     6c2:	df 93       	push	r29
     6c4:	8c 01       	movw	r16, r24
     6c6:	c5 eb       	ldi	r28, 0xB5	; 181
     6c8:	d0 e0       	ldi	r29, 0x00	; 0
     6ca:	80 91 b5 00 	lds	r24, 0x00B5
     6ce:	90 91 b6 00 	lds	r25, 0x00B6
     6d2:	89 2b       	or	r24, r25
     6d4:	a1 f0       	breq	.+40     	; 0x6fe <shell_input+0x42>
     6d6:	a8 81       	ld	r26, Y
     6d8:	b9 81       	ldd	r27, Y+1	; 0x01
     6da:	fd 01       	movw	r30, r26
     6dc:	01 90       	ld	r0, Z+
     6de:	00 20       	and	r0, r0
     6e0:	e9 f7       	brne	.-6      	; 0x6dc <shell_input+0x20>
     6e2:	31 97       	sbiw	r30, 0x01	; 1
     6e4:	ea 1b       	sub	r30, r26
     6e6:	fb 0b       	sbc	r31, r27
     6e8:	af 01       	movw	r20, r30
     6ea:	b8 01       	movw	r22, r16
     6ec:	cd 01       	movw	r24, r26
     6ee:	0e 94 a4 16 	call	0x2d48 <strncmp>
     6f2:	89 2b       	or	r24, r25
     6f4:	21 f0       	breq	.+8      	; 0x6fe <shell_input+0x42>
     6f6:	24 96       	adiw	r28, 0x04	; 4
     6f8:	88 81       	ld	r24, Y
     6fa:	99 81       	ldd	r25, Y+1	; 0x01
     6fc:	ea cf       	rjmp	.-44     	; 0x6d2 <shell_input+0x16>
     6fe:	ea 81       	ldd	r30, Y+2	; 0x02
     700:	fb 81       	ldd	r31, Y+3	; 0x03
     702:	c8 01       	movw	r24, r16
     704:	09 95       	icall
  parse(cmd, parsetab);
  shell_prompt(SHELL_PROMPT);
     706:	8d e8       	ldi	r24, 0x8D	; 141
     708:	91 e0       	ldi	r25, 0x01	; 1
     70a:	0e 94 22 01 	call	0x244 <shell_prompt>
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	1f 91       	pop	r17
     714:	0f 91       	pop	r16
     716:	08 95       	ret

00000718 <uip_setipid>:
static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
     718:	90 93 3f 03 	sts	0x033F, r25
     71c:	80 93 3e 03 	sts	0x033E, r24
     720:	08 95       	ret

00000722 <uip_add32>:

static u8_t iss[4];          /* The iss variable is used for the TCP
				initial sequence number. */

#if UIP_ACTIVE_OPEN
static u16_t lastport;       /* Keeps track of the last port used for
				a new connection. */
#endif /* UIP_ACTIVE_OPEN */

/* Temporary variables. */
u8_t uip_acc32[4];
static u8_t c, opt;
static u16_t tmp16;

/* Structures and definitions. */
#define TCP_FIN 0x01
#define TCP_SYN 0x02
#define TCP_RST 0x04
#define TCP_PSH 0x08
#define TCP_ACK 0x10
#define TCP_URG 0x20
#define TCP_CTL 0x3f

#define TCP_OPT_END     0   /* End of TCP options list */
#define TCP_OPT_NOOP    1   /* "No-operation" TCP option */
#define TCP_OPT_MSS     2   /* Maximum segment size TCP option */

#define TCP_OPT_MSS_LEN 4   /* Length of TCP MSS option. */

#define ICMP_ECHO_REPLY 0
#define ICMP_ECHO       8

#define ICMP6_ECHO_REPLY             129
#define ICMP6_ECHO                   128
#define ICMP6_NEIGHBOR_SOLICITATION  135
#define ICMP6_NEIGHBOR_ADVERTISEMENT 136

#define ICMP6_FLAG_S (1 << 6)

#define ICMP6_OPTION_SOURCE_LINK_ADDRESS 1
#define ICMP6_OPTION_TARGET_LINK_ADDRESS 2


/* Macros. */
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define FBUF ((struct uip_tcpip_hdr *)&uip_reassbuf[0])
#define ICMPBUF ((struct uip_icmpip_hdr *)&uip_buf[UIP_LLH_LEN])
#define UDPBUF ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])


#if UIP_STATISTICS == 1
struct uip_stats uip_stat;
#define UIP_STAT(s) s
#else
#define UIP_STAT(s)
#endif /* UIP_STATISTICS == 1 */

#if UIP_LOGGING == 1
#include <stdio.h>
void uip_log(char *msg);
#define UIP_LOG(m) uip_log(m)
#else
#define UIP_LOG(m)
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
     722:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
     724:	83 81       	ldd	r24, Z+3	; 0x03
     726:	86 0f       	add	r24, r22
     728:	80 93 72 03 	sts	0x0372, r24
  uip_acc32[2] = op32[2] + (op16 >> 8);
     72c:	27 2f       	mov	r18, r23
     72e:	33 27       	eor	r19, r19
     730:	82 81       	ldd	r24, Z+2	; 0x02
     732:	82 0f       	add	r24, r18
     734:	80 93 71 03 	sts	0x0371, r24
  uip_acc32[1] = op32[1];
     738:	41 81       	ldd	r20, Z+1	; 0x01
     73a:	40 93 70 03 	sts	0x0370, r20
  uip_acc32[0] = op32[0];
     73e:	e0 81       	ld	r30, Z
     740:	e0 93 6f 03 	sts	0x036F, r30
  
  if(uip_acc32[2] < (op16 >> 8)) {
     744:	99 27       	eor	r25, r25
     746:	82 17       	cp	r24, r18
     748:	93 07       	cpc	r25, r19
     74a:	48 f4       	brcc	.+18     	; 0x75e <uip_add32+0x3c>
    ++uip_acc32[1];
     74c:	84 2f       	mov	r24, r20
     74e:	8f 5f       	subi	r24, 0xFF	; 255
     750:	80 93 70 03 	sts	0x0370, r24
    if(uip_acc32[1] == 0) {
     754:	88 23       	and	r24, r24
     756:	19 f4       	brne	.+6      	; 0x75e <uip_add32+0x3c>
      ++uip_acc32[0];
     758:	ef 5f       	subi	r30, 0xFF	; 255
     75a:	e0 93 6f 03 	sts	0x036F, r30
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
     75e:	80 91 72 03 	lds	r24, 0x0372
     762:	99 27       	eor	r25, r25
     764:	70 70       	andi	r23, 0x00	; 0
     766:	86 17       	cp	r24, r22
     768:	97 07       	cpc	r25, r23
     76a:	98 f4       	brcc	.+38     	; 0x792 <uip_add32+0x70>
    ++uip_acc32[2];
     76c:	80 91 71 03 	lds	r24, 0x0371
     770:	8f 5f       	subi	r24, 0xFF	; 255
     772:	80 93 71 03 	sts	0x0371, r24
    if(uip_acc32[2] == 0) {
     776:	88 23       	and	r24, r24
     778:	61 f4       	brne	.+24     	; 0x792 <uip_add32+0x70>
      ++uip_acc32[1];
     77a:	80 91 70 03 	lds	r24, 0x0370
     77e:	8f 5f       	subi	r24, 0xFF	; 255
     780:	80 93 70 03 	sts	0x0370, r24
      if(uip_acc32[1] == 0) {
     784:	88 23       	and	r24, r24
     786:	29 f4       	brne	.+10     	; 0x792 <uip_add32+0x70>
	++uip_acc32[0];
     788:	80 91 6f 03 	lds	r24, 0x036F
     78c:	8f 5f       	subi	r24, 0xFF	; 255
     78e:	80 93 6f 03 	sts	0x036F, r24
     792:	08 95       	ret

00000794 <chksum>:
      }
    }
  }
}

#endif /* UIP_ARCH_ADD32 */

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
     794:	dc 01       	movw	r26, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
     796:	fb 01       	movw	r30, r22
  last_byte = data + len - 1;
     798:	46 0f       	add	r20, r22
     79a:	57 1f       	adc	r21, r23
     79c:	41 50       	subi	r20, 0x01	; 1
     79e:	50 40       	sbci	r21, 0x00	; 0
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    sum += t;
    if(sum < t) {
      sum++;		/* carry */
    }
    dataptr += 2;
     7a0:	e4 17       	cp	r30, r20
     7a2:	f5 07       	cpc	r31, r21
     7a4:	78 f4       	brcc	.+30     	; 0x7c4 <chksum+0x30>
     7a6:	80 81       	ld	r24, Z
     7a8:	99 27       	eor	r25, r25
     7aa:	38 2f       	mov	r19, r24
     7ac:	22 27       	eor	r18, r18
     7ae:	81 81       	ldd	r24, Z+1	; 0x01
     7b0:	28 0f       	add	r18, r24
     7b2:	31 1d       	adc	r19, r1
     7b4:	a2 0f       	add	r26, r18
     7b6:	b3 1f       	adc	r27, r19
     7b8:	a2 17       	cp	r26, r18
     7ba:	b3 07       	cpc	r27, r19
     7bc:	08 f4       	brcc	.+2      	; 0x7c0 <chksum+0x2c>
     7be:	11 96       	adiw	r26, 0x01	; 1
     7c0:	32 96       	adiw	r30, 0x02	; 2
     7c2:	ee cf       	rjmp	.-36     	; 0x7a0 <chksum+0xc>
  }
  
  if(dataptr == last_byte) {
     7c4:	e4 17       	cp	r30, r20
     7c6:	f5 07       	cpc	r31, r21
     7c8:	51 f4       	brne	.+20     	; 0x7de <chksum+0x4a>
    t = (dataptr[0] << 8) + 0;
     7ca:	80 81       	ld	r24, Z
     7cc:	99 27       	eor	r25, r25
     7ce:	38 2f       	mov	r19, r24
     7d0:	22 27       	eor	r18, r18
    sum += t;
     7d2:	a2 0f       	add	r26, r18
     7d4:	b3 1f       	adc	r27, r19
    if(sum < t) {
     7d6:	a2 17       	cp	r26, r18
     7d8:	b3 07       	cpc	r27, r19
     7da:	08 f4       	brcc	.+2      	; 0x7de <chksum+0x4a>
      sum++;		/* carry */
     7dc:	11 96       	adiw	r26, 0x01	; 1
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
     7de:	cd 01       	movw	r24, r26
     7e0:	08 95       	ret

000007e2 <htons>:
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
  return htons(chksum(0, (u8_t *)data, len));
}
/*---------------------------------------------------------------------------*/
#ifndef UIP_ARCH_IPCHKSUM
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}
#endif
/*---------------------------------------------------------------------------*/
static u16_t
upper_layer_chksum(u8_t proto)
{
  u16_t upper_layer_len;
  u16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
#endif /* UIP_CONF_IPV6 */
  
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
}
/*---------------------------------------------------------------------------*/
#if UIP_CONF_IPV6
u16_t
uip_icmp6chksum(void)
{
  return upper_layer_chksum(UIP_PROTO_ICMP6);
  
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
/*---------------------------------------------------------------------------*/
#if UIP_UDP_CHECKSUMS
u16_t
uip_udpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_UDP);
}
#endif /* UIP_UDP_CHECKSUMS */
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
#endif /* UIP_ACTIVE_OPEN */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    uip_udp_conns[c].lport = 0;
  }
#endif /* UIP_UDP */
  

  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
/*---------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;

  if(lastport >= 32000) {
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    if(conn->tcpstateflags != UIP_CLOSED &&
       conn->lport == htons(lastport)) {
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
      if(conn == 0 ||
	 cconn->timer > conn->timer) {
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;

  conn->snd_nxt[0] = iss[0];
  conn->snd_nxt[1] = iss[1];
  conn->snd_nxt[2] = iss[2];
  conn->snd_nxt[3] = iss[3];

  conn->initialmss = conn->mss = UIP_TCP_MSS;
  
  conn->len = 1;   /* TCP length of the SYN is one. */
  conn->nrtx = 0;
  conn->timer = 1; /* Send the SYN next time around. */
  conn->rto = UIP_RTO;
  conn->sa = 0;
  conn->sv = 16;   /* Initial value of the RTT variance. */
  conn->lport = htons(lastport);
  conn->rport = rport;
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  
  return conn;
}
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(uip_ipaddr_t *ripaddr, u16_t rport)
{
  register struct uip_udp_conn *conn;
  
  /* Find an unused local port. */
 again:
  ++lastport;

  if(lastport >= 32000) {
    lastport = 4096;
  }
  
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
      goto again;
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
      conn = &uip_udp_conns[c];
      break;
    }
  }

  if(conn == 0) {
    return 0;
  }
  
  conn->lport = HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(conn->ripaddr, 0, sizeof(uip_ipaddr_t));
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  }
  conn->ttl = UIP_TTL;
  
  return conn;
}
#endif /* UIP_UDP */
/*---------------------------------------------------------------------------*/
void
uip_unlisten(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == port) {
      uip_listenports[c] = 0;
      return;
    }
  }
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
      uip_listenports[c] = port;
      return;
    }
  }
}
/*---------------------------------------------------------------------------*/
/* XXX: IP fragment reassembly: not well-tested. */

#if UIP_REASSEMBLY && !UIP_CONF_IPV6
#define UIP_REASS_BUFSIZE (UIP_BUFSIZE - UIP_LLH_LEN)
static u8_t uip_reassbuf[UIP_REASS_BUFSIZE];
static u8_t uip_reassbitmap[UIP_REASS_BUFSIZE / (8 * 8)];
static const u8_t bitmap_bits[8] = {0xff, 0x7f, 0x3f, 0x1f,
				    0x0f, 0x07, 0x03, 0x01};
static u16_t uip_reasslen;
static u8_t uip_reassflags;
#define UIP_REASS_FLAG_LASTFRAG 0x01
static u8_t uip_reasstmr;

#define IP_MF   0x20

static u8_t
uip_reass(void)
{
  u16_t offset, len;
  u16_t i;

  /* If ip_reasstmr is zero, no packet is present in the buffer, so we
     write the IP header of the fragment into the reassembly
     buffer. The timer is updated with the maximum age. */
  if(uip_reasstmr == 0) {
    memcpy(uip_reassbuf, &BUF->vhl, UIP_IPH_LEN);
    uip_reasstmr = UIP_REASS_MAXAGE;
    uip_reassflags = 0;
    /* Clear the bitmap. */
    memset(uip_reassbitmap, 0, sizeof(uip_reassbitmap));
  }

  /* Check if the incoming fragment matches the one currently present
     in the reasembly buffer. If so, we proceed with copying the
     fragment into the buffer. */
  if(BUF->srcipaddr[0] == FBUF->srcipaddr[0] &&
     BUF->srcipaddr[1] == FBUF->srcipaddr[1] &&
     BUF->destipaddr[0] == FBUF->destipaddr[0] &&
     BUF->destipaddr[1] == FBUF->destipaddr[1] &&
     BUF->ipid[0] == FBUF->ipid[0] &&
     BUF->ipid[1] == FBUF->ipid[1]) {

    len = (BUF->len[0] << 8) + BUF->len[1] - (BUF->vhl & 0x0f) * 4;
    offset = (((BUF->ipoffset[0] & 0x3f) << 8) + BUF->ipoffset[1]) * 8;

    /* If the offset or the offset + fragment length overflows the
       reassembly buffer, we discard the entire packet. */
    if(offset > UIP_REASS_BUFSIZE ||
       offset + len > UIP_REASS_BUFSIZE) {
      uip_reasstmr = 0;
      goto nullreturn;
    }

    /* Copy the fragment into the reassembly buffer, at the right
       offset. */
    memcpy(&uip_reassbuf[UIP_IPH_LEN + offset],
	   (char *)BUF + (int)((BUF->vhl & 0x0f) * 4),
	   len);
      
    /* Update the bitmap. */
    if(offset / (8 * 8) == (offset + len) / (8 * 8)) {
      /* If the two endpoints are in the same byte, we only update
	 that byte. */
	     
      uip_reassbitmap[offset / (8 * 8)] |=
	     bitmap_bits[(offset / 8 ) & 7] &
	     ~bitmap_bits[((offset + len) / 8 ) & 7];
    } else {
      /* If the two endpoints are in different bytes, we update the
	 bytes in the endpoints and fill the stuff inbetween with
	 0xff. */
      uip_reassbitmap[offset / (8 * 8)] |=
	bitmap_bits[(offset / 8 ) & 7];
      for(i = 1 + offset / (8 * 8); i < (offset + len) / (8 * 8); ++i) {
	uip_reassbitmap[i] = 0xff;
      }
      uip_reassbitmap[(offset + len) / (8 * 8)] |=
	~bitmap_bits[((offset + len) / 8 ) & 7];
    }
    
    /* If this fragment has the More Fragments flag set to zero, we
       know that this is the last fragment, so we can calculate the
       size of the entire packet. We also set the
       IP_REASS_FLAG_LASTFRAG flag to indicate that we have received
       the final fragment. */

    if((BUF->ipoffset[0] & IP_MF) == 0) {
      uip_reassflags |= UIP_REASS_FLAG_LASTFRAG;
      uip_reasslen = offset + len;
    }
    
    /* Finally, we check if we have a full packet in the buffer. We do
       this by checking if we have the last fragment and if all bits
       in the bitmap are set. */
    if(uip_reassflags & UIP_REASS_FLAG_LASTFRAG) {
      /* Check all bytes up to and including all but the last byte in
	 the bitmap. */
      for(i = 0; i < uip_reasslen / (8 * 8) - 1; ++i) {
	if(uip_reassbitmap[i] != 0xff) {
	  goto nullreturn;
	}
      }
      /* Check the last byte in the bitmap. It should contain just the
	 right amount of bits. */
      if(uip_reassbitmap[uip_reasslen / (8 * 8)] !=
	 (u8_t)~bitmap_bits[uip_reasslen / 8 & 7]) {
	goto nullreturn;
      }

      /* If we have come this far, we have a full packet in the
	 buffer, so we allocate a pbuf and copy the packet into it. We
	 also reset the timer. */
      uip_reasstmr = 0;
      memcpy(BUF, FBUF, uip_reasslen);

      /* Pretend to be a "normal" (i.e., not fragmented) IP packet
	 from now on. */
      BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
      BUF->len[0] = uip_reasslen >> 8;
      BUF->len[1] = uip_reasslen & 0xff;
      BUF->ipchksum = 0;
      BUF->ipchksum = ~(uip_ipchksum());

      return uip_reasslen;
    }
  }

 nullreturn:
  return 0;
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
  uip_add32(uip_conn->rcv_nxt, n);
  uip_conn->rcv_nxt[0] = uip_acc32[0];
  uip_conn->rcv_nxt[1] = uip_acc32[1];
  uip_conn->rcv_nxt[2] = uip_acc32[2];
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
  register struct uip_conn *uip_connr = uip_conn;

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
       !uip_outstanding(uip_connr)) {
	uip_flags = UIP_POLL;
	UIP_APPCALL();
	goto appsend;
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
#if UIP_REASSEMBLY
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
      if(++iss[2] == 0) {
	if(++iss[1] == 0) {
	  ++iss[0];
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    uip_slen = 0;

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
	uip_connr->tcpstateflags = UIP_CLOSED;
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
	    UIP_APPCALL();

	    /* We also send a reset packet to the remote host. */
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
	  
	  /* Ok, so we need to retransmit. We do this differently
	     depending on which state we are in. In ESTABLISHED, we
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
	  case UIP_SYN_RCVD:
	    /* In the SYN_RCVD state, we should retransmit our
               SYNACK. */
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
	    goto tcp_send_syn;
#endif /* UIP_ACTIVE_OPEN */
	    
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
	    UIP_APPCALL();
	    goto apprexmit;
	    
	  case UIP_FIN_WAIT_1:
	  case UIP_CLOSING:
	  case UIP_LAST_ACK:
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
	UIP_APPCALL();
	goto appsend;
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    if(uip_udp_conn->lport != 0) {
      uip_conn = NULL;
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
      uip_len = uip_slen = 0;
      uip_flags = UIP_POLL;
      UIP_UDP_APPCALL();
      goto udp_send;
    } else {
      goto drop;
    }
  }
#endif

  /* This is where the input processing starts. */
  UIP_STAT(++uip_stat.ip.recv);

  /* Start of IP input header processing code. */
  
#if UIP_CONF_IPV6
  /* Check validity of the IP header. */
  if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.vhlerr);
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.vhlerr);
    UIP_LOG("ip: invalid version or header length.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */
  
  /* Check the size of the packet. If the size reported to us in
     uip_len is smaller the size reported in the IP header, we assume
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
#if UIP_CONF_IPV6
    uip_len += 40; /* The length reported in the IPv6 header is the
		      length of the payload that follows the
		      header. However, uIP uses the uip_len variable
		      for holding the size of the entire packet,
		      including the IP header. For IPv4 this is not a
		      problem as the length field in the IPv4 header
		      contains the length of the entire packet. But
		      for IPv6 we need to add the size of the IPv6
		      header (40 bytes). */
#endif /* UIP_CONF_IPV6 */
  } else {
    UIP_LOG("ip: packet shorter than reported in IP header.");
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
     BUF->ipoffset[1] != 0) {
#if UIP_REASSEMBLY
    uip_len = uip_reass();
    if(uip_len == 0) {
      goto drop;
    }
#else /* UIP_REASSEMBLY */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.fragerr);
    UIP_LOG("ip: fragment dropped.");
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
    /* If we are configured to use ping IP address configuration and
       hasn't been assigned an IP address yet, we accept all ICMP
       packets. */
#if UIP_PINGADDRCONF && !UIP_CONF_IPV6
    if(BUF->proto == UIP_PROTO_ICMP) {
      UIP_LOG("ip: possible ping config packet received.");
      goto icmp_input;
    } else {
      UIP_LOG("ip: packet dropped since no address assigned.");
      goto drop;
    }
#endif /* UIP_PINGADDRCONF */

  } else {
    /* If IP broadcast support is configured, we check for a broadcast
       UDP packet, which may be destined to us. */
#if UIP_BROADCAST
    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    if(BUF->proto == UIP_PROTO_UDP &&
       uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
       /*&&
	 uip_ipchksum() == 0xffff*/) {
      goto udp_input;
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
      UIP_STAT(++uip_stat.ip.drop);
      goto drop;
    }
#else /* UIP_CONF_IPV6 */
    /* For IPv6, packet reception is a little trickier as we need to
       make sure that we listen to certain multicast addresses (all
       hosts multicast address, and the solicited-node multicast
       address) as well. However, we will cheat here and accept all
       multicast packets that are sent to the ff02::/16 addresses. */
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
       BUF->destipaddr[0] != HTONS(0xff02)) {
      UIP_STAT(++uip_stat.ip.drop);
      goto drop;
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
				    checksum. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.chkerr);
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
				       proceed with TCP input
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    goto udp_input;
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
					here. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.protoerr);
    UIP_LOG("ip: neither tcp nor icmp.");
    goto drop;
  }

#if UIP_PINGADDRCONF
 icmp_input:
#endif /* UIP_PINGADDRCONF */
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    UIP_STAT(++uip_stat.icmp.drop);
    UIP_STAT(++uip_stat.icmp.typeerr);
    UIP_LOG("icmp: not icmp echo.");
    goto drop;
  }

  /* If we are configured to use ping IP address assignment, we use
     the destination IP address of this ping packet and assign it to
     ourself. */
#if UIP_PINGADDRCONF
  if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);

  UIP_STAT(++uip_stat.icmp.sent);
  goto send;

  /* End of IPv4 input header processing code. */
#else /* !UIP_CONF_IPV6 */

  /* This is IPv6 ICMPv6 processing code. */
  DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);

  if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
					 here. */
    UIP_STAT(++uip_stat.ip.drop);
    UIP_STAT(++uip_stat.ip.protoerr);
    UIP_LOG("ip: neither tcp nor icmp6.");
    goto drop;
  }

  UIP_STAT(++uip_stat.icmp.recv);

  /* If we get a neighbor solicitation for our address we should send
     a neighbor advertisement message back. */
  if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
    if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {

      if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
	/* Save the sender's address in our neighbor list. */
	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
      }
      
      /* We should now send a neighbor advertisement back to where the
	 neighbor solicication came from. */
      ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
      ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
      
      ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
      
      uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
      uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
      ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
      ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
      memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
      ICMPBUF->icmpchksum = 0;
      ICMPBUF->icmpchksum = ~uip_icmp6chksum();
      goto send;
      
    }
    goto drop;
  } else if(ICMPBUF->type == ICMP6_ECHO) {
    /* ICMP echo (i.e., ping) processing. This is simple, we only
       change the ICMP type from ECHO to ECHO_REPLY and update the
       ICMP checksum before we return the packet. */

    ICMPBUF->type = ICMP6_ECHO_REPLY;
    
    uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    ICMPBUF->icmpchksum = 0;
    ICMPBUF->icmpchksum = ~uip_icmp6chksum();
    
    UIP_STAT(++uip_stat.icmp.sent);
    goto send;
  } else {
    DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
    UIP_STAT(++uip_stat.icmp.drop);
    UIP_STAT(++uip_stat.icmp.typeerr);
    UIP_LOG("icmp: unknown ICMP message.");
    goto drop;
  }

  /* End of IPv6 ICMP processing. */
  
#endif /* !UIP_CONF_IPV6 */

#if UIP_UDP
  /* UDP input processing. */
 udp_input:
  /* UDP processing is really just a hack. We don't do anything to the
     UDP/IP headers, but let the UDP application do all the hard
     work. If the application sets uip_slen, it has a packet to
     send. */
#if UIP_UDP_CHECKSUMS
  uip_len = uip_len - UIP_IPUDPH_LEN;
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
  if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
    UIP_STAT(++uip_stat.udp.drop);
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    /* If the local UDP port is non-zero, the connection is considered
       to be used. If so, the local port number is checked against the
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
      goto udp_found;
    }
  }
  UIP_LOG("udp: no matching connection found");
  goto drop;
  
 udp_found:
  uip_conn = NULL;
  uip_flags = UIP_NEWDATA;
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
  uip_slen = 0;
  UIP_UDP_APPCALL();
 udp_send:
  if(uip_slen == 0) {
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;

#if UIP_CONF_IPV6
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
  BUF->len[1] = (uip_len & 0xff);
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
  BUF->proto = UIP_PROTO_UDP;

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
  UDPBUF->udpchksum = 0;

  BUF->srcport  = uip_udp_conn->lport;
  BUF->destport = uip_udp_conn->rport;

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
  uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
   
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];

#if UIP_UDP_CHECKSUMS
  /* Calculate UDP checksum. */
  UDPBUF->udpchksum = ~(uip_udpchksum());
  if(UDPBUF->udpchksum == 0) {
    UDPBUF->udpchksum = 0xffff;
  }
#endif /* UIP_UDP_CHECKSUMS */
  
  goto ip_send_nolen;
#endif /* UIP_UDP */
  
  /* TCP input processing. */
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");
    goto drop;
  }
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
       BUF->destport == uip_connr->lport &&
       BUF->srcport == uip_connr->rport &&
       uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
      goto found;
    }
  }

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(tmp16 == uip_listenports[c])
      goto found_listen;
  }
  
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
  uip_len = UIP_IPTCPH_LEN;
  BUF->tcpoffset = 5 << 4;

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
  BUF->seqno[3] = BUF->ackno[3];
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
  BUF->seqno[2] = BUF->ackno[2];
  BUF->ackno[2] = c;
  
  c = BUF->seqno[1];
  BUF->seqno[1] = BUF->ackno[1];
  BUF->ackno[1] = c;
  
  c = BUF->seqno[0];
  BUF->seqno[0] = BUF->ackno[0];
  BUF->ackno[0] = c;

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    if(++BUF->ackno[2] == 0) {
      if(++BUF->ackno[1] == 0) {
	++BUF->ackno[0];
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
  BUF->srcport = BUF->destport;
  BUF->destport = tmp16;
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
  
  /* And send out the RST packet! */
  goto tcp_send_noconn;

  /* This label will be jumped to if we matched the incoming packet
     with a connection in LISTEN. In that case, we should create a new
     connection and send a SYNACK in return. */
 found_listen:
  /* First we check if there are any connections avaliable. Unused
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
      uip_connr = &uip_conns[c];
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
      if(uip_connr == 0 ||
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    /* All connections are used already, we drop packet and hope that
       the remote end will retransmit the packet at a time when we
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
  uip_connr->sa = 0;
  uip_connr->sv = 4;
  uip_connr->nrtx = 0;
  uip_connr->lport = BUF->destport;
  uip_connr->rport = BUF->srcport;
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
  uip_connr->tcpstateflags = UIP_SYN_RCVD;

  uip_connr->snd_nxt[0] = iss[0];
  uip_connr->snd_nxt[1] = iss[1];
  uip_connr->snd_nxt[2] = iss[2];
  uip_connr->snd_nxt[3] = iss[3];
  uip_connr->len = 1;

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
      if(opt == TCP_OPT_END) {
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
	
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
      }
    }
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
#else /* UIP_ACTIVE_OPEN */
 tcp_send_synack:
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
  uip_flags = 0;
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    uip_connr->tcpstateflags = UIP_CLOSED;
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    UIP_APPCALL();
    goto drop;
  }
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
      goto tcp_send_ack;
    }
  }

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
      uip_connr->snd_nxt[1] = uip_acc32[1];
      uip_connr->snd_nxt[2] = uip_acc32[2];
      uip_connr->snd_nxt[3] = uip_acc32[3];
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
	uip_connr->sa += m;
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
	uip_connr->sv += m;
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
	implemented, since we force the application to close when the
	peer sends a FIN (hence the application goes directly from
	ESTABLISHED to LAST_ACK). */
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
      uip_flags = UIP_CONNECTED;
      uip_connr->len = 0;
      if(uip_len > 0) {
        uip_flags |= UIP_NEWDATA;
        uip_add_rcv_nxt(uip_len);
      }
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    goto drop;
#if UIP_ACTIVE_OPEN
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
	  if(opt == TCP_OPT_END) {
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
	    ++c;
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
      uip_connr->len = 0;
      uip_len = 0;
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    UIP_APPCALL();
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    goto reset;
#endif /* UIP_ACTIVE_OPEN */
    
  case UIP_ESTABLISHED:
    /* In the ESTABLISHED state, we call upon the application to feed
    data into the uip_buf. If the UIP_ACKDATA flag is set, the
    application should put new data into the buffer, otherwise we are
    retransmitting an old segment, and the application should put that
    data into the buffer.

    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
      if(uip_outstanding(uip_connr)) {
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
      uip_flags |= UIP_CLOSE;
      if(uip_len > 0) {
	uip_flags |= UIP_NEWDATA;
      }
      UIP_APPCALL();
      uip_connr->len = 1;
      uip_connr->tcpstateflags = UIP_LAST_ACK;
      uip_connr->nrtx = 0;
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
#if UIP_URGDATA > 0
      uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
      if(uip_urglen > uip_len) {
	/* There is more urgent data in the next segment to come. */
	uip_urglen = uip_len;
      }
      uip_add_rcv_nxt(uip_urglen);
      uip_len -= uip_urglen;
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
#endif /* UIP_URGDATA > 0 */
    }

    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
      uip_flags |= UIP_NEWDATA;
      uip_add_rcv_nxt(uip_len);
    }

    /* Check if the available buffer space advertised by the other end
       is smaller than the initial MSS for this connection. If so, we
       set the current MSS to the window size to ensure that the
       application does not send more data than the other end can
       handle.

       If the remote host advertises a zero window, we set the MSS to
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    if(tmp16 > uip_connr->initialmss ||
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    }
    uip_connr->mss = tmp16;

    /* If this packet constitutes an ACK for outstanding data (flagged
       by the UIP_ACKDATA flag, we should call the application since it
       might want to send more data. If the incoming packet had data
       from the peer (as flagged by the UIP_NEWDATA flag), the
       application must also be notified.

       When the application is called, the global variable uip_len
       contains the length of the incoming data. The application can
       access the incoming data through the global pointer
       uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
       bytes into the uip_buf array.

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
      uip_slen = 0;
      UIP_APPCALL();

    appsend:
      
      if(uip_flags & UIP_ABORT) {
	uip_slen = 0;
	uip_connr->tcpstateflags = UIP_CLOSED;
	BUF->flags = TCP_RST | TCP_ACK;
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
	uip_slen = 0;
	uip_connr->len = 1;
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
	uip_connr->nrtx = 0;
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
	  uip_connr->len = 0;
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
	    uip_slen = uip_connr->mss;
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
	}
      }
      uip_connr->nrtx = 0;
    apprexmit:
      uip_appdata = uip_sappdata;
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
	uip_len = UIP_TCPIP_HLEN;
	BUF->flags = TCP_ACK;
	goto tcp_send_noopts;
      }
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_CLOSED;
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
    }
    break;
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
      uip_add_rcv_nxt(uip_len);
    }
    if(BUF->flags & TCP_FIN) {
      if(uip_flags & UIP_ACKDATA) {
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
	uip_connr->timer = 0;
	uip_connr->len = 0;
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
      uip_connr->len = 0;
      goto drop;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
      uip_add_rcv_nxt(uip_len);
    }
    if(BUF->flags & TCP_FIN) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
      uip_connr->timer = 0;
    }
  }
  goto drop;
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
  BUF->seqno[1] = uip_connr->snd_nxt[1];
  BUF->seqno[2] = uip_connr->snd_nxt[2];
  BUF->seqno[3] = uip_connr->snd_nxt[3];

  BUF->proto = UIP_PROTO_TCP;
  
  BUF->srcport  = uip_connr->lport;
  BUF->destport = uip_connr->rport;

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
#if UIP_CONF_IPV6
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
  BUF->len[1] = (uip_len & 0xff);
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
  BUF->tcpchksum = ~(uip_tcpchksum());
  
// ip_send_nolen:

#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
  BUF->tos = 0;
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
  ++ipid;
  BUF->ipid[0] = ipid >> 8;
  BUF->ipid[1] = ipid & 0xff;
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
  BUF->ipchksum = ~(uip_ipchksum());
  DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
#endif /* UIP_CONF_IPV6 */
   
  UIP_STAT(++uip_stat.tcp.sent);
 send:
  DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
	       (BUF->len[0] << 8) | BUF->len[1]);
  
  UIP_STAT(++uip_stat.ip.sent);
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
  uip_flags = 0;
  return;
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
     7e2:	29 2f       	mov	r18, r25
     7e4:	38 2f       	mov	r19, r24
}
     7e6:	c9 01       	movw	r24, r18
     7e8:	08 95       	ret

000007ea <uip_chksum>:
     7ea:	9c 01       	movw	r18, r24
     7ec:	ab 01       	movw	r20, r22
     7ee:	b9 01       	movw	r22, r18
     7f0:	80 e0       	ldi	r24, 0x00	; 0
     7f2:	90 e0       	ldi	r25, 0x00	; 0
     7f4:	0e 94 ca 03 	call	0x794 <chksum>
     7f8:	0e 94 f1 03 	call	0x7e2 <htons>
     7fc:	08 95       	ret

000007fe <uip_ipchksum>:
     7fe:	44 e1       	ldi	r20, 0x14	; 20
     800:	50 e0       	ldi	r21, 0x00	; 0
     802:	6e e8       	ldi	r22, 0x8E	; 142
     804:	76 e0       	ldi	r23, 0x06	; 6
     806:	80 e0       	ldi	r24, 0x00	; 0
     808:	90 e0       	ldi	r25, 0x00	; 0
     80a:	0e 94 ca 03 	call	0x794 <chksum>
     80e:	00 97       	sbiw	r24, 0x00	; 0
     810:	19 f0       	breq	.+6      	; 0x818 <uip_ipchksum+0x1a>
     812:	0e 94 f1 03 	call	0x7e2 <htons>
     816:	08 95       	ret
     818:	8f ef       	ldi	r24, 0xFF	; 255
     81a:	9f ef       	ldi	r25, 0xFF	; 255
     81c:	08 95       	ret

0000081e <upper_layer_chksum>:
     81e:	0f 93       	push	r16
     820:	1f 93       	push	r17
     822:	90 91 90 06 	lds	r25, 0x0690
     826:	29 2f       	mov	r18, r25
     828:	33 27       	eor	r19, r19
     82a:	12 2f       	mov	r17, r18
     82c:	00 27       	eor	r16, r16
     82e:	90 91 91 06 	lds	r25, 0x0691
     832:	09 0f       	add	r16, r25
     834:	11 1d       	adc	r17, r1
     836:	04 51       	subi	r16, 0x14	; 20
     838:	10 40       	sbci	r17, 0x00	; 0
     83a:	48 e0       	ldi	r20, 0x08	; 8
     83c:	50 e0       	ldi	r21, 0x00	; 0
     83e:	6a e9       	ldi	r22, 0x9A	; 154
     840:	76 e0       	ldi	r23, 0x06	; 6
     842:	98 01       	movw	r18, r16
     844:	28 0f       	add	r18, r24
     846:	31 1d       	adc	r19, r1
     848:	c9 01       	movw	r24, r18
     84a:	0e 94 ca 03 	call	0x794 <chksum>
     84e:	a8 01       	movw	r20, r16
     850:	62 ea       	ldi	r22, 0xA2	; 162
     852:	76 e0       	ldi	r23, 0x06	; 6
     854:	0e 94 ca 03 	call	0x794 <chksum>
     858:	00 97       	sbiw	r24, 0x00	; 0
     85a:	19 f0       	breq	.+6      	; 0x862 <__stack+0x3>
     85c:	0e 94 f1 03 	call	0x7e2 <htons>
     860:	02 c0       	rjmp	.+4      	; 0x866 <__stack+0x7>
     862:	8f ef       	ldi	r24, 0xFF	; 255
     864:	9f ef       	ldi	r25, 0xFF	; 255
     866:	1f 91       	pop	r17
     868:	0f 91       	pop	r16
     86a:	08 95       	ret

0000086c <uip_tcpchksum>:
     86c:	86 e0       	ldi	r24, 0x06	; 6
     86e:	0e 94 0f 04 	call	0x81e <upper_layer_chksum>
     872:	08 95       	ret

00000874 <uip_udpchksum>:
     874:	81 e1       	ldi	r24, 0x11	; 17
     876:	0e 94 0f 04 	call	0x81e <upper_layer_chksum>
     87a:	08 95       	ret

0000087c <uip_init>:
     87c:	10 92 46 03 	sts	0x0346, r1
     880:	20 e0       	ldi	r18, 0x00	; 0
     882:	80 e0       	ldi	r24, 0x00	; 0
     884:	90 e0       	ldi	r25, 0x00	; 0
     886:	fc 01       	movw	r30, r24
     888:	e8 0f       	add	r30, r24
     88a:	f9 1f       	adc	r31, r25
     88c:	ee 5a       	subi	r30, 0xAE	; 174
     88e:	f9 4f       	sbci	r31, 0xF9	; 249
     890:	11 82       	std	Z+1, r1	; 0x01
     892:	10 82       	st	Z, r1
     894:	2f 5f       	subi	r18, 0xFF	; 255
     896:	01 96       	adiw	r24, 0x01	; 1
     898:	22 23       	and	r18, r18
     89a:	a9 f3       	breq	.-22     	; 0x886 <uip_init+0xa>
     89c:	10 92 46 03 	sts	0x0346, r1
     8a0:	80 e0       	ldi	r24, 0x00	; 0
     8a2:	e1 e9       	ldi	r30, 0x91	; 145
     8a4:	f3 e0       	ldi	r31, 0x03	; 3
     8a6:	10 82       	st	Z, r1
     8a8:	e7 5b       	subi	r30, 0xB7	; 183
     8aa:	ff 4f       	sbci	r31, 0xFF	; 255
     8ac:	8f 5f       	subi	r24, 0xFF	; 255
     8ae:	8a 30       	cpi	r24, 0x0A	; 10
     8b0:	d0 f3       	brcs	.-12     	; 0x8a6 <uip_init+0x2a>
     8b2:	8a e0       	ldi	r24, 0x0A	; 10
     8b4:	80 93 46 03 	sts	0x0346, r24
     8b8:	80 e0       	ldi	r24, 0x00	; 0
     8ba:	94 e0       	ldi	r25, 0x04	; 4
     8bc:	90 93 45 03 	sts	0x0345, r25
     8c0:	80 93 44 03 	sts	0x0344, r24
     8c4:	08 95       	ret

000008c6 <uip_connect>:
     8c6:	cf 92       	push	r12
     8c8:	df 92       	push	r13
     8ca:	ef 92       	push	r14
     8cc:	ff 92       	push	r15
     8ce:	0f 93       	push	r16
     8d0:	1f 93       	push	r17
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
     8d6:	7c 01       	movw	r14, r24
     8d8:	6b 01       	movw	r12, r22
     8da:	80 91 44 03 	lds	r24, 0x0344
     8de:	90 91 45 03 	lds	r25, 0x0345
     8e2:	01 96       	adiw	r24, 0x01	; 1
     8e4:	90 93 45 03 	sts	0x0345, r25
     8e8:	80 93 44 03 	sts	0x0344, r24
     8ec:	80 50       	subi	r24, 0x00	; 0
     8ee:	9d 47       	sbci	r25, 0x7D	; 125
     8f0:	30 f0       	brcs	.+12     	; 0x8fe <uip_connect+0x38>
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	90 e1       	ldi	r25, 0x10	; 16
     8f6:	90 93 45 03 	sts	0x0345, r25
     8fa:	80 93 44 03 	sts	0x0344, r24
     8fe:	10 92 46 03 	sts	0x0346, r1
     902:	10 91 46 03 	lds	r17, 0x0346
     906:	09 e4       	ldi	r16, 0x49	; 73
     908:	10 9f       	mul	r17, r16
     90a:	e0 01       	movw	r28, r0
     90c:	11 24       	eor	r1, r1
     90e:	c8 58       	subi	r28, 0x88	; 136
     910:	dc 4f       	sbci	r29, 0xFC	; 252
     912:	89 8d       	ldd	r24, Y+25	; 0x19
     914:	88 23       	and	r24, r24
     916:	59 f0       	breq	.+22     	; 0x92e <uip_connect+0x68>
     918:	80 91 44 03 	lds	r24, 0x0344
     91c:	90 91 45 03 	lds	r25, 0x0345
     920:	0e 94 f1 03 	call	0x7e2 <htons>
     924:	2c 81       	ldd	r18, Y+4	; 0x04
     926:	3d 81       	ldd	r19, Y+5	; 0x05
     928:	28 17       	cp	r18, r24
     92a:	39 07       	cpc	r19, r25
     92c:	b1 f2       	breq	.-84     	; 0x8da <uip_connect+0x14>
     92e:	81 2f       	mov	r24, r17
     930:	8f 5f       	subi	r24, 0xFF	; 255
     932:	80 93 46 03 	sts	0x0346, r24
     936:	8a 30       	cpi	r24, 0x0A	; 10
     938:	20 f3       	brcs	.-56     	; 0x902 <uip_connect+0x3c>
     93a:	c0 e0       	ldi	r28, 0x00	; 0
     93c:	d0 e0       	ldi	r29, 0x00	; 0
     93e:	10 92 46 03 	sts	0x0346, r1
     942:	30 2f       	mov	r19, r16
     944:	20 91 46 03 	lds	r18, 0x0346
     948:	23 9f       	mul	r18, r19
     94a:	f0 01       	movw	r30, r0
     94c:	11 24       	eor	r1, r1
     94e:	e8 58       	subi	r30, 0x88	; 136
     950:	fc 4f       	sbci	r31, 0xFC	; 252
     952:	81 8d       	ldd	r24, Z+25	; 0x19
     954:	88 23       	and	r24, r24
     956:	91 f0       	breq	.+36     	; 0x97c <uip_connect+0xb6>
     958:	87 30       	cpi	r24, 0x07	; 7
     95a:	39 f4       	brne	.+14     	; 0x96a <uip_connect+0xa4>
     95c:	20 97       	sbiw	r28, 0x00	; 0
     95e:	21 f0       	breq	.+8      	; 0x968 <uip_connect+0xa2>
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
     962:	8a 8d       	ldd	r24, Y+26	; 0x1a
     964:	89 17       	cp	r24, r25
     966:	08 f4       	brcc	.+2      	; 0x96a <uip_connect+0xa4>
     968:	ef 01       	movw	r28, r30
     96a:	82 2f       	mov	r24, r18
     96c:	8f 5f       	subi	r24, 0xFF	; 255
     96e:	80 93 46 03 	sts	0x0346, r24
     972:	8a 30       	cpi	r24, 0x0A	; 10
     974:	38 f3       	brcs	.-50     	; 0x944 <uip_connect+0x7e>
     976:	20 97       	sbiw	r28, 0x00	; 0
     978:	19 f4       	brne	.+6      	; 0x980 <uip_connect+0xba>
     97a:	35 c0       	rjmp	.+106    	; 0x9e6 <uip_connect+0x120>
     97c:	ef 01       	movw	r28, r30
     97e:	fb cf       	rjmp	.-10     	; 0x976 <uip_connect+0xb0>
     980:	82 e0       	ldi	r24, 0x02	; 2
     982:	89 8f       	std	Y+25, r24	; 0x19
     984:	80 91 40 03 	lds	r24, 0x0340
     988:	8c 87       	std	Y+12, r24	; 0x0c
     98a:	80 91 41 03 	lds	r24, 0x0341
     98e:	8d 87       	std	Y+13, r24	; 0x0d
     990:	80 91 42 03 	lds	r24, 0x0342
     994:	8e 87       	std	Y+14, r24	; 0x0e
     996:	80 91 43 03 	lds	r24, 0x0343
     99a:	8f 87       	std	Y+15, r24	; 0x0f
     99c:	8e e6       	ldi	r24, 0x6E	; 110
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	9b 8b       	std	Y+19, r25	; 0x13
     9a2:	8a 8b       	std	Y+18, r24	; 0x12
     9a4:	9d 8b       	std	Y+21, r25	; 0x15
     9a6:	8c 8b       	std	Y+20, r24	; 0x14
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	90 e0       	ldi	r25, 0x00	; 0
     9ac:	99 8b       	std	Y+17, r25	; 0x11
     9ae:	88 8b       	std	Y+16, r24	; 0x10
     9b0:	1b 8e       	std	Y+27, r1	; 0x1b
     9b2:	81 e0       	ldi	r24, 0x01	; 1
     9b4:	8a 8f       	std	Y+26, r24	; 0x1a
     9b6:	83 e0       	ldi	r24, 0x03	; 3
     9b8:	88 8f       	std	Y+24, r24	; 0x18
     9ba:	1e 8a       	std	Y+22, r1	; 0x16
     9bc:	80 e1       	ldi	r24, 0x10	; 16
     9be:	8f 8b       	std	Y+23, r24	; 0x17
     9c0:	80 91 44 03 	lds	r24, 0x0344
     9c4:	90 91 45 03 	lds	r25, 0x0345
     9c8:	0e 94 f1 03 	call	0x7e2 <htons>
     9cc:	9d 83       	std	Y+5, r25	; 0x05
     9ce:	8c 83       	std	Y+4, r24	; 0x04
     9d0:	df 82       	std	Y+7, r13	; 0x07
     9d2:	ce 82       	std	Y+6, r12	; 0x06
     9d4:	f7 01       	movw	r30, r14
     9d6:	80 81       	ld	r24, Z
     9d8:	91 81       	ldd	r25, Z+1	; 0x01
     9da:	99 83       	std	Y+1, r25	; 0x01
     9dc:	88 83       	st	Y, r24
     9de:	82 81       	ldd	r24, Z+2	; 0x02
     9e0:	93 81       	ldd	r25, Z+3	; 0x03
     9e2:	9b 83       	std	Y+3, r25	; 0x03
     9e4:	8a 83       	std	Y+2, r24	; 0x02
     9e6:	ce 01       	movw	r24, r28
     9e8:	df 91       	pop	r29
     9ea:	cf 91       	pop	r28
     9ec:	1f 91       	pop	r17
     9ee:	0f 91       	pop	r16
     9f0:	ff 90       	pop	r15
     9f2:	ef 90       	pop	r14
     9f4:	df 90       	pop	r13
     9f6:	cf 90       	pop	r12
     9f8:	08 95       	ret

000009fa <uip_unlisten>:
     9fa:	ac 01       	movw	r20, r24
     9fc:	10 92 46 03 	sts	0x0346, r1
     a00:	20 e0       	ldi	r18, 0x00	; 0
     a02:	e2 2f       	mov	r30, r18
     a04:	ff 27       	eor	r31, r31
     a06:	ee 0f       	add	r30, r30
     a08:	ff 1f       	adc	r31, r31
     a0a:	ee 5a       	subi	r30, 0xAE	; 174
     a0c:	f9 4f       	sbci	r31, 0xF9	; 249
     a0e:	80 81       	ld	r24, Z
     a10:	91 81       	ldd	r25, Z+1	; 0x01
     a12:	84 17       	cp	r24, r20
     a14:	95 07       	cpc	r25, r21
     a16:	19 f4       	brne	.+6      	; 0xa1e <uip_unlisten+0x24>
     a18:	11 82       	std	Z+1, r1	; 0x01
     a1a:	10 82       	st	Z, r1
     a1c:	02 c0       	rjmp	.+4      	; 0xa22 <uip_unlisten+0x28>
     a1e:	2f 5f       	subi	r18, 0xFF	; 255
     a20:	81 f3       	breq	.-32     	; 0xa02 <uip_unlisten+0x8>
     a22:	20 93 46 03 	sts	0x0346, r18
     a26:	08 95       	ret

00000a28 <uip_listen>:
     a28:	ac 01       	movw	r20, r24
     a2a:	10 92 46 03 	sts	0x0346, r1
     a2e:	20 e0       	ldi	r18, 0x00	; 0
     a30:	e2 2f       	mov	r30, r18
     a32:	ff 27       	eor	r31, r31
     a34:	ee 0f       	add	r30, r30
     a36:	ff 1f       	adc	r31, r31
     a38:	ee 5a       	subi	r30, 0xAE	; 174
     a3a:	f9 4f       	sbci	r31, 0xF9	; 249
     a3c:	80 81       	ld	r24, Z
     a3e:	91 81       	ldd	r25, Z+1	; 0x01
     a40:	89 2b       	or	r24, r25
     a42:	19 f4       	brne	.+6      	; 0xa4a <uip_listen+0x22>
     a44:	51 83       	std	Z+1, r21	; 0x01
     a46:	40 83       	st	Z, r20
     a48:	02 c0       	rjmp	.+4      	; 0xa4e <uip_listen+0x26>
     a4a:	2f 5f       	subi	r18, 0xFF	; 255
     a4c:	89 f3       	breq	.-30     	; 0xa30 <uip_listen+0x8>
     a4e:	20 93 46 03 	sts	0x0346, r18
     a52:	08 95       	ret

00000a54 <uip_add_rcv_nxt>:
     a54:	20 91 76 03 	lds	r18, 0x0376
     a58:	30 91 77 03 	lds	r19, 0x0377
     a5c:	bc 01       	movw	r22, r24
     a5e:	c9 01       	movw	r24, r18
     a60:	08 96       	adiw	r24, 0x08	; 8
     a62:	0e 94 91 03 	call	0x722 <uip_add32>
     a66:	e0 91 76 03 	lds	r30, 0x0376
     a6a:	f0 91 77 03 	lds	r31, 0x0377
     a6e:	80 91 6f 03 	lds	r24, 0x036F
     a72:	80 87       	std	Z+8, r24	; 0x08
     a74:	e0 91 76 03 	lds	r30, 0x0376
     a78:	f0 91 77 03 	lds	r31, 0x0377
     a7c:	80 91 70 03 	lds	r24, 0x0370
     a80:	81 87       	std	Z+9, r24	; 0x09
     a82:	e0 91 76 03 	lds	r30, 0x0376
     a86:	f0 91 77 03 	lds	r31, 0x0377
     a8a:	80 91 71 03 	lds	r24, 0x0371
     a8e:	82 87       	std	Z+10, r24	; 0x0a
     a90:	e0 91 76 03 	lds	r30, 0x0376
     a94:	f0 91 77 03 	lds	r31, 0x0377
     a98:	80 91 72 03 	lds	r24, 0x0372
     a9c:	83 87       	std	Z+11, r24	; 0x0b
     a9e:	08 95       	ret

00000aa0 <uip_process>:
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	28 2f       	mov	r18, r24
     aa6:	c0 91 76 03 	lds	r28, 0x0376
     aaa:	d0 91 77 03 	lds	r29, 0x0377
     aae:	86 eb       	ldi	r24, 0xB6	; 182
     ab0:	96 e0       	ldi	r25, 0x06	; 6
     ab2:	90 93 75 03 	sts	0x0375, r25
     ab6:	80 93 74 03 	sts	0x0374, r24
     aba:	90 93 6e 03 	sts	0x036E, r25
     abe:	80 93 6d 03 	sts	0x036D, r24
     ac2:	23 30       	cpi	r18, 0x03	; 3
     ac4:	69 f4       	brne	.+26     	; 0xae0 <uip_process+0x40>
     ac6:	89 8d       	ldd	r24, Y+25	; 0x19
     ac8:	99 27       	eor	r25, r25
     aca:	8f 70       	andi	r24, 0x0F	; 15
     acc:	90 70       	andi	r25, 0x00	; 0
     ace:	03 97       	sbiw	r24, 0x03	; 3
     ad0:	09 f0       	breq	.+2      	; 0xad4 <uip_process+0x34>
     ad2:	3a c7       	rjmp	.+3700   	; 0x1948 <uip_process+0xea8>
     ad4:	88 89       	ldd	r24, Y+16	; 0x10
     ad6:	99 89       	ldd	r25, Y+17	; 0x11
     ad8:	89 2b       	or	r24, r25
     ada:	09 f0       	breq	.+2      	; 0xade <uip_process+0x3e>
     adc:	35 c7       	rjmp	.+3690   	; 0x1948 <uip_process+0xea8>
     ade:	97 c0       	rjmp	.+302    	; 0xc0e <uip_process+0x16e>
     ae0:	22 30       	cpi	r18, 0x02	; 2
     ae2:	09 f0       	breq	.+2      	; 0xae6 <uip_process+0x46>
     ae4:	98 c0       	rjmp	.+304    	; 0xc16 <uip_process+0x176>
     ae6:	80 91 43 03 	lds	r24, 0x0343
     aea:	8f 5f       	subi	r24, 0xFF	; 255
     aec:	80 93 43 03 	sts	0x0343, r24
     af0:	88 23       	and	r24, r24
     af2:	99 f4       	brne	.+38     	; 0xb1a <uip_process+0x7a>
     af4:	80 91 42 03 	lds	r24, 0x0342
     af8:	8f 5f       	subi	r24, 0xFF	; 255
     afa:	80 93 42 03 	sts	0x0342, r24
     afe:	88 23       	and	r24, r24
     b00:	61 f4       	brne	.+24     	; 0xb1a <uip_process+0x7a>
     b02:	80 91 41 03 	lds	r24, 0x0341
     b06:	8f 5f       	subi	r24, 0xFF	; 255
     b08:	80 93 41 03 	sts	0x0341, r24
     b0c:	88 23       	and	r24, r24
     b0e:	29 f4       	brne	.+10     	; 0xb1a <uip_process+0x7a>
     b10:	80 91 40 03 	lds	r24, 0x0340
     b14:	8f 5f       	subi	r24, 0xFF	; 255
     b16:	80 93 40 03 	sts	0x0340, r24
     b1a:	10 92 6c 03 	sts	0x036C, r1
     b1e:	10 92 6b 03 	sts	0x036B, r1
     b22:	10 92 27 08 	sts	0x0827, r1
     b26:	10 92 26 08 	sts	0x0826, r1
     b2a:	39 8d       	ldd	r19, Y+25	; 0x19
     b2c:	37 30       	cpi	r19, 0x07	; 7
     b2e:	11 f0       	breq	.+4      	; 0xb34 <uip_process+0x94>
     b30:	35 30       	cpi	r19, 0x05	; 5
     b32:	41 f4       	brne	.+16     	; 0xb44 <uip_process+0xa4>
     b34:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b36:	8f 5f       	subi	r24, 0xFF	; 255
     b38:	8a 8f       	std	Y+26, r24	; 0x1a
     b3a:	88 37       	cpi	r24, 0x78	; 120
     b3c:	09 f0       	breq	.+2      	; 0xb40 <uip_process+0xa0>
     b3e:	04 c7       	rjmp	.+3592   	; 0x1948 <uip_process+0xea8>
     b40:	19 8e       	std	Y+25, r1	; 0x19
     b42:	02 c7       	rjmp	.+3588   	; 0x1948 <uip_process+0xea8>
     b44:	33 23       	and	r19, r19
     b46:	09 f4       	brne	.+2      	; 0xb4a <uip_process+0xaa>
     b48:	ff c6       	rjmp	.+3582   	; 0x1948 <uip_process+0xea8>
     b4a:	88 89       	ldd	r24, Y+16	; 0x10
     b4c:	99 89       	ldd	r25, Y+17	; 0x11
     b4e:	89 2b       	or	r24, r25
     b50:	09 f4       	brne	.+2      	; 0xb54 <uip_process+0xb4>
     b52:	56 c0       	rjmp	.+172    	; 0xc00 <uip_process+0x160>
     b54:	8a 8d       	ldd	r24, Y+26	; 0x1a
     b56:	81 50       	subi	r24, 0x01	; 1
     b58:	8a 8f       	std	Y+26, r24	; 0x1a
     b5a:	8f 3f       	cpi	r24, 0xFF	; 255
     b5c:	09 f0       	breq	.+2      	; 0xb60 <uip_process+0xc0>
     b5e:	f4 c6       	rjmp	.+3560   	; 0x1948 <uip_process+0xea8>
     b60:	2b 8d       	ldd	r18, Y+27	; 0x1b
     b62:	28 30       	cpi	r18, 0x08	; 8
     b64:	29 f0       	breq	.+10     	; 0xb70 <uip_process+0xd0>
     b66:	31 50       	subi	r19, 0x01	; 1
     b68:	32 30       	cpi	r19, 0x02	; 2
     b6a:	48 f4       	brcc	.+18     	; 0xb7e <uip_process+0xde>
     b6c:	25 30       	cpi	r18, 0x05	; 5
     b6e:	39 f4       	brne	.+14     	; 0xb7e <uip_process+0xde>
     b70:	19 8e       	std	Y+25, r1	; 0x19
     b72:	80 e8       	ldi	r24, 0x80	; 128
     b74:	80 93 73 03 	sts	0x0373, r24
     b78:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
     b7c:	76 c5       	rjmp	.+2796   	; 0x166a <uip_process+0xbca>
     b7e:	25 30       	cpi	r18, 0x05	; 5
     b80:	48 f4       	brcc	.+18     	; 0xb94 <uip_process+0xf4>
     b82:	83 e0       	ldi	r24, 0x03	; 3
     b84:	90 e0       	ldi	r25, 0x00	; 0
     b86:	02 2e       	mov	r0, r18
     b88:	02 c0       	rjmp	.+4      	; 0xb8e <uip_process+0xee>
     b8a:	88 0f       	add	r24, r24
     b8c:	99 1f       	adc	r25, r25
     b8e:	0a 94       	dec	r0
     b90:	e2 f7       	brpl	.-8      	; 0xb8a <uip_process+0xea>
     b92:	01 c0       	rjmp	.+2      	; 0xb96 <uip_process+0xf6>
     b94:	80 e3       	ldi	r24, 0x30	; 48
     b96:	8a 8f       	std	Y+26, r24	; 0x1a
     b98:	2f 5f       	subi	r18, 0xFF	; 255
     b9a:	2b 8f       	std	Y+27, r18	; 0x1b
     b9c:	80 91 7a 06 	lds	r24, 0x067A
     ba0:	90 91 7b 06 	lds	r25, 0x067B
     ba4:	01 96       	adiw	r24, 0x01	; 1
     ba6:	90 93 7b 06 	sts	0x067B, r25
     baa:	80 93 7a 06 	sts	0x067A, r24
     bae:	89 8d       	ldd	r24, Y+25	; 0x19
     bb0:	99 27       	eor	r25, r25
     bb2:	8f 70       	andi	r24, 0x0F	; 15
     bb4:	90 70       	andi	r25, 0x00	; 0
     bb6:	83 30       	cpi	r24, 0x03	; 3
     bb8:	91 05       	cpc	r25, r1
     bba:	e1 f0       	breq	.+56     	; 0xbf4 <uip_process+0x154>
     bbc:	84 30       	cpi	r24, 0x04	; 4
     bbe:	91 05       	cpc	r25, r1
     bc0:	3c f4       	brge	.+14     	; 0xbd0 <uip_process+0x130>
     bc2:	81 30       	cpi	r24, 0x01	; 1
     bc4:	91 05       	cpc	r25, r1
     bc6:	09 f4       	brne	.+2      	; 0xbca <uip_process+0x12a>
     bc8:	2c c3       	rjmp	.+1624   	; 0x1222 <uip_process+0x782>
     bca:	02 97       	sbiw	r24, 0x02	; 2
     bcc:	81 f0       	breq	.+32     	; 0xbee <uip_process+0x14e>
     bce:	bc c6       	rjmp	.+3448   	; 0x1948 <uip_process+0xea8>
     bd0:	86 30       	cpi	r24, 0x06	; 6
     bd2:	91 05       	cpc	r25, r1
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <uip_process+0x138>
     bd6:	5b c5       	rjmp	.+2742   	; 0x168e <uip_process+0xbee>
     bd8:	87 30       	cpi	r24, 0x07	; 7
     bda:	91 05       	cpc	r25, r1
     bdc:	24 f4       	brge	.+8      	; 0xbe6 <uip_process+0x146>
     bde:	04 97       	sbiw	r24, 0x04	; 4
     be0:	09 f4       	brne	.+2      	; 0xbe4 <uip_process+0x144>
     be2:	55 c5       	rjmp	.+2730   	; 0x168e <uip_process+0xbee>
     be4:	b1 c6       	rjmp	.+3426   	; 0x1948 <uip_process+0xea8>
     be6:	08 97       	sbiw	r24, 0x08	; 8
     be8:	09 f4       	brne	.+2      	; 0xbec <uip_process+0x14c>
     bea:	51 c5       	rjmp	.+2722   	; 0x168e <uip_process+0xbee>
     bec:	ad c6       	rjmp	.+3418   	; 0x1948 <uip_process+0xea8>
     bee:	10 92 af 06 	sts	0x06AF, r1
     bf2:	1a c3       	rjmp	.+1588   	; 0x1228 <uip_process+0x788>
     bf4:	84 e0       	ldi	r24, 0x04	; 4
     bf6:	80 93 73 03 	sts	0x0373, r24
     bfa:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
     bfe:	70 c5       	rjmp	.+2784   	; 0x16e0 <uip_process+0xc40>
     c00:	83 2f       	mov	r24, r19
     c02:	99 27       	eor	r25, r25
     c04:	8f 70       	andi	r24, 0x0F	; 15
     c06:	90 70       	andi	r25, 0x00	; 0
     c08:	03 97       	sbiw	r24, 0x03	; 3
     c0a:	09 f0       	breq	.+2      	; 0xc0e <uip_process+0x16e>
     c0c:	9d c6       	rjmp	.+3386   	; 0x1948 <uip_process+0xea8>
     c0e:	88 e0       	ldi	r24, 0x08	; 8
     c10:	80 93 73 03 	sts	0x0373, r24
     c14:	1a c5       	rjmp	.+2612   	; 0x164a <uip_process+0xbaa>
     c16:	80 91 56 06 	lds	r24, 0x0656
     c1a:	90 91 57 06 	lds	r25, 0x0657
     c1e:	01 96       	adiw	r24, 0x01	; 1
     c20:	90 93 57 06 	sts	0x0657, r25
     c24:	80 93 56 06 	sts	0x0656, r24
     c28:	80 91 8e 06 	lds	r24, 0x068E
     c2c:	85 34       	cpi	r24, 0x45	; 69
     c2e:	a9 f0       	breq	.+42     	; 0xc5a <uip_process+0x1ba>
     c30:	80 91 54 06 	lds	r24, 0x0654
     c34:	90 91 55 06 	lds	r25, 0x0655
     c38:	01 96       	adiw	r24, 0x01	; 1
     c3a:	90 93 55 06 	sts	0x0655, r25
     c3e:	80 93 54 06 	sts	0x0654, r24
     c42:	80 91 5a 06 	lds	r24, 0x065A
     c46:	90 91 5b 06 	lds	r25, 0x065B
     c4a:	01 96       	adiw	r24, 0x01	; 1
     c4c:	90 93 5b 06 	sts	0x065B, r25
     c50:	80 93 5a 06 	sts	0x065A, r24
     c54:	8d ea       	ldi	r24, 0xAD	; 173
     c56:	91 e0       	ldi	r25, 0x01	; 1
     c58:	43 c2       	rjmp	.+1158   	; 0x10e0 <uip_process+0x640>
     c5a:	80 91 90 06 	lds	r24, 0x0690
     c5e:	99 27       	eor	r25, r25
     c60:	38 2f       	mov	r19, r24
     c62:	22 27       	eor	r18, r18
     c64:	80 91 91 06 	lds	r24, 0x0691
     c68:	28 0f       	add	r18, r24
     c6a:	31 1d       	adc	r19, r1
     c6c:	80 91 6b 03 	lds	r24, 0x036B
     c70:	90 91 6c 03 	lds	r25, 0x036C
     c74:	82 17       	cp	r24, r18
     c76:	93 07       	cpc	r25, r19
     c78:	18 f4       	brcc	.+6      	; 0xc80 <uip_process+0x1e0>
     c7a:	83 ed       	ldi	r24, 0xD3	; 211
     c7c:	91 e0       	ldi	r25, 0x01	; 1
     c7e:	30 c2       	rjmp	.+1120   	; 0x10e0 <uip_process+0x640>
     c80:	30 93 6c 03 	sts	0x036C, r19
     c84:	20 93 6b 03 	sts	0x036B, r18
     c88:	80 91 94 06 	lds	r24, 0x0694
     c8c:	99 27       	eor	r25, r25
     c8e:	8f 73       	andi	r24, 0x3F	; 63
     c90:	90 70       	andi	r25, 0x00	; 0
     c92:	89 2b       	or	r24, r25
     c94:	21 f4       	brne	.+8      	; 0xc9e <uip_process+0x1fe>
     c96:	80 91 95 06 	lds	r24, 0x0695
     c9a:	88 23       	and	r24, r24
     c9c:	a9 f0       	breq	.+42     	; 0xcc8 <uip_process+0x228>
     c9e:	80 91 54 06 	lds	r24, 0x0654
     ca2:	90 91 55 06 	lds	r25, 0x0655
     ca6:	01 96       	adiw	r24, 0x01	; 1
     ca8:	90 93 55 06 	sts	0x0655, r25
     cac:	80 93 54 06 	sts	0x0654, r24
     cb0:	80 91 60 06 	lds	r24, 0x0660
     cb4:	90 91 61 06 	lds	r25, 0x0661
     cb8:	01 96       	adiw	r24, 0x01	; 1
     cba:	90 93 61 06 	sts	0x0661, r25
     cbe:	80 93 60 06 	sts	0x0660, r24
     cc2:	82 e0       	ldi	r24, 0x02	; 2
     cc4:	92 e0       	ldi	r25, 0x02	; 2
     cc6:	0c c2       	rjmp	.+1048   	; 0x10e0 <uip_process+0x640>
     cc8:	40 91 a5 01 	lds	r20, 0x01A5
     ccc:	50 91 a6 01 	lds	r21, 0x01A6
     cd0:	80 91 a9 01 	lds	r24, 0x01A9
     cd4:	90 91 aa 01 	lds	r25, 0x01AA
     cd8:	48 17       	cp	r20, r24
     cda:	59 07       	cpc	r21, r25
     cdc:	59 f4       	brne	.+22     	; 0xcf4 <uip_process+0x254>
     cde:	20 91 a7 01 	lds	r18, 0x01A7
     ce2:	30 91 a8 01 	lds	r19, 0x01A8
     ce6:	80 91 ab 01 	lds	r24, 0x01AB
     cea:	90 91 ac 01 	lds	r25, 0x01AC
     cee:	28 17       	cp	r18, r24
     cf0:	39 07       	cpc	r19, r25
     cf2:	e1 f0       	breq	.+56     	; 0xd2c <uip_process+0x28c>
     cf4:	80 91 9e 06 	lds	r24, 0x069E
     cf8:	90 91 9f 06 	lds	r25, 0x069F
     cfc:	84 17       	cp	r24, r20
     cfe:	95 07       	cpc	r25, r21
     d00:	59 f4       	brne	.+22     	; 0xd18 <uip_process+0x278>
     d02:	20 91 a0 06 	lds	r18, 0x06A0
     d06:	30 91 a1 06 	lds	r19, 0x06A1
     d0a:	80 91 a7 01 	lds	r24, 0x01A7
     d0e:	90 91 a8 01 	lds	r25, 0x01A8
     d12:	28 17       	cp	r18, r24
     d14:	39 07       	cpc	r19, r25
     d16:	51 f0       	breq	.+20     	; 0xd2c <uip_process+0x28c>
     d18:	80 91 54 06 	lds	r24, 0x0654
     d1c:	90 91 55 06 	lds	r25, 0x0655
     d20:	01 96       	adiw	r24, 0x01	; 1
     d22:	90 93 55 06 	sts	0x0655, r25
     d26:	80 93 54 06 	sts	0x0654, r24
     d2a:	0e c6       	rjmp	.+3100   	; 0x1948 <uip_process+0xea8>
     d2c:	0e 94 ff 03 	call	0x7fe <uip_ipchksum>
     d30:	8f 5f       	subi	r24, 0xFF	; 255
     d32:	9f 4f       	sbci	r25, 0xFF	; 255
     d34:	a9 f0       	breq	.+42     	; 0xd60 <uip_process+0x2c0>
     d36:	80 91 54 06 	lds	r24, 0x0654
     d3a:	90 91 55 06 	lds	r25, 0x0655
     d3e:	01 96       	adiw	r24, 0x01	; 1
     d40:	90 93 55 06 	sts	0x0655, r25
     d44:	80 93 54 06 	sts	0x0654, r24
     d48:	80 91 62 06 	lds	r24, 0x0662
     d4c:	90 91 63 06 	lds	r25, 0x0663
     d50:	01 96       	adiw	r24, 0x01	; 1
     d52:	90 93 63 06 	sts	0x0663, r25
     d56:	80 93 62 06 	sts	0x0662, r24
     d5a:	88 e1       	ldi	r24, 0x18	; 24
     d5c:	92 e0       	ldi	r25, 0x02	; 2
     d5e:	c0 c1       	rjmp	.+896    	; 0x10e0 <uip_process+0x640>
     d60:	80 91 97 06 	lds	r24, 0x0697
     d64:	86 30       	cpi	r24, 0x06	; 6
     d66:	09 f4       	brne	.+2      	; 0xd6a <uip_process+0x2ca>
     d68:	74 c0       	rjmp	.+232    	; 0xe52 <uip_process+0x3b2>
     d6a:	81 30       	cpi	r24, 0x01	; 1
     d6c:	a9 f0       	breq	.+42     	; 0xd98 <uip_process+0x2f8>
     d6e:	80 91 54 06 	lds	r24, 0x0654
     d72:	90 91 55 06 	lds	r25, 0x0655
     d76:	01 96       	adiw	r24, 0x01	; 1
     d78:	90 93 55 06 	sts	0x0655, r25
     d7c:	80 93 54 06 	sts	0x0654, r24
     d80:	80 91 64 06 	lds	r24, 0x0664
     d84:	90 91 65 06 	lds	r25, 0x0665
     d88:	01 96       	adiw	r24, 0x01	; 1
     d8a:	90 93 65 06 	sts	0x0665, r25
     d8e:	80 93 64 06 	sts	0x0664, r24
     d92:	8a e2       	ldi	r24, 0x2A	; 42
     d94:	92 e0       	ldi	r25, 0x02	; 2
     d96:	a4 c1       	rjmp	.+840    	; 0x10e0 <uip_process+0x640>
     d98:	80 91 68 06 	lds	r24, 0x0668
     d9c:	90 91 69 06 	lds	r25, 0x0669
     da0:	01 96       	adiw	r24, 0x01	; 1
     da2:	90 93 69 06 	sts	0x0669, r25
     da6:	80 93 68 06 	sts	0x0668, r24
     daa:	80 91 a2 06 	lds	r24, 0x06A2
     dae:	88 30       	cpi	r24, 0x08	; 8
     db0:	a9 f0       	breq	.+42     	; 0xddc <uip_process+0x33c>
     db2:	80 91 66 06 	lds	r24, 0x0666
     db6:	90 91 67 06 	lds	r25, 0x0667
     dba:	01 96       	adiw	r24, 0x01	; 1
     dbc:	90 93 67 06 	sts	0x0667, r25
     dc0:	80 93 66 06 	sts	0x0666, r24
     dc4:	80 91 6c 06 	lds	r24, 0x066C
     dc8:	90 91 6d 06 	lds	r25, 0x066D
     dcc:	01 96       	adiw	r24, 0x01	; 1
     dce:	90 93 6d 06 	sts	0x066D, r25
     dd2:	80 93 6c 06 	sts	0x066C, r24
     dd6:	84 e4       	ldi	r24, 0x44	; 68
     dd8:	92 e0       	ldi	r25, 0x02	; 2
     dda:	82 c1       	rjmp	.+772    	; 0x10e0 <uip_process+0x640>
     ddc:	10 92 a2 06 	sts	0x06A2, r1
     de0:	80 91 a4 06 	lds	r24, 0x06A4
     de4:	90 91 a5 06 	lds	r25, 0x06A5
     de8:	4f ef       	ldi	r20, 0xFF	; 255
     dea:	87 3f       	cpi	r24, 0xF7	; 247
     dec:	94 07       	cpc	r25, r20
     dee:	10 f0       	brcs	.+4      	; 0xdf4 <uip_process+0x354>
     df0:	09 96       	adiw	r24, 0x09	; 9
     df2:	01 c0       	rjmp	.+2      	; 0xdf6 <uip_process+0x356>
     df4:	08 96       	adiw	r24, 0x08	; 8
     df6:	90 93 a5 06 	sts	0x06A5, r25
     dfa:	80 93 a4 06 	sts	0x06A4, r24
     dfe:	80 91 9a 06 	lds	r24, 0x069A
     e02:	90 91 9b 06 	lds	r25, 0x069B
     e06:	90 93 9f 06 	sts	0x069F, r25
     e0a:	80 93 9e 06 	sts	0x069E, r24
     e0e:	80 91 9c 06 	lds	r24, 0x069C
     e12:	90 91 9d 06 	lds	r25, 0x069D
     e16:	90 93 a1 06 	sts	0x06A1, r25
     e1a:	80 93 a0 06 	sts	0x06A0, r24
     e1e:	80 91 a5 01 	lds	r24, 0x01A5
     e22:	90 91 a6 01 	lds	r25, 0x01A6
     e26:	90 93 9b 06 	sts	0x069B, r25
     e2a:	80 93 9a 06 	sts	0x069A, r24
     e2e:	80 91 a7 01 	lds	r24, 0x01A7
     e32:	90 91 a8 01 	lds	r25, 0x01A8
     e36:	90 93 9d 06 	sts	0x069D, r25
     e3a:	80 93 9c 06 	sts	0x069C, r24
     e3e:	80 91 6a 06 	lds	r24, 0x066A
     e42:	90 91 6b 06 	lds	r25, 0x066B
     e46:	01 96       	adiw	r24, 0x01	; 1
     e48:	90 93 6b 06 	sts	0x066B, r25
     e4c:	80 93 6a 06 	sts	0x066A, r24
     e50:	71 c5       	rjmp	.+2786   	; 0x1934 <uip_process+0xe94>
     e52:	80 91 70 06 	lds	r24, 0x0670
     e56:	90 91 71 06 	lds	r25, 0x0671
     e5a:	01 96       	adiw	r24, 0x01	; 1
     e5c:	90 93 71 06 	sts	0x0671, r25
     e60:	80 93 70 06 	sts	0x0670, r24
     e64:	0e 94 36 04 	call	0x86c <uip_tcpchksum>
     e68:	8f 5f       	subi	r24, 0xFF	; 255
     e6a:	9f 4f       	sbci	r25, 0xFF	; 255
     e6c:	a9 f0       	breq	.+42     	; 0xe98 <uip_process+0x3f8>
     e6e:	80 91 6e 06 	lds	r24, 0x066E
     e72:	90 91 6f 06 	lds	r25, 0x066F
     e76:	01 96       	adiw	r24, 0x01	; 1
     e78:	90 93 6f 06 	sts	0x066F, r25
     e7c:	80 93 6e 06 	sts	0x066E, r24
     e80:	80 91 74 06 	lds	r24, 0x0674
     e84:	90 91 75 06 	lds	r25, 0x0675
     e88:	01 96       	adiw	r24, 0x01	; 1
     e8a:	90 93 75 06 	sts	0x0675, r25
     e8e:	80 93 74 06 	sts	0x0674, r24
     e92:	89 e5       	ldi	r24, 0x59	; 89
     e94:	92 e0       	ldi	r25, 0x02	; 2
     e96:	24 c1       	rjmp	.+584    	; 0x10e0 <uip_process+0x640>
     e98:	c8 e7       	ldi	r28, 0x78	; 120
     e9a:	d3 e0       	ldi	r29, 0x03	; 3
     e9c:	46 e0       	ldi	r20, 0x06	; 6
     e9e:	c9 30       	cpi	r28, 0x09	; 9
     ea0:	d4 07       	cpc	r29, r20
     ea2:	09 f0       	breq	.+2      	; 0xea6 <uip_process+0x406>
     ea4:	78 f5       	brcc	.+94     	; 0xf04 <uip_process+0x464>
     ea6:	e0 91 a4 06 	lds	r30, 0x06A4
     eaa:	f0 91 a5 06 	lds	r31, 0x06A5
     eae:	60 91 a2 06 	lds	r22, 0x06A2
     eb2:	70 91 a3 06 	lds	r23, 0x06A3
     eb6:	40 91 9a 06 	lds	r20, 0x069A
     eba:	50 91 9b 06 	lds	r21, 0x069B
     ebe:	20 91 9c 06 	lds	r18, 0x069C
     ec2:	30 91 9d 06 	lds	r19, 0x069D
     ec6:	89 8d       	ldd	r24, Y+25	; 0x19
     ec8:	88 23       	and	r24, r24
     eca:	a9 f0       	breq	.+42     	; 0xef6 <uip_process+0x456>
     ecc:	8c 81       	ldd	r24, Y+4	; 0x04
     ece:	9d 81       	ldd	r25, Y+5	; 0x05
     ed0:	e8 17       	cp	r30, r24
     ed2:	f9 07       	cpc	r31, r25
     ed4:	81 f4       	brne	.+32     	; 0xef6 <uip_process+0x456>
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	9f 81       	ldd	r25, Y+7	; 0x07
     eda:	68 17       	cp	r22, r24
     edc:	79 07       	cpc	r23, r25
     ede:	59 f4       	brne	.+22     	; 0xef6 <uip_process+0x456>
     ee0:	88 81       	ld	r24, Y
     ee2:	99 81       	ldd	r25, Y+1	; 0x01
     ee4:	48 17       	cp	r20, r24
     ee6:	59 07       	cpc	r21, r25
     ee8:	31 f4       	brne	.+12     	; 0xef6 <uip_process+0x456>
     eea:	8a 81       	ldd	r24, Y+2	; 0x02
     eec:	9b 81       	ldd	r25, Y+3	; 0x03
     eee:	28 17       	cp	r18, r24
     ef0:	39 07       	cpc	r19, r25
     ef2:	09 f4       	brne	.+2      	; 0xef6 <uip_process+0x456>
     ef4:	b2 c1       	rjmp	.+868    	; 0x125a <uip_process+0x7ba>
     ef6:	c7 5b       	subi	r28, 0xB7	; 183
     ef8:	df 4f       	sbci	r29, 0xFF	; 255
     efa:	86 e0       	ldi	r24, 0x06	; 6
     efc:	c9 30       	cpi	r28, 0x09	; 9
     efe:	d8 07       	cpc	r29, r24
     f00:	11 f3       	breq	.-60     	; 0xec6 <uip_process+0x426>
     f02:	08 f3       	brcs	.-62     	; 0xec6 <uip_process+0x426>
     f04:	80 91 af 06 	lds	r24, 0x06AF
     f08:	99 27       	eor	r25, r25
     f0a:	8f 73       	andi	r24, 0x3F	; 63
     f0c:	90 70       	andi	r25, 0x00	; 0
     f0e:	02 97       	sbiw	r24, 0x02	; 2
     f10:	41 f5       	brne	.+80     	; 0xf62 <uip_process+0x4c2>
     f12:	80 91 a4 06 	lds	r24, 0x06A4
     f16:	90 91 a5 06 	lds	r25, 0x06A5
     f1a:	90 93 49 03 	sts	0x0349, r25
     f1e:	80 93 48 03 	sts	0x0348, r24
     f22:	10 92 46 03 	sts	0x0346, r1
     f26:	ac 01       	movw	r20, r24
     f28:	20 91 46 03 	lds	r18, 0x0346
     f2c:	e2 2f       	mov	r30, r18
     f2e:	ff 27       	eor	r31, r31
     f30:	ee 0f       	add	r30, r30
     f32:	ff 1f       	adc	r31, r31
     f34:	ee 5a       	subi	r30, 0xAE	; 174
     f36:	f9 4f       	sbci	r31, 0xF9	; 249
     f38:	80 81       	ld	r24, Z
     f3a:	91 81       	ldd	r25, Z+1	; 0x01
     f3c:	48 17       	cp	r20, r24
     f3e:	59 07       	cpc	r21, r25
     f40:	09 f4       	brne	.+2      	; 0xf44 <uip_process+0x4a4>
     f42:	98 c0       	rjmp	.+304    	; 0x1074 <uip_process+0x5d4>
     f44:	82 2f       	mov	r24, r18
     f46:	8f 5f       	subi	r24, 0xFF	; 255
     f48:	80 93 46 03 	sts	0x0346, r24
     f4c:	88 23       	and	r24, r24
     f4e:	61 f3       	breq	.-40     	; 0xf28 <uip_process+0x488>
     f50:	80 91 7e 06 	lds	r24, 0x067E
     f54:	90 91 7f 06 	lds	r25, 0x067F
     f58:	01 96       	adiw	r24, 0x01	; 1
     f5a:	90 93 7f 06 	sts	0x067F, r25
     f5e:	80 93 7e 06 	sts	0x067E, r24
     f62:	80 91 af 06 	lds	r24, 0x06AF
     f66:	82 fd       	sbrc	r24, 2
     f68:	ef c4       	rjmp	.+2526   	; 0x1948 <uip_process+0xea8>
     f6a:	80 91 78 06 	lds	r24, 0x0678
     f6e:	90 91 79 06 	lds	r25, 0x0679
     f72:	01 96       	adiw	r24, 0x01	; 1
     f74:	90 93 79 06 	sts	0x0679, r25
     f78:	80 93 78 06 	sts	0x0678, r24
     f7c:	84 e1       	ldi	r24, 0x14	; 20
     f7e:	80 93 af 06 	sts	0x06AF, r24
     f82:	88 e2       	ldi	r24, 0x28	; 40
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	90 93 6c 03 	sts	0x036C, r25
     f8a:	80 93 6b 03 	sts	0x036B, r24
     f8e:	80 e5       	ldi	r24, 0x50	; 80
     f90:	80 93 ae 06 	sts	0x06AE, r24
     f94:	90 91 a9 06 	lds	r25, 0x06A9
     f98:	80 91 ad 06 	lds	r24, 0x06AD
     f9c:	80 93 a9 06 	sts	0x06A9, r24
     fa0:	30 91 a8 06 	lds	r19, 0x06A8
     fa4:	80 91 ac 06 	lds	r24, 0x06AC
     fa8:	80 93 a8 06 	sts	0x06A8, r24
     fac:	30 93 ac 06 	sts	0x06AC, r19
     fb0:	40 91 a7 06 	lds	r20, 0x06A7
     fb4:	80 91 ab 06 	lds	r24, 0x06AB
     fb8:	80 93 a7 06 	sts	0x06A7, r24
     fbc:	40 93 ab 06 	sts	0x06AB, r20
     fc0:	20 91 a6 06 	lds	r18, 0x06A6
     fc4:	20 93 46 03 	sts	0x0346, r18
     fc8:	80 91 aa 06 	lds	r24, 0x06AA
     fcc:	80 93 a6 06 	sts	0x06A6, r24
     fd0:	20 93 aa 06 	sts	0x06AA, r18
     fd4:	9f 5f       	subi	r25, 0xFF	; 255
     fd6:	90 93 ad 06 	sts	0x06AD, r25
     fda:	99 23       	and	r25, r25
     fdc:	79 f4       	brne	.+30     	; 0xffc <uip_process+0x55c>
     fde:	83 2f       	mov	r24, r19
     fe0:	8f 5f       	subi	r24, 0xFF	; 255
     fe2:	80 93 ac 06 	sts	0x06AC, r24
     fe6:	88 23       	and	r24, r24
     fe8:	49 f4       	brne	.+18     	; 0xffc <uip_process+0x55c>
     fea:	84 2f       	mov	r24, r20
     fec:	8f 5f       	subi	r24, 0xFF	; 255
     fee:	80 93 ab 06 	sts	0x06AB, r24
     ff2:	88 23       	and	r24, r24
     ff4:	19 f4       	brne	.+6      	; 0xffc <uip_process+0x55c>
     ff6:	2f 5f       	subi	r18, 0xFF	; 255
     ff8:	20 93 aa 06 	sts	0x06AA, r18
     ffc:	20 91 a2 06 	lds	r18, 0x06A2
    1000:	30 91 a3 06 	lds	r19, 0x06A3
    1004:	30 93 49 03 	sts	0x0349, r19
    1008:	20 93 48 03 	sts	0x0348, r18
    100c:	80 91 a4 06 	lds	r24, 0x06A4
    1010:	90 91 a5 06 	lds	r25, 0x06A5
    1014:	90 93 a3 06 	sts	0x06A3, r25
    1018:	80 93 a2 06 	sts	0x06A2, r24
    101c:	30 93 a5 06 	sts	0x06A5, r19
    1020:	20 93 a4 06 	sts	0x06A4, r18
    1024:	80 91 9a 06 	lds	r24, 0x069A
    1028:	90 91 9b 06 	lds	r25, 0x069B
    102c:	90 93 9f 06 	sts	0x069F, r25
    1030:	80 93 9e 06 	sts	0x069E, r24
    1034:	80 91 9c 06 	lds	r24, 0x069C
    1038:	90 91 9d 06 	lds	r25, 0x069D
    103c:	90 93 a1 06 	sts	0x06A1, r25
    1040:	80 93 a0 06 	sts	0x06A0, r24
    1044:	80 91 a5 01 	lds	r24, 0x01A5
    1048:	90 91 a6 01 	lds	r25, 0x01A6
    104c:	90 93 9b 06 	sts	0x069B, r25
    1050:	80 93 9a 06 	sts	0x069A, r24
    1054:	80 91 a7 01 	lds	r24, 0x01A7
    1058:	90 91 a8 01 	lds	r25, 0x01A8
    105c:	90 93 9d 06 	sts	0x069D, r25
    1060:	80 93 9c 06 	sts	0x069C, r24
    1064:	19 c4       	rjmp	.+2098   	; 0x1898 <uip_process+0xdf8>
    1066:	89 e4       	ldi	r24, 0x49	; 73
    1068:	28 9f       	mul	r18, r24
    106a:	e0 01       	movw	r28, r0
    106c:	11 24       	eor	r1, r1
    106e:	c8 58       	subi	r28, 0x88	; 136
    1070:	dc 4f       	sbci	r29, 0xFC	; 252
    1072:	29 c0       	rjmp	.+82     	; 0x10c6 <uip_process+0x626>
    1074:	c0 e0       	ldi	r28, 0x00	; 0
    1076:	d0 e0       	ldi	r29, 0x00	; 0
    1078:	10 92 46 03 	sts	0x0346, r1
    107c:	49 e4       	ldi	r20, 0x49	; 73
    107e:	50 e0       	ldi	r21, 0x00	; 0
    1080:	20 91 46 03 	lds	r18, 0x0346
    1084:	82 2f       	mov	r24, r18
    1086:	99 27       	eor	r25, r25
    1088:	84 9f       	mul	r24, r20
    108a:	f0 01       	movw	r30, r0
    108c:	85 9f       	mul	r24, r21
    108e:	f0 0d       	add	r31, r0
    1090:	94 9f       	mul	r25, r20
    1092:	f0 0d       	add	r31, r0
    1094:	11 24       	eor	r1, r1
    1096:	e8 58       	subi	r30, 0x88	; 136
    1098:	fc 4f       	sbci	r31, 0xFC	; 252
    109a:	81 8d       	ldd	r24, Z+25	; 0x19
    109c:	88 23       	and	r24, r24
    109e:	19 f3       	breq	.-58     	; 0x1066 <uip_process+0x5c6>
    10a0:	87 30       	cpi	r24, 0x07	; 7
    10a2:	59 f4       	brne	.+22     	; 0x10ba <uip_process+0x61a>
    10a4:	20 97       	sbiw	r28, 0x00	; 0
    10a6:	21 f0       	breq	.+8      	; 0x10b0 <uip_process+0x610>
    10a8:	92 8d       	ldd	r25, Z+26	; 0x1a
    10aa:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ac:	89 17       	cp	r24, r25
    10ae:	28 f4       	brcc	.+10     	; 0x10ba <uip_process+0x61a>
    10b0:	24 9f       	mul	r18, r20
    10b2:	e0 01       	movw	r28, r0
    10b4:	11 24       	eor	r1, r1
    10b6:	c8 58       	subi	r28, 0x88	; 136
    10b8:	dc 4f       	sbci	r29, 0xFC	; 252
    10ba:	82 2f       	mov	r24, r18
    10bc:	8f 5f       	subi	r24, 0xFF	; 255
    10be:	80 93 46 03 	sts	0x0346, r24
    10c2:	8a 30       	cpi	r24, 0x0A	; 10
    10c4:	e8 f2       	brcs	.-70     	; 0x1080 <uip_process+0x5e0>
    10c6:	20 97       	sbiw	r28, 0x00	; 0
    10c8:	71 f4       	brne	.+28     	; 0x10e6 <uip_process+0x646>
    10ca:	80 91 7c 06 	lds	r24, 0x067C
    10ce:	90 91 7d 06 	lds	r25, 0x067D
    10d2:	01 96       	adiw	r24, 0x01	; 1
    10d4:	90 93 7d 06 	sts	0x067D, r25
    10d8:	80 93 7c 06 	sts	0x067C, r24
    10dc:	8c e6       	ldi	r24, 0x6C	; 108
    10de:	92 e0       	ldi	r25, 0x02	; 2
    10e0:	0e 94 e5 00 	call	0x1ca <uip_log>
    10e4:	31 c4       	rjmp	.+2146   	; 0x1948 <uip_process+0xea8>
    10e6:	d0 93 77 03 	sts	0x0377, r29
    10ea:	c0 93 76 03 	sts	0x0376, r28
    10ee:	83 e0       	ldi	r24, 0x03	; 3
    10f0:	8a 8f       	std	Y+26, r24	; 0x1a
    10f2:	88 8f       	std	Y+24, r24	; 0x18
    10f4:	1e 8a       	std	Y+22, r1	; 0x16
    10f6:	84 e0       	ldi	r24, 0x04	; 4
    10f8:	8f 8b       	std	Y+23, r24	; 0x17
    10fa:	1b 8e       	std	Y+27, r1	; 0x1b
    10fc:	80 91 a4 06 	lds	r24, 0x06A4
    1100:	90 91 a5 06 	lds	r25, 0x06A5
    1104:	9d 83       	std	Y+5, r25	; 0x05
    1106:	8c 83       	std	Y+4, r24	; 0x04
    1108:	80 91 a2 06 	lds	r24, 0x06A2
    110c:	90 91 a3 06 	lds	r25, 0x06A3
    1110:	9f 83       	std	Y+7, r25	; 0x07
    1112:	8e 83       	std	Y+6, r24	; 0x06
    1114:	80 91 9a 06 	lds	r24, 0x069A
    1118:	90 91 9b 06 	lds	r25, 0x069B
    111c:	99 83       	std	Y+1, r25	; 0x01
    111e:	88 83       	st	Y, r24
    1120:	80 91 9c 06 	lds	r24, 0x069C
    1124:	90 91 9d 06 	lds	r25, 0x069D
    1128:	9b 83       	std	Y+3, r25	; 0x03
    112a:	8a 83       	std	Y+2, r24	; 0x02
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	89 8f       	std	Y+25, r24	; 0x19
    1130:	80 91 40 03 	lds	r24, 0x0340
    1134:	8c 87       	std	Y+12, r24	; 0x0c
    1136:	80 91 41 03 	lds	r24, 0x0341
    113a:	8d 87       	std	Y+13, r24	; 0x0d
    113c:	80 91 42 03 	lds	r24, 0x0342
    1140:	8e 87       	std	Y+14, r24	; 0x0e
    1142:	80 91 43 03 	lds	r24, 0x0343
    1146:	8f 87       	std	Y+15, r24	; 0x0f
    1148:	21 e0       	ldi	r18, 0x01	; 1
    114a:	30 e0       	ldi	r19, 0x00	; 0
    114c:	39 8b       	std	Y+17, r19	; 0x11
    114e:	28 8b       	std	Y+16, r18	; 0x10
    1150:	80 91 a9 06 	lds	r24, 0x06A9
    1154:	8b 87       	std	Y+11, r24	; 0x0b
    1156:	80 91 a8 06 	lds	r24, 0x06A8
    115a:	8a 87       	std	Y+10, r24	; 0x0a
    115c:	80 91 a7 06 	lds	r24, 0x06A7
    1160:	89 87       	std	Y+9, r24	; 0x09
    1162:	80 91 a6 06 	lds	r24, 0x06A6
    1166:	88 87       	std	Y+8, r24	; 0x08
    1168:	c9 01       	movw	r24, r18
    116a:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    116e:	20 91 ae 06 	lds	r18, 0x06AE
    1172:	82 2f       	mov	r24, r18
    1174:	99 27       	eor	r25, r25
    1176:	80 7f       	andi	r24, 0xF0	; 240
    1178:	90 70       	andi	r25, 0x00	; 0
    117a:	81 35       	cpi	r24, 0x51	; 81
    117c:	91 05       	cpc	r25, r1
    117e:	0c f4       	brge	.+2      	; 0x1182 <uip_process+0x6e2>
    1180:	50 c0       	rjmp	.+160    	; 0x1222 <uip_process+0x782>
    1182:	10 92 46 03 	sts	0x0346, r1
    1186:	22 95       	swap	r18
    1188:	2f 70       	andi	r18, 0x0F	; 15
    118a:	82 2f       	mov	r24, r18
    118c:	99 27       	eor	r25, r25
    118e:	05 97       	sbiw	r24, 0x05	; 5
    1190:	88 0f       	add	r24, r24
    1192:	99 1f       	adc	r25, r25
    1194:	88 0f       	add	r24, r24
    1196:	99 1f       	adc	r25, r25
    1198:	18 16       	cp	r1, r24
    119a:	19 06       	cpc	r1, r25
    119c:	0c f0       	brlt	.+2      	; 0x11a0 <uip_process+0x700>
    119e:	41 c0       	rjmp	.+130    	; 0x1222 <uip_process+0x782>
    11a0:	ac 01       	movw	r20, r24
    11a2:	20 91 48 03 	lds	r18, 0x0348
    11a6:	30 91 49 03 	lds	r19, 0x0349
    11aa:	90 91 46 03 	lds	r25, 0x0346
    11ae:	e9 2f       	mov	r30, r25
    11b0:	ff 27       	eor	r31, r31
    11b2:	e0 58       	subi	r30, 0x80	; 128
    11b4:	f9 4f       	sbci	r31, 0xF9	; 249
    11b6:	86 a9       	ldd	r24, Z+54	; 0x36
    11b8:	80 93 47 03 	sts	0x0347, r24
    11bc:	88 23       	and	r24, r24
    11be:	69 f1       	breq	.+90     	; 0x121a <uip_process+0x77a>
    11c0:	81 30       	cpi	r24, 0x01	; 1
    11c2:	11 f4       	brne	.+4      	; 0x11c8 <uip_process+0x728>
    11c4:	9f 5f       	subi	r25, 0xFF	; 255
    11c6:	21 c0       	rjmp	.+66     	; 0x120a <uip_process+0x76a>
    11c8:	82 30       	cpi	r24, 0x02	; 2
    11ca:	b9 f4       	brne	.+46     	; 0x11fa <uip_process+0x75a>
    11cc:	87 a9       	ldd	r24, Z+55	; 0x37
    11ce:	84 30       	cpi	r24, 0x04	; 4
    11d0:	a1 f4       	brne	.+40     	; 0x11fa <uip_process+0x75a>
    11d2:	80 ad       	ldd	r24, Z+56	; 0x38
    11d4:	99 27       	eor	r25, r25
    11d6:	38 2f       	mov	r19, r24
    11d8:	22 27       	eor	r18, r18
    11da:	81 ad       	ldd	r24, Z+57	; 0x39
    11dc:	99 27       	eor	r25, r25
    11de:	28 2b       	or	r18, r24
    11e0:	39 2b       	or	r19, r25
    11e2:	c9 01       	movw	r24, r18
    11e4:	41 e0       	ldi	r20, 0x01	; 1
    11e6:	2f 36       	cpi	r18, 0x6F	; 111
    11e8:	34 07       	cpc	r19, r20
    11ea:	10 f0       	brcs	.+4      	; 0x11f0 <uip_process+0x750>
    11ec:	8e e6       	ldi	r24, 0x6E	; 110
    11ee:	91 e0       	ldi	r25, 0x01	; 1
    11f0:	9b 8b       	std	Y+19, r25	; 0x13
    11f2:	8a 8b       	std	Y+18, r24	; 0x12
    11f4:	9d 8b       	std	Y+21, r25	; 0x15
    11f6:	8c 8b       	std	Y+20, r24	; 0x14
    11f8:	10 c0       	rjmp	.+32     	; 0x121a <uip_process+0x77a>
    11fa:	e9 2f       	mov	r30, r25
    11fc:	ff 27       	eor	r31, r31
    11fe:	e0 58       	subi	r30, 0x80	; 128
    1200:	f9 4f       	sbci	r31, 0xF9	; 249
    1202:	87 a9       	ldd	r24, Z+55	; 0x37
    1204:	88 23       	and	r24, r24
    1206:	49 f0       	breq	.+18     	; 0x121a <uip_process+0x77a>
    1208:	98 0f       	add	r25, r24
    120a:	90 93 46 03 	sts	0x0346, r25
    120e:	80 91 46 03 	lds	r24, 0x0346
    1212:	99 27       	eor	r25, r25
    1214:	84 17       	cp	r24, r20
    1216:	95 07       	cpc	r25, r21
    1218:	44 f2       	brlt	.-112    	; 0x11aa <uip_process+0x70a>
    121a:	30 93 49 03 	sts	0x0349, r19
    121e:	20 93 48 03 	sts	0x0348, r18
    1222:	80 e1       	ldi	r24, 0x10	; 16
    1224:	80 93 af 06 	sts	0x06AF, r24
    1228:	80 91 af 06 	lds	r24, 0x06AF
    122c:	82 60       	ori	r24, 0x02	; 2
    122e:	80 93 af 06 	sts	0x06AF, r24
    1232:	82 e0       	ldi	r24, 0x02	; 2
    1234:	80 93 b6 06 	sts	0x06B6, r24
    1238:	84 e0       	ldi	r24, 0x04	; 4
    123a:	80 93 b7 06 	sts	0x06B7, r24
    123e:	81 e0       	ldi	r24, 0x01	; 1
    1240:	80 93 b8 06 	sts	0x06B8, r24
    1244:	8e e6       	ldi	r24, 0x6E	; 110
    1246:	80 93 b9 06 	sts	0x06B9, r24
    124a:	8c e2       	ldi	r24, 0x2C	; 44
    124c:	90 e0       	ldi	r25, 0x00	; 0
    124e:	90 93 6c 03 	sts	0x036C, r25
    1252:	80 93 6b 03 	sts	0x036B, r24
    1256:	80 e6       	ldi	r24, 0x60	; 96
    1258:	cc c2       	rjmp	.+1432   	; 0x17f2 <uip_process+0xd52>
    125a:	d0 93 77 03 	sts	0x0377, r29
    125e:	c0 93 76 03 	sts	0x0376, r28
    1262:	10 92 73 03 	sts	0x0373, r1
    1266:	60 91 af 06 	lds	r22, 0x06AF
    126a:	46 2f       	mov	r20, r22
    126c:	55 27       	eor	r21, r21
    126e:	42 ff       	sbrs	r20, 2
    1270:	07 c0       	rjmp	.+14     	; 0x1280 <uip_process+0x7e0>
    1272:	19 8e       	std	Y+25, r1	; 0x19
    1274:	8e e8       	ldi	r24, 0x8E	; 142
    1276:	92 e0       	ldi	r25, 0x02	; 2
    1278:	0e 94 e5 00 	call	0x1ca <uip_log>
    127c:	80 e2       	ldi	r24, 0x20	; 32
    127e:	5d c2       	rjmp	.+1210   	; 0x173a <uip_process+0xc9a>
    1280:	80 91 ae 06 	lds	r24, 0x06AE
    1284:	82 95       	swap	r24
    1286:	8f 70       	andi	r24, 0x0F	; 15
    1288:	88 0f       	add	r24, r24
    128a:	88 0f       	add	r24, r24
    128c:	80 93 46 03 	sts	0x0346, r24
    1290:	20 91 6b 03 	lds	r18, 0x036B
    1294:	30 91 6c 03 	lds	r19, 0x036C
    1298:	28 1b       	sub	r18, r24
    129a:	31 09       	sbc	r19, r1
    129c:	24 51       	subi	r18, 0x14	; 20
    129e:	30 40       	sbci	r19, 0x00	; 0
    12a0:	30 93 6c 03 	sts	0x036C, r19
    12a4:	20 93 6b 03 	sts	0x036B, r18
    12a8:	89 8d       	ldd	r24, Y+25	; 0x19
    12aa:	99 27       	eor	r25, r25
    12ac:	8f 70       	andi	r24, 0x0F	; 15
    12ae:	90 70       	andi	r25, 0x00	; 0
    12b0:	02 97       	sbiw	r24, 0x02	; 2
    12b2:	29 f4       	brne	.+10     	; 0x12be <uip_process+0x81e>
    12b4:	ca 01       	movw	r24, r20
    12b6:	8f 73       	andi	r24, 0x3F	; 63
    12b8:	90 70       	andi	r25, 0x00	; 0
    12ba:	42 97       	sbiw	r24, 0x12	; 18
    12bc:	f1 f0       	breq	.+60     	; 0x12fa <uip_process+0x85a>
    12be:	23 2b       	or	r18, r19
    12c0:	21 f4       	brne	.+8      	; 0x12ca <uip_process+0x82a>
    12c2:	43 70       	andi	r20, 0x03	; 3
    12c4:	50 70       	andi	r21, 0x00	; 0
    12c6:	45 2b       	or	r20, r21
    12c8:	c1 f0       	breq	.+48     	; 0x12fa <uip_process+0x85a>
    12ca:	90 91 a6 06 	lds	r25, 0x06A6
    12ce:	88 85       	ldd	r24, Y+8	; 0x08
    12d0:	98 17       	cp	r25, r24
    12d2:	09 f0       	breq	.+2      	; 0x12d6 <uip_process+0x836>
    12d4:	84 c2       	rjmp	.+1288   	; 0x17de <uip_process+0xd3e>
    12d6:	90 91 a7 06 	lds	r25, 0x06A7
    12da:	89 85       	ldd	r24, Y+9	; 0x09
    12dc:	98 17       	cp	r25, r24
    12de:	09 f0       	breq	.+2      	; 0x12e2 <uip_process+0x842>
    12e0:	7e c2       	rjmp	.+1276   	; 0x17de <uip_process+0xd3e>
    12e2:	90 91 a8 06 	lds	r25, 0x06A8
    12e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    12e8:	98 17       	cp	r25, r24
    12ea:	09 f0       	breq	.+2      	; 0x12ee <uip_process+0x84e>
    12ec:	78 c2       	rjmp	.+1264   	; 0x17de <uip_process+0xd3e>
    12ee:	90 91 a9 06 	lds	r25, 0x06A9
    12f2:	8b 85       	ldd	r24, Y+11	; 0x0b
    12f4:	98 17       	cp	r25, r24
    12f6:	09 f0       	breq	.+2      	; 0x12fa <uip_process+0x85a>
    12f8:	72 c2       	rjmp	.+1252   	; 0x17de <uip_process+0xd3e>
    12fa:	64 ff       	sbrs	r22, 4
    12fc:	51 c0       	rjmp	.+162    	; 0x13a0 <uip_process+0x900>
    12fe:	68 89       	ldd	r22, Y+16	; 0x10
    1300:	79 89       	ldd	r23, Y+17	; 0x11
    1302:	61 15       	cp	r22, r1
    1304:	71 05       	cpc	r23, r1
    1306:	09 f4       	brne	.+2      	; 0x130a <uip_process+0x86a>
    1308:	4b c0       	rjmp	.+150    	; 0x13a0 <uip_process+0x900>
    130a:	ce 01       	movw	r24, r28
    130c:	0c 96       	adiw	r24, 0x0c	; 12
    130e:	0e 94 91 03 	call	0x722 <uip_add32>
    1312:	20 91 aa 06 	lds	r18, 0x06AA
    1316:	80 91 6f 03 	lds	r24, 0x036F
    131a:	28 17       	cp	r18, r24
    131c:	09 f0       	breq	.+2      	; 0x1320 <uip_process+0x880>
    131e:	40 c0       	rjmp	.+128    	; 0x13a0 <uip_process+0x900>
    1320:	90 91 ab 06 	lds	r25, 0x06AB
    1324:	80 91 70 03 	lds	r24, 0x0370
    1328:	98 17       	cp	r25, r24
    132a:	d1 f5       	brne	.+116    	; 0x13a0 <uip_process+0x900>
    132c:	90 91 ac 06 	lds	r25, 0x06AC
    1330:	80 91 71 03 	lds	r24, 0x0371
    1334:	98 17       	cp	r25, r24
    1336:	a1 f5       	brne	.+104    	; 0x13a0 <uip_process+0x900>
    1338:	90 91 ad 06 	lds	r25, 0x06AD
    133c:	80 91 72 03 	lds	r24, 0x0372
    1340:	98 17       	cp	r25, r24
    1342:	71 f5       	brne	.+92     	; 0x13a0 <uip_process+0x900>
    1344:	2c 87       	std	Y+12, r18	; 0x0c
    1346:	80 91 70 03 	lds	r24, 0x0370
    134a:	8d 87       	std	Y+13, r24	; 0x0d
    134c:	80 91 71 03 	lds	r24, 0x0371
    1350:	8e 87       	std	Y+14, r24	; 0x0e
    1352:	80 91 72 03 	lds	r24, 0x0372
    1356:	8f 87       	std	Y+15, r24	; 0x0f
    1358:	8b 8d       	ldd	r24, Y+27	; 0x1b
    135a:	88 23       	and	r24, r24
    135c:	d1 f4       	brne	.+52     	; 0x1392 <uip_process+0x8f2>
    135e:	98 8d       	ldd	r25, Y+24	; 0x18
    1360:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1362:	98 1b       	sub	r25, r24
    1364:	2e 89       	ldd	r18, Y+22	; 0x16
    1366:	82 2f       	mov	r24, r18
    1368:	86 95       	lsr	r24
    136a:	86 95       	lsr	r24
    136c:	86 95       	lsr	r24
    136e:	98 1b       	sub	r25, r24
    1370:	29 0f       	add	r18, r25
    1372:	2e 8b       	std	Y+22, r18	; 0x16
    1374:	89 2f       	mov	r24, r25
    1376:	87 fd       	sbrc	r24, 7
    1378:	81 95       	neg	r24
    137a:	3f 89       	ldd	r19, Y+23	; 0x17
    137c:	93 2f       	mov	r25, r19
    137e:	96 95       	lsr	r25
    1380:	96 95       	lsr	r25
    1382:	89 1b       	sub	r24, r25
    1384:	83 0f       	add	r24, r19
    1386:	8f 8b       	std	Y+23, r24	; 0x17
    1388:	26 95       	lsr	r18
    138a:	26 95       	lsr	r18
    138c:	26 95       	lsr	r18
    138e:	28 0f       	add	r18, r24
    1390:	28 8f       	std	Y+24, r18	; 0x18
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	80 93 73 03 	sts	0x0373, r24
    1398:	88 8d       	ldd	r24, Y+24	; 0x18
    139a:	8a 8f       	std	Y+26, r24	; 0x1a
    139c:	19 8a       	std	Y+17, r1	; 0x11
    139e:	18 8a       	std	Y+16, r1	; 0x10
    13a0:	89 8d       	ldd	r24, Y+25	; 0x19
    13a2:	48 2f       	mov	r20, r24
    13a4:	55 27       	eor	r21, r21
    13a6:	9a 01       	movw	r18, r20
    13a8:	2f 70       	andi	r18, 0x0F	; 15
    13aa:	30 70       	andi	r19, 0x00	; 0
    13ac:	24 30       	cpi	r18, 0x04	; 4
    13ae:	31 05       	cpc	r19, r1
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <uip_process+0x914>
    13b2:	c8 c1       	rjmp	.+912    	; 0x1744 <uip_process+0xca4>
    13b4:	25 30       	cpi	r18, 0x05	; 5
    13b6:	31 05       	cpc	r19, r1
    13b8:	5c f4       	brge	.+22     	; 0x13d0 <uip_process+0x930>
    13ba:	22 30       	cpi	r18, 0x02	; 2
    13bc:	31 05       	cpc	r19, r1
    13be:	99 f1       	breq	.+102    	; 0x1426 <uip_process+0x986>
    13c0:	23 30       	cpi	r18, 0x03	; 3
    13c2:	31 05       	cpc	r19, r1
    13c4:	0c f0       	brlt	.+2      	; 0x13c8 <uip_process+0x928>
    13c6:	bc c0       	rjmp	.+376    	; 0x1540 <uip_process+0xaa0>
    13c8:	21 30       	cpi	r18, 0x01	; 1
    13ca:	31 05       	cpc	r19, r1
    13cc:	91 f0       	breq	.+36     	; 0x13f2 <uip_process+0x952>
    13ce:	bc c2       	rjmp	.+1400   	; 0x1948 <uip_process+0xea8>
    13d0:	26 30       	cpi	r18, 0x06	; 6
    13d2:	31 05       	cpc	r19, r1
    13d4:	09 f4       	brne	.+2      	; 0x13d8 <uip_process+0x938>
    13d6:	fb c1       	rjmp	.+1014   	; 0x17ce <uip_process+0xd2e>
    13d8:	26 30       	cpi	r18, 0x06	; 6
    13da:	31 05       	cpc	r19, r1
    13dc:	0c f4       	brge	.+2      	; 0x13e0 <uip_process+0x940>
    13de:	d6 c1       	rjmp	.+940    	; 0x178c <uip_process+0xcec>
    13e0:	27 30       	cpi	r18, 0x07	; 7
    13e2:	31 05       	cpc	r19, r1
    13e4:	09 f4       	brne	.+2      	; 0x13e8 <uip_process+0x948>
    13e6:	fb c1       	rjmp	.+1014   	; 0x17de <uip_process+0xd3e>
    13e8:	28 30       	cpi	r18, 0x08	; 8
    13ea:	31 05       	cpc	r19, r1
    13ec:	09 f4       	brne	.+2      	; 0x13f0 <uip_process+0x950>
    13ee:	9f c1       	rjmp	.+830    	; 0x172e <uip_process+0xc8e>
    13f0:	ab c2       	rjmp	.+1366   	; 0x1948 <uip_process+0xea8>
    13f2:	80 91 73 03 	lds	r24, 0x0373
    13f6:	80 ff       	sbrs	r24, 0
    13f8:	a7 c2       	rjmp	.+1358   	; 0x1948 <uip_process+0xea8>
    13fa:	83 e0       	ldi	r24, 0x03	; 3
    13fc:	89 8f       	std	Y+25, r24	; 0x19
    13fe:	80 e4       	ldi	r24, 0x40	; 64
    1400:	80 93 73 03 	sts	0x0373, r24
    1404:	19 8a       	std	Y+17, r1	; 0x11
    1406:	18 8a       	std	Y+16, r1	; 0x10
    1408:	20 91 6b 03 	lds	r18, 0x036B
    140c:	30 91 6c 03 	lds	r19, 0x036C
    1410:	21 15       	cp	r18, r1
    1412:	31 05       	cpc	r19, r1
    1414:	09 f4       	brne	.+2      	; 0x1418 <uip_process+0x978>
    1416:	15 c1       	rjmp	.+554    	; 0x1642 <uip_process+0xba2>
    1418:	82 e4       	ldi	r24, 0x42	; 66
    141a:	80 93 73 03 	sts	0x0373, r24
    141e:	c9 01       	movw	r24, r18
    1420:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    1424:	0e c1       	rjmp	.+540    	; 0x1642 <uip_process+0xba2>
    1426:	80 91 73 03 	lds	r24, 0x0373
    142a:	80 ff       	sbrs	r24, 0
    142c:	7e c0       	rjmp	.+252    	; 0x152a <uip_process+0xa8a>
    142e:	80 91 af 06 	lds	r24, 0x06AF
    1432:	99 27       	eor	r25, r25
    1434:	8f 73       	andi	r24, 0x3F	; 63
    1436:	90 70       	andi	r25, 0x00	; 0
    1438:	42 97       	sbiw	r24, 0x12	; 18
    143a:	09 f0       	breq	.+2      	; 0x143e <uip_process+0x99e>
    143c:	76 c0       	rjmp	.+236    	; 0x152a <uip_process+0xa8a>
    143e:	20 91 ae 06 	lds	r18, 0x06AE
    1442:	82 2f       	mov	r24, r18
    1444:	99 27       	eor	r25, r25
    1446:	80 7f       	andi	r24, 0xF0	; 240
    1448:	90 70       	andi	r25, 0x00	; 0
    144a:	81 35       	cpi	r24, 0x51	; 81
    144c:	91 05       	cpc	r25, r1
    144e:	0c f4       	brge	.+2      	; 0x1452 <uip_process+0x9b2>
    1450:	50 c0       	rjmp	.+160    	; 0x14f2 <uip_process+0xa52>
    1452:	10 92 46 03 	sts	0x0346, r1
    1456:	22 95       	swap	r18
    1458:	2f 70       	andi	r18, 0x0F	; 15
    145a:	82 2f       	mov	r24, r18
    145c:	99 27       	eor	r25, r25
    145e:	05 97       	sbiw	r24, 0x05	; 5
    1460:	88 0f       	add	r24, r24
    1462:	99 1f       	adc	r25, r25
    1464:	88 0f       	add	r24, r24
    1466:	99 1f       	adc	r25, r25
    1468:	18 16       	cp	r1, r24
    146a:	19 06       	cpc	r1, r25
    146c:	0c f0       	brlt	.+2      	; 0x1470 <uip_process+0x9d0>
    146e:	41 c0       	rjmp	.+130    	; 0x14f2 <uip_process+0xa52>
    1470:	ac 01       	movw	r20, r24
    1472:	20 91 48 03 	lds	r18, 0x0348
    1476:	30 91 49 03 	lds	r19, 0x0349
    147a:	90 91 46 03 	lds	r25, 0x0346
    147e:	e9 2f       	mov	r30, r25
    1480:	ff 27       	eor	r31, r31
    1482:	e0 58       	subi	r30, 0x80	; 128
    1484:	f9 4f       	sbci	r31, 0xF9	; 249
    1486:	86 a9       	ldd	r24, Z+54	; 0x36
    1488:	80 93 47 03 	sts	0x0347, r24
    148c:	88 23       	and	r24, r24
    148e:	69 f1       	breq	.+90     	; 0x14ea <uip_process+0xa4a>
    1490:	81 30       	cpi	r24, 0x01	; 1
    1492:	11 f4       	brne	.+4      	; 0x1498 <uip_process+0x9f8>
    1494:	9f 5f       	subi	r25, 0xFF	; 255
    1496:	21 c0       	rjmp	.+66     	; 0x14da <uip_process+0xa3a>
    1498:	82 30       	cpi	r24, 0x02	; 2
    149a:	b9 f4       	brne	.+46     	; 0x14ca <uip_process+0xa2a>
    149c:	87 a9       	ldd	r24, Z+55	; 0x37
    149e:	84 30       	cpi	r24, 0x04	; 4
    14a0:	a1 f4       	brne	.+40     	; 0x14ca <uip_process+0xa2a>
    14a2:	80 ad       	ldd	r24, Z+56	; 0x38
    14a4:	99 27       	eor	r25, r25
    14a6:	38 2f       	mov	r19, r24
    14a8:	22 27       	eor	r18, r18
    14aa:	81 ad       	ldd	r24, Z+57	; 0x39
    14ac:	99 27       	eor	r25, r25
    14ae:	28 2b       	or	r18, r24
    14b0:	39 2b       	or	r19, r25
    14b2:	c9 01       	movw	r24, r18
    14b4:	41 e0       	ldi	r20, 0x01	; 1
    14b6:	2f 36       	cpi	r18, 0x6F	; 111
    14b8:	34 07       	cpc	r19, r20
    14ba:	10 f0       	brcs	.+4      	; 0x14c0 <uip_process+0xa20>
    14bc:	8e e6       	ldi	r24, 0x6E	; 110
    14be:	91 e0       	ldi	r25, 0x01	; 1
    14c0:	9b 8b       	std	Y+19, r25	; 0x13
    14c2:	8a 8b       	std	Y+18, r24	; 0x12
    14c4:	9d 8b       	std	Y+21, r25	; 0x15
    14c6:	8c 8b       	std	Y+20, r24	; 0x14
    14c8:	10 c0       	rjmp	.+32     	; 0x14ea <uip_process+0xa4a>
    14ca:	e9 2f       	mov	r30, r25
    14cc:	ff 27       	eor	r31, r31
    14ce:	e0 58       	subi	r30, 0x80	; 128
    14d0:	f9 4f       	sbci	r31, 0xF9	; 249
    14d2:	87 a9       	ldd	r24, Z+55	; 0x37
    14d4:	88 23       	and	r24, r24
    14d6:	49 f0       	breq	.+18     	; 0x14ea <uip_process+0xa4a>
    14d8:	98 0f       	add	r25, r24
    14da:	90 93 46 03 	sts	0x0346, r25
    14de:	80 91 46 03 	lds	r24, 0x0346
    14e2:	99 27       	eor	r25, r25
    14e4:	84 17       	cp	r24, r20
    14e6:	95 07       	cpc	r25, r21
    14e8:	44 f2       	brlt	.-112    	; 0x147a <uip_process+0x9da>
    14ea:	30 93 49 03 	sts	0x0349, r19
    14ee:	20 93 48 03 	sts	0x0348, r18
    14f2:	83 e0       	ldi	r24, 0x03	; 3
    14f4:	89 8f       	std	Y+25, r24	; 0x19
    14f6:	80 91 a6 06 	lds	r24, 0x06A6
    14fa:	88 87       	std	Y+8, r24	; 0x08
    14fc:	80 91 a7 06 	lds	r24, 0x06A7
    1500:	89 87       	std	Y+9, r24	; 0x09
    1502:	80 91 a8 06 	lds	r24, 0x06A8
    1506:	8a 87       	std	Y+10, r24	; 0x0a
    1508:	80 91 a9 06 	lds	r24, 0x06A9
    150c:	8b 87       	std	Y+11, r24	; 0x0b
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    1516:	82 e4       	ldi	r24, 0x42	; 66
    1518:	80 93 73 03 	sts	0x0373, r24
    151c:	19 8a       	std	Y+17, r1	; 0x11
    151e:	18 8a       	std	Y+16, r1	; 0x10
    1520:	10 92 6c 03 	sts	0x036C, r1
    1524:	10 92 6b 03 	sts	0x036B, r1
    1528:	8c c0       	rjmp	.+280    	; 0x1642 <uip_process+0xba2>
    152a:	80 e2       	ldi	r24, 0x20	; 32
    152c:	80 93 73 03 	sts	0x0373, r24
    1530:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
    1534:	e0 91 76 03 	lds	r30, 0x0376
    1538:	f0 91 77 03 	lds	r31, 0x0377
    153c:	11 8e       	std	Z+25, r1	; 0x19
    153e:	11 cd       	rjmp	.-1502   	; 0xf62 <uip_process+0x4c2>
    1540:	90 91 af 06 	lds	r25, 0x06AF
    1544:	90 ff       	sbrs	r25, 0
    1546:	25 c0       	rjmp	.+74     	; 0x1592 <uip_process+0xaf2>
    1548:	44 fd       	sbrc	r20, 4
    154a:	23 c0       	rjmp	.+70     	; 0x1592 <uip_process+0xaf2>
    154c:	88 89       	ldd	r24, Y+16	; 0x10
    154e:	99 89       	ldd	r25, Y+17	; 0x11
    1550:	89 2b       	or	r24, r25
    1552:	09 f0       	breq	.+2      	; 0x1556 <uip_process+0xab6>
    1554:	f9 c1       	rjmp	.+1010   	; 0x1948 <uip_process+0xea8>
    1556:	80 91 6b 03 	lds	r24, 0x036B
    155a:	90 91 6c 03 	lds	r25, 0x036C
    155e:	01 96       	adiw	r24, 0x01	; 1
    1560:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    1564:	20 91 73 03 	lds	r18, 0x0373
    1568:	82 2f       	mov	r24, r18
    156a:	80 61       	ori	r24, 0x10	; 16
    156c:	80 93 73 03 	sts	0x0373, r24
    1570:	80 91 6b 03 	lds	r24, 0x036B
    1574:	90 91 6c 03 	lds	r25, 0x036C
    1578:	89 2b       	or	r24, r25
    157a:	19 f0       	breq	.+6      	; 0x1582 <uip_process+0xae2>
    157c:	22 61       	ori	r18, 0x12	; 18
    157e:	20 93 73 03 	sts	0x0373, r18
    1582:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
    1586:	81 e0       	ldi	r24, 0x01	; 1
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	99 8b       	std	Y+17, r25	; 0x11
    158c:	88 8b       	std	Y+16, r24	; 0x10
    158e:	88 e0       	ldi	r24, 0x08	; 8
    1590:	7c c0       	rjmp	.+248    	; 0x168a <uip_process+0xbea>
    1592:	95 ff       	sbrs	r25, 5
    1594:	1e c0       	rjmp	.+60     	; 0x15d2 <uip_process+0xb32>
    1596:	80 91 b4 06 	lds	r24, 0x06B4
    159a:	99 27       	eor	r25, r25
    159c:	38 2f       	mov	r19, r24
    159e:	22 27       	eor	r18, r18
    15a0:	80 91 b5 06 	lds	r24, 0x06B5
    15a4:	99 27       	eor	r25, r25
    15a6:	28 2b       	or	r18, r24
    15a8:	39 2b       	or	r19, r25
    15aa:	80 91 74 03 	lds	r24, 0x0374
    15ae:	90 91 75 03 	lds	r25, 0x0375
    15b2:	82 0f       	add	r24, r18
    15b4:	93 1f       	adc	r25, r19
    15b6:	90 93 75 03 	sts	0x0375, r25
    15ba:	80 93 74 03 	sts	0x0374, r24
    15be:	80 91 6b 03 	lds	r24, 0x036B
    15c2:	90 91 6c 03 	lds	r25, 0x036C
    15c6:	82 1b       	sub	r24, r18
    15c8:	93 0b       	sbc	r25, r19
    15ca:	90 93 6c 03 	sts	0x036C, r25
    15ce:	80 93 6b 03 	sts	0x036B, r24
    15d2:	20 91 6b 03 	lds	r18, 0x036B
    15d6:	30 91 6c 03 	lds	r19, 0x036C
    15da:	21 15       	cp	r18, r1
    15dc:	31 05       	cpc	r19, r1
    15de:	59 f0       	breq	.+22     	; 0x15f6 <uip_process+0xb56>
    15e0:	89 8d       	ldd	r24, Y+25	; 0x19
    15e2:	84 fd       	sbrc	r24, 4
    15e4:	08 c0       	rjmp	.+16     	; 0x15f6 <uip_process+0xb56>
    15e6:	80 91 73 03 	lds	r24, 0x0373
    15ea:	82 60       	ori	r24, 0x02	; 2
    15ec:	80 93 73 03 	sts	0x0373, r24
    15f0:	c9 01       	movw	r24, r18
    15f2:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    15f6:	80 91 b0 06 	lds	r24, 0x06B0
    15fa:	99 27       	eor	r25, r25
    15fc:	38 2f       	mov	r19, r24
    15fe:	22 27       	eor	r18, r18
    1600:	80 91 b1 06 	lds	r24, 0x06B1
    1604:	28 0f       	add	r18, r24
    1606:	31 1d       	adc	r19, r1
    1608:	30 93 49 03 	sts	0x0349, r19
    160c:	20 93 48 03 	sts	0x0348, r18
    1610:	8c 89       	ldd	r24, Y+20	; 0x14
    1612:	9d 89       	ldd	r25, Y+21	; 0x15
    1614:	82 17       	cp	r24, r18
    1616:	93 07       	cpc	r25, r19
    1618:	10 f0       	brcs	.+4      	; 0x161e <uip_process+0xb7e>
    161a:	23 2b       	or	r18, r19
    161c:	21 f4       	brne	.+8      	; 0x1626 <uip_process+0xb86>
    161e:	90 93 49 03 	sts	0x0349, r25
    1622:	80 93 48 03 	sts	0x0348, r24
    1626:	80 91 48 03 	lds	r24, 0x0348
    162a:	90 91 49 03 	lds	r25, 0x0349
    162e:	9b 8b       	std	Y+19, r25	; 0x13
    1630:	8a 8b       	std	Y+18, r24	; 0x12
    1632:	80 91 73 03 	lds	r24, 0x0373
    1636:	99 27       	eor	r25, r25
    1638:	83 70       	andi	r24, 0x03	; 3
    163a:	90 70       	andi	r25, 0x00	; 0
    163c:	89 2b       	or	r24, r25
    163e:	09 f4       	brne	.+2      	; 0x1642 <uip_process+0xba2>
    1640:	83 c1       	rjmp	.+774    	; 0x1948 <uip_process+0xea8>
    1642:	10 92 27 08 	sts	0x0827, r1
    1646:	10 92 26 08 	sts	0x0826, r1
    164a:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
    164e:	80 91 73 03 	lds	r24, 0x0373
    1652:	28 2f       	mov	r18, r24
    1654:	33 27       	eor	r19, r19
    1656:	c9 01       	movw	r24, r18
    1658:	80 72       	andi	r24, 0x20	; 32
    165a:	90 70       	andi	r25, 0x00	; 0
    165c:	25 ff       	sbrs	r18, 5
    165e:	07 c0       	rjmp	.+14     	; 0x166e <uip_process+0xbce>
    1660:	10 92 27 08 	sts	0x0827, r1
    1664:	10 92 26 08 	sts	0x0826, r1
    1668:	19 8e       	std	Y+25, r1	; 0x19
    166a:	84 e1       	ldi	r24, 0x14	; 20
    166c:	b9 c0       	rjmp	.+370    	; 0x17e0 <uip_process+0xd40>
    166e:	a9 01       	movw	r20, r18
    1670:	40 71       	andi	r20, 0x10	; 16
    1672:	50 70       	andi	r21, 0x00	; 0
    1674:	24 ff       	sbrs	r18, 4
    1676:	0d c0       	rjmp	.+26     	; 0x1692 <uip_process+0xbf2>
    1678:	90 93 27 08 	sts	0x0827, r25
    167c:	80 93 26 08 	sts	0x0826, r24
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	99 8b       	std	Y+17, r25	; 0x11
    1686:	88 8b       	std	Y+16, r24	; 0x10
    1688:	84 e0       	ldi	r24, 0x04	; 4
    168a:	89 8f       	std	Y+25, r24	; 0x19
    168c:	1b 8e       	std	Y+27, r1	; 0x1b
    168e:	81 e1       	ldi	r24, 0x11	; 17
    1690:	a7 c0       	rjmp	.+334    	; 0x17e0 <uip_process+0xd40>
    1692:	80 91 26 08 	lds	r24, 0x0826
    1696:	90 91 27 08 	lds	r25, 0x0827
    169a:	89 2b       	or	r24, r25
    169c:	01 f1       	breq	.+64     	; 0x16de <uip_process+0xc3e>
    169e:	20 ff       	sbrs	r18, 0
    16a0:	02 c0       	rjmp	.+4      	; 0x16a6 <uip_process+0xc06>
    16a2:	59 8b       	std	Y+17, r21	; 0x11
    16a4:	48 8b       	std	Y+16, r20	; 0x10
    16a6:	88 89       	ldd	r24, Y+16	; 0x10
    16a8:	99 89       	ldd	r25, Y+17	; 0x11
    16aa:	00 97       	sbiw	r24, 0x00	; 0
    16ac:	a1 f4       	brne	.+40     	; 0x16d6 <uip_process+0xc36>
    16ae:	80 91 26 08 	lds	r24, 0x0826
    16b2:	90 91 27 08 	lds	r25, 0x0827
    16b6:	2a 89       	ldd	r18, Y+18	; 0x12
    16b8:	3b 89       	ldd	r19, Y+19	; 0x13
    16ba:	28 17       	cp	r18, r24
    16bc:	39 07       	cpc	r19, r25
    16be:	20 f4       	brcc	.+8      	; 0x16c8 <uip_process+0xc28>
    16c0:	30 93 27 08 	sts	0x0827, r19
    16c4:	20 93 26 08 	sts	0x0826, r18
    16c8:	80 91 26 08 	lds	r24, 0x0826
    16cc:	90 91 27 08 	lds	r25, 0x0827
    16d0:	99 8b       	std	Y+17, r25	; 0x11
    16d2:	88 8b       	std	Y+16, r24	; 0x10
    16d4:	04 c0       	rjmp	.+8      	; 0x16de <uip_process+0xc3e>
    16d6:	90 93 27 08 	sts	0x0827, r25
    16da:	80 93 26 08 	sts	0x0826, r24
    16de:	1b 8e       	std	Y+27, r1	; 0x1b
    16e0:	80 91 6d 03 	lds	r24, 0x036D
    16e4:	90 91 6e 03 	lds	r25, 0x036E
    16e8:	90 93 75 03 	sts	0x0375, r25
    16ec:	80 93 74 03 	sts	0x0374, r24
    16f0:	80 91 26 08 	lds	r24, 0x0826
    16f4:	90 91 27 08 	lds	r25, 0x0827
    16f8:	89 2b       	or	r24, r25
    16fa:	59 f0       	breq	.+22     	; 0x1712 <uip_process+0xc72>
    16fc:	88 89       	ldd	r24, Y+16	; 0x10
    16fe:	99 89       	ldd	r25, Y+17	; 0x11
    1700:	00 97       	sbiw	r24, 0x00	; 0
    1702:	39 f0       	breq	.+14     	; 0x1712 <uip_process+0xc72>
    1704:	88 96       	adiw	r24, 0x28	; 40
    1706:	90 93 6c 03 	sts	0x036C, r25
    170a:	80 93 6b 03 	sts	0x036B, r24
    170e:	88 e1       	ldi	r24, 0x18	; 24
    1710:	0b c0       	rjmp	.+22     	; 0x1728 <uip_process+0xc88>
    1712:	80 91 73 03 	lds	r24, 0x0373
    1716:	81 ff       	sbrs	r24, 1
    1718:	17 c1       	rjmp	.+558    	; 0x1948 <uip_process+0xea8>
    171a:	88 e2       	ldi	r24, 0x28	; 40
    171c:	90 e0       	ldi	r25, 0x00	; 0
    171e:	90 93 6c 03 	sts	0x036C, r25
    1722:	80 93 6b 03 	sts	0x036B, r24
    1726:	80 e1       	ldi	r24, 0x10	; 16
    1728:	80 93 af 06 	sts	0x06AF, r24
    172c:	61 c0       	rjmp	.+194    	; 0x17f0 <uip_process+0xd50>
    172e:	80 91 73 03 	lds	r24, 0x0373
    1732:	80 ff       	sbrs	r24, 0
    1734:	09 c1       	rjmp	.+530    	; 0x1948 <uip_process+0xea8>
    1736:	19 8e       	std	Y+25, r1	; 0x19
    1738:	80 e1       	ldi	r24, 0x10	; 16
    173a:	80 93 73 03 	sts	0x0373, r24
    173e:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
    1742:	02 c1       	rjmp	.+516    	; 0x1948 <uip_process+0xea8>
    1744:	80 91 6b 03 	lds	r24, 0x036B
    1748:	90 91 6c 03 	lds	r25, 0x036C
    174c:	00 97       	sbiw	r24, 0x00	; 0
    174e:	11 f0       	breq	.+4      	; 0x1754 <uip_process+0xcb4>
    1750:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    1754:	80 91 af 06 	lds	r24, 0x06AF
    1758:	99 27       	eor	r25, r25
    175a:	40 91 73 03 	lds	r20, 0x0373
    175e:	9c 01       	movw	r18, r24
    1760:	21 70       	andi	r18, 0x01	; 1
    1762:	30 70       	andi	r19, 0x00	; 0
    1764:	80 ff       	sbrs	r24, 0
    1766:	0b c0       	rjmp	.+22     	; 0x177e <uip_process+0xcde>
    1768:	40 ff       	sbrs	r20, 0
    176a:	06 c0       	rjmp	.+12     	; 0x1778 <uip_process+0xcd8>
    176c:	87 e0       	ldi	r24, 0x07	; 7
    176e:	89 8f       	std	Y+25, r24	; 0x19
    1770:	1a 8e       	std	Y+26, r1	; 0x1a
    1772:	19 8a       	std	Y+17, r1	; 0x11
    1774:	18 8a       	std	Y+16, r1	; 0x10
    1776:	19 c0       	rjmp	.+50     	; 0x17aa <uip_process+0xd0a>
    1778:	86 e0       	ldi	r24, 0x06	; 6
    177a:	89 8f       	std	Y+25, r24	; 0x19
    177c:	16 c0       	rjmp	.+44     	; 0x17aa <uip_process+0xd0a>
    177e:	40 ff       	sbrs	r20, 0
    1780:	1e c0       	rjmp	.+60     	; 0x17be <uip_process+0xd1e>
    1782:	85 e0       	ldi	r24, 0x05	; 5
    1784:	89 8f       	std	Y+25, r24	; 0x19
    1786:	39 8b       	std	Y+17, r19	; 0x11
    1788:	28 8b       	std	Y+16, r18	; 0x10
    178a:	de c0       	rjmp	.+444    	; 0x1948 <uip_process+0xea8>
    178c:	80 91 6b 03 	lds	r24, 0x036B
    1790:	90 91 6c 03 	lds	r25, 0x036C
    1794:	00 97       	sbiw	r24, 0x00	; 0
    1796:	11 f0       	breq	.+4      	; 0x179c <uip_process+0xcfc>
    1798:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    179c:	80 91 af 06 	lds	r24, 0x06AF
    17a0:	80 ff       	sbrs	r24, 0
    17a2:	0d c0       	rjmp	.+26     	; 0x17be <uip_process+0xd1e>
    17a4:	87 e0       	ldi	r24, 0x07	; 7
    17a6:	89 8f       	std	Y+25, r24	; 0x19
    17a8:	1a 8e       	std	Y+26, r1	; 0x1a
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	90 e0       	ldi	r25, 0x00	; 0
    17ae:	0e 94 2a 05 	call	0xa54 <uip_add_rcv_nxt>
    17b2:	80 e1       	ldi	r24, 0x10	; 16
    17b4:	80 93 73 03 	sts	0x0373, r24
    17b8:	0e 94 cd 01 	call	0x39a <telnetd_appcall>
    17bc:	10 c0       	rjmp	.+32     	; 0x17de <uip_process+0xd3e>
    17be:	80 91 6b 03 	lds	r24, 0x036B
    17c2:	90 91 6c 03 	lds	r25, 0x036C
    17c6:	89 2b       	or	r24, r25
    17c8:	09 f4       	brne	.+2      	; 0x17cc <uip_process+0xd2c>
    17ca:	be c0       	rjmp	.+380    	; 0x1948 <uip_process+0xea8>
    17cc:	08 c0       	rjmp	.+16     	; 0x17de <uip_process+0xd3e>
    17ce:	80 91 73 03 	lds	r24, 0x0373
    17d2:	80 ff       	sbrs	r24, 0
    17d4:	b9 c0       	rjmp	.+370    	; 0x1948 <uip_process+0xea8>
    17d6:	87 e0       	ldi	r24, 0x07	; 7
    17d8:	89 8f       	std	Y+25, r24	; 0x19
    17da:	1a 8e       	std	Y+26, r1	; 0x1a
    17dc:	b5 c0       	rjmp	.+362    	; 0x1948 <uip_process+0xea8>
    17de:	80 e1       	ldi	r24, 0x10	; 16
    17e0:	80 93 af 06 	sts	0x06AF, r24
    17e4:	88 e2       	ldi	r24, 0x28	; 40
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	90 93 6c 03 	sts	0x036C, r25
    17ec:	80 93 6b 03 	sts	0x036B, r24
    17f0:	80 e5       	ldi	r24, 0x50	; 80
    17f2:	80 93 ae 06 	sts	0x06AE, r24
    17f6:	88 85       	ldd	r24, Y+8	; 0x08
    17f8:	80 93 aa 06 	sts	0x06AA, r24
    17fc:	89 85       	ldd	r24, Y+9	; 0x09
    17fe:	80 93 ab 06 	sts	0x06AB, r24
    1802:	8a 85       	ldd	r24, Y+10	; 0x0a
    1804:	80 93 ac 06 	sts	0x06AC, r24
    1808:	8b 85       	ldd	r24, Y+11	; 0x0b
    180a:	80 93 ad 06 	sts	0x06AD, r24
    180e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1810:	80 93 a6 06 	sts	0x06A6, r24
    1814:	8d 85       	ldd	r24, Y+13	; 0x0d
    1816:	80 93 a7 06 	sts	0x06A7, r24
    181a:	8e 85       	ldd	r24, Y+14	; 0x0e
    181c:	80 93 a8 06 	sts	0x06A8, r24
    1820:	8f 85       	ldd	r24, Y+15	; 0x0f
    1822:	80 93 a9 06 	sts	0x06A9, r24
    1826:	86 e0       	ldi	r24, 0x06	; 6
    1828:	80 93 97 06 	sts	0x0697, r24
    182c:	8c 81       	ldd	r24, Y+4	; 0x04
    182e:	9d 81       	ldd	r25, Y+5	; 0x05
    1830:	90 93 a3 06 	sts	0x06A3, r25
    1834:	80 93 a2 06 	sts	0x06A2, r24
    1838:	8e 81       	ldd	r24, Y+6	; 0x06
    183a:	9f 81       	ldd	r25, Y+7	; 0x07
    183c:	90 93 a5 06 	sts	0x06A5, r25
    1840:	80 93 a4 06 	sts	0x06A4, r24
    1844:	80 91 a5 01 	lds	r24, 0x01A5
    1848:	90 91 a6 01 	lds	r25, 0x01A6
    184c:	90 93 9b 06 	sts	0x069B, r25
    1850:	80 93 9a 06 	sts	0x069A, r24
    1854:	80 91 a7 01 	lds	r24, 0x01A7
    1858:	90 91 a8 01 	lds	r25, 0x01A8
    185c:	90 93 9d 06 	sts	0x069D, r25
    1860:	80 93 9c 06 	sts	0x069C, r24
    1864:	88 81       	ld	r24, Y
    1866:	99 81       	ldd	r25, Y+1	; 0x01
    1868:	90 93 9f 06 	sts	0x069F, r25
    186c:	80 93 9e 06 	sts	0x069E, r24
    1870:	8a 81       	ldd	r24, Y+2	; 0x02
    1872:	9b 81       	ldd	r25, Y+3	; 0x03
    1874:	90 93 a1 06 	sts	0x06A1, r25
    1878:	80 93 a0 06 	sts	0x06A0, r24
    187c:	89 8d       	ldd	r24, Y+25	; 0x19
    187e:	84 ff       	sbrs	r24, 4
    1880:	05 c0       	rjmp	.+10     	; 0x188c <uip_process+0xdec>
    1882:	10 92 b1 06 	sts	0x06B1, r1
    1886:	10 92 b0 06 	sts	0x06B0, r1
    188a:	06 c0       	rjmp	.+12     	; 0x1898 <uip_process+0xdf8>
    188c:	81 e0       	ldi	r24, 0x01	; 1
    188e:	80 93 b0 06 	sts	0x06B0, r24
    1892:	8e e6       	ldi	r24, 0x6E	; 110
    1894:	80 93 b1 06 	sts	0x06B1, r24
    1898:	8f e6       	ldi	r24, 0x6F	; 111
    189a:	80 93 96 06 	sts	0x0696, r24
    189e:	80 91 6b 03 	lds	r24, 0x036B
    18a2:	90 91 6c 03 	lds	r25, 0x036C
    18a6:	89 2f       	mov	r24, r25
    18a8:	99 27       	eor	r25, r25
    18aa:	80 93 90 06 	sts	0x0690, r24
    18ae:	80 91 6b 03 	lds	r24, 0x036B
    18b2:	80 93 91 06 	sts	0x0691, r24
    18b6:	10 92 b5 06 	sts	0x06B5, r1
    18ba:	10 92 b4 06 	sts	0x06B4, r1
    18be:	10 92 b3 06 	sts	0x06B3, r1
    18c2:	10 92 b2 06 	sts	0x06B2, r1
    18c6:	0e 94 36 04 	call	0x86c <uip_tcpchksum>
    18ca:	80 95       	com	r24
    18cc:	90 95       	com	r25
    18ce:	90 93 b3 06 	sts	0x06B3, r25
    18d2:	80 93 b2 06 	sts	0x06B2, r24
    18d6:	85 e4       	ldi	r24, 0x45	; 69
    18d8:	80 93 8e 06 	sts	0x068E, r24
    18dc:	10 92 8f 06 	sts	0x068F, r1
    18e0:	10 92 95 06 	sts	0x0695, r1
    18e4:	10 92 94 06 	sts	0x0694, r1
    18e8:	80 91 3e 03 	lds	r24, 0x033E
    18ec:	90 91 3f 03 	lds	r25, 0x033F
    18f0:	01 96       	adiw	r24, 0x01	; 1
    18f2:	90 93 3f 03 	sts	0x033F, r25
    18f6:	80 93 3e 03 	sts	0x033E, r24
    18fa:	89 2f       	mov	r24, r25
    18fc:	99 27       	eor	r25, r25
    18fe:	80 93 92 06 	sts	0x0692, r24
    1902:	80 91 3e 03 	lds	r24, 0x033E
    1906:	80 93 93 06 	sts	0x0693, r24
    190a:	10 92 99 06 	sts	0x0699, r1
    190e:	10 92 98 06 	sts	0x0698, r1
    1912:	0e 94 ff 03 	call	0x7fe <uip_ipchksum>
    1916:	80 95       	com	r24
    1918:	90 95       	com	r25
    191a:	90 93 99 06 	sts	0x0699, r25
    191e:	80 93 98 06 	sts	0x0698, r24
    1922:	80 91 72 06 	lds	r24, 0x0672
    1926:	90 91 73 06 	lds	r25, 0x0673
    192a:	01 96       	adiw	r24, 0x01	; 1
    192c:	90 93 73 06 	sts	0x0673, r25
    1930:	80 93 72 06 	sts	0x0672, r24
    1934:	80 91 58 06 	lds	r24, 0x0658
    1938:	90 91 59 06 	lds	r25, 0x0659
    193c:	01 96       	adiw	r24, 0x01	; 1
    193e:	90 93 59 06 	sts	0x0659, r25
    1942:	80 93 58 06 	sts	0x0658, r24
    1946:	04 c0       	rjmp	.+8      	; 0x1950 <uip_process+0xeb0>
    1948:	10 92 6c 03 	sts	0x036C, r1
    194c:	10 92 6b 03 	sts	0x036B, r1
    1950:	10 92 73 03 	sts	0x0373, r1
    1954:	df 91       	pop	r29
    1956:	cf 91       	pop	r28
    1958:	08 95       	ret

0000195a <uip_send>:
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    195a:	9c 01       	movw	r18, r24
    195c:	ab 01       	movw	r20, r22
  if(len > 0) {
    195e:	16 16       	cp	r1, r22
    1960:	17 06       	cpc	r1, r23
    1962:	74 f4       	brge	.+28     	; 0x1980 <uip_send+0x26>
    uip_slen = len;
    1964:	70 93 27 08 	sts	0x0827, r23
    1968:	60 93 26 08 	sts	0x0826, r22
    if(data != uip_sappdata) {
    196c:	80 91 6d 03 	lds	r24, 0x036D
    1970:	90 91 6e 03 	lds	r25, 0x036E
    1974:	28 17       	cp	r18, r24
    1976:	39 07       	cpc	r19, r25
    1978:	19 f0       	breq	.+6      	; 0x1980 <uip_send+0x26>
      memcpy(uip_sappdata, (data), uip_slen);
    197a:	b9 01       	movw	r22, r18
    197c:	0e 94 8d 16 	call	0x2d1a <memcpy>
    1980:	08 95       	ret

00001982 <timer_set>:
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    1982:	0f 93       	push	r16
    1984:	1f 93       	push	r17
    1986:	8c 01       	movw	r16, r24
  t->interval = interval;
    1988:	f8 01       	movw	r30, r16
    198a:	73 83       	std	Z+3, r23	; 0x03
    198c:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    198e:	0e 94 88 12 	call	0x2510 <clock_time>
    1992:	f8 01       	movw	r30, r16
    1994:	91 83       	std	Z+1, r25	; 0x01
    1996:	80 83       	st	Z, r24
    1998:	1f 91       	pop	r17
    199a:	0f 91       	pop	r16
    199c:	08 95       	ret

0000199e <timer_reset>:
}
/*---------------------------------------------------------------------------*/
/**
 * Reset the timer with the same interval.
 *
 * This function resets the timer with the same interval that was
 * given to the timer_set() function. The start point of the interval
 * is the exact time that the timer last expired. Therefore, this
 * function will cause the timer to be stable over time, unlike the
 * timer_rester() function.
 *
 * \param t A pointer to the timer.
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    199e:	fc 01       	movw	r30, r24
  t->start += t->interval;
    19a0:	80 81       	ld	r24, Z
    19a2:	91 81       	ldd	r25, Z+1	; 0x01
    19a4:	22 81       	ldd	r18, Z+2	; 0x02
    19a6:	33 81       	ldd	r19, Z+3	; 0x03
    19a8:	82 0f       	add	r24, r18
    19aa:	93 1f       	adc	r25, r19
    19ac:	91 83       	std	Z+1, r25	; 0x01
    19ae:	80 83       	st	Z, r24
    19b0:	08 95       	ret

000019b2 <timer_restart>:
}
/*---------------------------------------------------------------------------*/
/**
 * Restart the timer from the current point in time
 *
 * This function restarts a timer with the same interval that was
 * given to the timer_set() function. The timer will start at the
 * current time.
 *
 * \note A periodic timer will drift if this function is used to reset
 * it. For preioric timers, use the timer_reset() function instead.
 *
 * \param t A pointer to the timer.
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
    19b2:	0f 93       	push	r16
    19b4:	1f 93       	push	r17
    19b6:	8c 01       	movw	r16, r24
  t->start = clock_time();
    19b8:	0e 94 88 12 	call	0x2510 <clock_time>
    19bc:	f8 01       	movw	r30, r16
    19be:	91 83       	std	Z+1, r25	; 0x01
    19c0:	80 83       	st	Z, r24
    19c2:	1f 91       	pop	r17
    19c4:	0f 91       	pop	r16
    19c6:	08 95       	ret

000019c8 <timer_expired>:
}
/*---------------------------------------------------------------------------*/
/**
 * Check if a timer has expired.
 *
 * This function tests if a timer has expired and returns true or
 * false depending on its status.
 *
 * \param t A pointer to the timer
 *
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    19c8:	0f 93       	push	r16
    19ca:	1f 93       	push	r17
    19cc:	cf 93       	push	r28
    19ce:	df 93       	push	r29
    19d0:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    19d2:	c0 e0       	ldi	r28, 0x00	; 0
    19d4:	d0 e0       	ldi	r29, 0x00	; 0
    19d6:	0e 94 88 12 	call	0x2510 <clock_time>
    19da:	f8 01       	movw	r30, r16
    19dc:	20 81       	ld	r18, Z
    19de:	31 81       	ldd	r19, Z+1	; 0x01
    19e0:	82 1b       	sub	r24, r18
    19e2:	93 0b       	sbc	r25, r19
    19e4:	9c 01       	movw	r18, r24
    19e6:	82 81       	ldd	r24, Z+2	; 0x02
    19e8:	93 81       	ldd	r25, Z+3	; 0x03
    19ea:	28 17       	cp	r18, r24
    19ec:	39 07       	cpc	r19, r25
    19ee:	14 f0       	brlt	.+4      	; 0x19f4 <timer_expired+0x2c>
    19f0:	c1 e0       	ldi	r28, 0x01	; 1
    19f2:	d0 e0       	ldi	r29, 0x00	; 0
}
    19f4:	ce 01       	movw	r24, r28
    19f6:	df 91       	pop	r29
    19f8:	cf 91       	pop	r28
    19fa:	1f 91       	pop	r17
    19fc:	0f 91       	pop	r16
    19fe:	08 95       	ret

00001a00 <uip_arp_init>:
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1a00:	10 92 64 03 	sts	0x0364, r1
    1a04:	80 e0       	ldi	r24, 0x00	; 0
    1a06:	ea e4       	ldi	r30, 0x4A	; 74
    1a08:	f3 e0       	ldi	r31, 0x03	; 3
    memset(arp_table[i].ipaddr, 0, 4);
    1a0a:	10 82       	st	Z, r1
    1a0c:	11 82       	std	Z+1, r1	; 0x01
    1a0e:	12 82       	std	Z+2, r1	; 0x02
    1a10:	13 82       	std	Z+3, r1	; 0x03
    1a12:	3b 96       	adiw	r30, 0x0b	; 11
    1a14:	8f 5f       	subi	r24, 0xFF	; 255
    1a16:	82 30       	cpi	r24, 0x02	; 2
    1a18:	c0 f3       	brcs	.-16     	; 0x1a0a <uip_arp_init+0xa>
    1a1a:	82 e0       	ldi	r24, 0x02	; 2
    1a1c:	80 93 64 03 	sts	0x0364, r24
    1a20:	08 95       	ret

00001a22 <uip_arp_timer>:
  }
}
/*-----------------------------------------------------------------------------------*/
/**
 * Periodic ARP processing function.
 *
 * This function performs periodic timer processing in the ARP module
 * and should be called at regular intervals. The recommended interval
 * is 10 seconds between the calls.
 *
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr;
  
  ++arptime;
    1a22:	80 91 66 03 	lds	r24, 0x0366
    1a26:	8f 5f       	subi	r24, 0xFF	; 255
    1a28:	80 93 66 03 	sts	0x0366, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1a2c:	10 92 64 03 	sts	0x0364, r1
    1a30:	5b e0       	ldi	r21, 0x0B	; 11
    1a32:	68 2f       	mov	r22, r24
    1a34:	77 27       	eor	r23, r23
    1a36:	40 e0       	ldi	r20, 0x00	; 0
    tabptr = &arp_table[i];
    1a38:	45 9f       	mul	r20, r21
    1a3a:	f0 01       	movw	r30, r0
    1a3c:	11 24       	eor	r1, r1
    1a3e:	e6 5b       	subi	r30, 0xB6	; 182
    1a40:	fc 4f       	sbci	r31, 0xFC	; 252
    if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
    1a42:	80 81       	ld	r24, Z
    1a44:	91 81       	ldd	r25, Z+1	; 0x01
    1a46:	22 81       	ldd	r18, Z+2	; 0x02
    1a48:	33 81       	ldd	r19, Z+3	; 0x03
    1a4a:	82 2b       	or	r24, r18
    1a4c:	93 2b       	or	r25, r19
    1a4e:	89 2b       	or	r24, r25
    1a50:	59 f0       	breq	.+22     	; 0x1a68 <uip_arp_timer+0x46>
    1a52:	82 85       	ldd	r24, Z+10	; 0x0a
    1a54:	9b 01       	movw	r18, r22
    1a56:	28 1b       	sub	r18, r24
    1a58:	31 09       	sbc	r19, r1
    1a5a:	28 37       	cpi	r18, 0x78	; 120
    1a5c:	31 05       	cpc	r19, r1
    1a5e:	24 f0       	brlt	.+8      	; 0x1a68 <uip_arp_timer+0x46>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(tabptr->ipaddr, 0, 4);
    1a60:	10 82       	st	Z, r1
    1a62:	11 82       	std	Z+1, r1	; 0x01
    1a64:	12 82       	std	Z+2, r1	; 0x02
    1a66:	13 82       	std	Z+3, r1	; 0x03
    1a68:	84 2f       	mov	r24, r20
    1a6a:	8f 5f       	subi	r24, 0xFF	; 255
    1a6c:	48 2f       	mov	r20, r24
    1a6e:	82 30       	cpi	r24, 0x02	; 2
    1a70:	18 f3       	brcs	.-58     	; 0x1a38 <uip_arp_timer+0x16>
    1a72:	80 93 64 03 	sts	0x0364, r24
    1a76:	08 95       	ret

00001a78 <uip_arp_update>:
    }
  }

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    1a78:	ff 92       	push	r15
    1a7a:	0f 93       	push	r16
    1a7c:	1f 93       	push	r17
    1a7e:	cf 93       	push	r28
    1a80:	df 93       	push	r29
    1a82:	dc 01       	movw	r26, r24
    1a84:	8b 01       	movw	r16, r22
  register struct arp_entry *tabptr;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1a86:	10 92 64 03 	sts	0x0364, r1
    1a8a:	7b e0       	ldi	r23, 0x0B	; 11

    tabptr = &arp_table[i];
    1a8c:	60 91 64 03 	lds	r22, 0x0364
    1a90:	67 9f       	mul	r22, r23
    1a92:	e0 01       	movw	r28, r0
    1a94:	11 24       	eor	r1, r1
    1a96:	c6 5b       	subi	r28, 0xB6	; 182
    1a98:	dc 4f       	sbci	r29, 0xFC	; 252
    /* Only check those entries that are actually in use. */
    if(tabptr->ipaddr[0] != 0 &&
    1a9a:	28 81       	ld	r18, Y
    1a9c:	39 81       	ldd	r19, Y+1	; 0x01
    1a9e:	21 15       	cp	r18, r1
    1aa0:	31 05       	cpc	r19, r1
    1aa2:	d9 f0       	breq	.+54     	; 0x1ada <uip_arp_update+0x62>
    1aa4:	4a 81       	ldd	r20, Y+2	; 0x02
    1aa6:	5b 81       	ldd	r21, Y+3	; 0x03
    1aa8:	41 15       	cp	r20, r1
    1aaa:	51 05       	cpc	r21, r1
    1aac:	b1 f0       	breq	.+44     	; 0x1ada <uip_arp_update+0x62>
       tabptr->ipaddr[1] != 0) {

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(ipaddr[0] == tabptr->ipaddr[0] &&
    1aae:	8d 91       	ld	r24, X+
    1ab0:	9c 91       	ld	r25, X
    1ab2:	11 97       	sbiw	r26, 0x01	; 1
    1ab4:	82 17       	cp	r24, r18
    1ab6:	93 07       	cpc	r25, r19
    1ab8:	81 f4       	brne	.+32     	; 0x1ada <uip_arp_update+0x62>
    1aba:	fd 01       	movw	r30, r26
    1abc:	82 81       	ldd	r24, Z+2	; 0x02
    1abe:	93 81       	ldd	r25, Z+3	; 0x03
    1ac0:	84 17       	cp	r24, r20
    1ac2:	95 07       	cpc	r25, r21
    1ac4:	51 f4       	brne	.+20     	; 0x1ada <uip_arp_update+0x62>
	 ipaddr[1] == tabptr->ipaddr[1]) {
	 
	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    1ac6:	24 96       	adiw	r28, 0x04	; 4
    1ac8:	86 e0       	ldi	r24, 0x06	; 6
    1aca:	de 01       	movw	r26, r28
    1acc:	f8 01       	movw	r30, r16
    1ace:	01 90       	ld	r0, Z+
    1ad0:	0d 92       	st	X+, r0
    1ad2:	8a 95       	dec	r24
    1ad4:	e1 f7       	brne	.-8      	; 0x1ace <uip_arp_update+0x56>
    1ad6:	24 97       	sbiw	r28, 0x04	; 4
    1ad8:	65 c0       	rjmp	.+202    	; 0x1ba4 <uip_arp_update+0x12c>
    1ada:	86 2f       	mov	r24, r22
    1adc:	8f 5f       	subi	r24, 0xFF	; 255
    1ade:	80 93 64 03 	sts	0x0364, r24
    1ae2:	82 30       	cpi	r24, 0x02	; 2
    1ae4:	98 f2       	brcs	.-90     	; 0x1a8c <uip_arp_update+0x14>
	tabptr->time = arptime;

	return;
      }
    }
  }

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1ae6:	10 92 64 03 	sts	0x0364, r1
    1aea:	3b e0       	ldi	r19, 0x0B	; 11
    tabptr = &arp_table[i];
    1aec:	20 91 64 03 	lds	r18, 0x0364
    1af0:	23 9f       	mul	r18, r19
    1af2:	e0 01       	movw	r28, r0
    1af4:	11 24       	eor	r1, r1
    1af6:	c6 5b       	subi	r28, 0xB6	; 182
    1af8:	dc 4f       	sbci	r29, 0xFC	; 252
    if(tabptr->ipaddr[0] == 0 &&
    1afa:	88 81       	ld	r24, Y
    1afc:	99 81       	ldd	r25, Y+1	; 0x01
    1afe:	89 2b       	or	r24, r25
    1b00:	21 f4       	brne	.+8      	; 0x1b0a <uip_arp_update+0x92>
    1b02:	8a 81       	ldd	r24, Y+2	; 0x02
    1b04:	9b 81       	ldd	r25, Y+3	; 0x03
    1b06:	89 2b       	or	r24, r25
    1b08:	31 f0       	breq	.+12     	; 0x1b16 <uip_arp_update+0x9e>
    1b0a:	82 2f       	mov	r24, r18
    1b0c:	8f 5f       	subi	r24, 0xFF	; 255
    1b0e:	80 93 64 03 	sts	0x0364, r24
    1b12:	82 30       	cpi	r24, 0x02	; 2
    1b14:	58 f3       	brcs	.-42     	; 0x1aec <uip_arp_update+0x74>
       tabptr->ipaddr[1] == 0) {
      break;
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    1b16:	80 91 64 03 	lds	r24, 0x0364
    1b1a:	82 30       	cpi	r24, 0x02	; 2
    1b1c:	99 f5       	brne	.+102    	; 0x1b84 <uip_arp_update+0x10c>
    tmpage = 0;
    1b1e:	10 92 67 03 	sts	0x0367, r1
    c = 0;
    1b22:	10 92 65 03 	sts	0x0365, r1
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1b26:	10 92 64 03 	sts	0x0364, r1
    1b2a:	8b e0       	ldi	r24, 0x0B	; 11
    1b2c:	f8 2e       	mov	r15, r24
    1b2e:	c0 91 66 03 	lds	r28, 0x0366
    1b32:	6c 2f       	mov	r22, r28
    1b34:	77 27       	eor	r23, r23
      tabptr = &arp_table[i];
    1b36:	40 91 64 03 	lds	r20, 0x0364
    1b3a:	4f 9d       	mul	r20, r15
    1b3c:	f0 01       	movw	r30, r0
    1b3e:	11 24       	eor	r1, r1
    1b40:	e6 5b       	subi	r30, 0xB6	; 182
    1b42:	fc 4f       	sbci	r31, 0xFC	; 252
      if(arptime - tabptr->time > tmpage) {
    1b44:	52 85       	ldd	r21, Z+10	; 0x0a
    1b46:	9b 01       	movw	r18, r22
    1b48:	25 1b       	sub	r18, r21
    1b4a:	31 09       	sbc	r19, r1
    1b4c:	80 91 67 03 	lds	r24, 0x0367
    1b50:	99 27       	eor	r25, r25
    1b52:	82 17       	cp	r24, r18
    1b54:	93 07       	cpc	r25, r19
    1b56:	34 f4       	brge	.+12     	; 0x1b64 <uip_arp_update+0xec>
	tmpage = arptime - tabptr->time;
    1b58:	8c 2f       	mov	r24, r28
    1b5a:	85 1b       	sub	r24, r21
    1b5c:	80 93 67 03 	sts	0x0367, r24
	c = i;
    1b60:	40 93 65 03 	sts	0x0365, r20
    1b64:	84 2f       	mov	r24, r20
    1b66:	8f 5f       	subi	r24, 0xFF	; 255
    1b68:	80 93 64 03 	sts	0x0364, r24
    1b6c:	82 30       	cpi	r24, 0x02	; 2
    1b6e:	18 f3       	brcs	.-58     	; 0x1b36 <uip_arp_update+0xbe>
      }
    }
    i = c;
    1b70:	90 91 65 03 	lds	r25, 0x0365
    1b74:	90 93 64 03 	sts	0x0364, r25
    tabptr = &arp_table[i];
    1b78:	8b e0       	ldi	r24, 0x0B	; 11
    1b7a:	98 9f       	mul	r25, r24
    1b7c:	e0 01       	movw	r28, r0
    1b7e:	11 24       	eor	r1, r1
    1b80:	c6 5b       	subi	r28, 0xB6	; 182
    1b82:	dc 4f       	sbci	r29, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  memcpy(tabptr->ipaddr, ipaddr, 4);
    1b84:	8d 91       	ld	r24, X+
    1b86:	9d 91       	ld	r25, X+
    1b88:	0d 90       	ld	r0, X+
    1b8a:	bc 91       	ld	r27, X
    1b8c:	a0 2d       	mov	r26, r0
    1b8e:	fe 01       	movw	r30, r28
    1b90:	81 93       	st	Z+, r24
    1b92:	91 93       	st	Z+, r25
    1b94:	a1 93       	st	Z+, r26
    1b96:	b1 93       	st	Z+, r27
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    1b98:	86 e0       	ldi	r24, 0x06	; 6
    1b9a:	d8 01       	movw	r26, r16
    1b9c:	0d 90       	ld	r0, X+
    1b9e:	01 92       	st	Z+, r0
    1ba0:	8a 95       	dec	r24
    1ba2:	e1 f7       	brne	.-8      	; 0x1b9c <uip_arp_update+0x124>
  tabptr->time = arptime;
    1ba4:	80 91 66 03 	lds	r24, 0x0366
    1ba8:	8a 87       	std	Y+10, r24	; 0x0a
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	08 95       	ret

00001bb6 <uip_arp_arpin>:
}
/*-----------------------------------------------------------------------------------*/
/**
 * ARP processing for incoming IP packets
 *
 * This function should be called by the device driver when an IP
 * packet has been received. The function will check if the address is
 * in the ARP cache, and if so the ARP cache entry will be
 * refreshed. If no ARP cache entry was found, a new one is created.
 *
 * This function expects an IP packet with a prepended Ethernet header
 * in the uip_buf[] buffer, and the length of the packet in the global
 * variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
#if 0
void
uip_arp_ipin(void)
{
  uip_len -= sizeof(struct uip_eth_hdr);
	
  /* Only insert/update an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  if((IPBUF->srcipaddr[0] & uip_netmask[0]) !=
     (uip_hostaddr[0] & uip_netmask[0])) {
    return;
  }
  if((IPBUF->srcipaddr[1] & uip_netmask[1]) !=
     (uip_hostaddr[1] & uip_netmask[1])) {
    return;
  }
  uip_arp_update(IPBUF->srcipaddr, &(IPBUF->ethhdr.src));
  
  return;
}
#endif /* 0 */
/*-----------------------------------------------------------------------------------*/
/**
 * ARP processing for incoming ARP packets.
 *
 * This function should be called by the device driver when an ARP
 * packet has been received. The function will act differently
 * depending on the ARP packet type: if it is a reply for a request
 * that we previously sent out, the ARP cache will be filled in with
 * the values from the ARP reply. If the incoming ARP packet is an ARP
 * request for our IP address, an ARP reply packet is created and put
 * into the uip_buf[] buffer.
 *
 * When the function returns, the value of the global variable uip_len
 * indicates whether the device driver should send out a packet or
 * not. If uip_len is zero, no packet should be sent. If uip_len is
 * non-zero, it contains the length of the outbound packet that is
 * present in the uip_buf[] buffer.
 *
 * This function expects an ARP packet with a prepended Ethernet
 * header in the uip_buf[] buffer, and the length of the packet in the
 * global variable uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
  
  if(uip_len < sizeof(struct arp_hdr)) {
    1bba:	80 91 6b 03 	lds	r24, 0x036B
    1bbe:	90 91 6c 03 	lds	r25, 0x036C
    1bc2:	8a 97       	sbiw	r24, 0x2a	; 42
    1bc4:	28 f4       	brcc	.+10     	; 0x1bd0 <uip_arp_arpin+0x1a>
    uip_len = 0;
    1bc6:	10 92 6c 03 	sts	0x036C, r1
    1bca:	10 92 6b 03 	sts	0x036B, r1
    return;
    1bce:	a7 c0       	rjmp	.+334    	; 0x1d1e <uip_arp_arpin+0x168>
  }
  uip_len = 0;
    1bd0:	10 92 6c 03 	sts	0x036C, r1
    1bd4:	10 92 6b 03 	sts	0x036B, r1
  
  switch(BUF->opcode) {
    1bd8:	c0 e8       	ldi	r28, 0x80	; 128
    1bda:	d6 e0       	ldi	r29, 0x06	; 6
    1bdc:	80 91 94 06 	lds	r24, 0x0694
    1be0:	90 91 95 06 	lds	r25, 0x0695
    1be4:	21 e0       	ldi	r18, 0x01	; 1
    1be6:	80 30       	cpi	r24, 0x00	; 0
    1be8:	92 07       	cpc	r25, r18
    1bea:	29 f0       	breq	.+10     	; 0x1bf6 <uip_arp_arpin+0x40>
    1bec:	80 50       	subi	r24, 0x00	; 0
    1bee:	92 40       	sbci	r25, 0x02	; 2
    1bf0:	09 f4       	brne	.+2      	; 0x1bf4 <uip_arp_arpin+0x3e>
    1bf2:	78 c0       	rjmp	.+240    	; 0x1ce4 <uip_arp_arpin+0x12e>
    1bf4:	94 c0       	rjmp	.+296    	; 0x1d1e <uip_arp_arpin+0x168>
  case HTONS(ARP_REQUEST):
    /* ARP request. If it asked for our address, we send out a
       reply. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    1bf6:	20 91 a6 06 	lds	r18, 0x06A6
    1bfa:	30 91 a7 06 	lds	r19, 0x06A7
    1bfe:	80 91 a5 01 	lds	r24, 0x01A5
    1c02:	90 91 a6 01 	lds	r25, 0x01A6
    1c06:	28 17       	cp	r18, r24
    1c08:	39 07       	cpc	r19, r25
    1c0a:	09 f0       	breq	.+2      	; 0x1c0e <uip_arp_arpin+0x58>
    1c0c:	88 c0       	rjmp	.+272    	; 0x1d1e <uip_arp_arpin+0x168>
    1c0e:	20 91 a8 06 	lds	r18, 0x06A8
    1c12:	30 91 a9 06 	lds	r19, 0x06A9
    1c16:	80 91 a7 01 	lds	r24, 0x01A7
    1c1a:	90 91 a8 01 	lds	r25, 0x01A8
    1c1e:	28 17       	cp	r18, r24
    1c20:	39 07       	cpc	r19, r25
    1c22:	09 f0       	breq	.+2      	; 0x1c26 <uip_arp_arpin+0x70>
    1c24:	7c c0       	rjmp	.+248    	; 0x1d1e <uip_arp_arpin+0x168>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    1c26:	be 01       	movw	r22, r28
    1c28:	6a 5e       	subi	r22, 0xEA	; 234
    1c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	4c 96       	adiw	r24, 0x1c	; 28
    1c30:	0e 94 3c 0d 	call	0x1a78 <uip_arp_update>
      
      /* The reply opcode is 2. */
      BUF->opcode = HTONS(2);
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	92 e0       	ldi	r25, 0x02	; 2
    1c38:	90 93 95 06 	sts	0x0695, r25
    1c3c:	80 93 94 06 	sts	0x0694, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    1c40:	9e 01       	movw	r18, r28
    1c42:	20 5e       	subi	r18, 0xE0	; 224
    1c44:	3f 4f       	sbci	r19, 0xFF	; 255
    1c46:	ae 01       	movw	r20, r28
    1c48:	4a 5e       	subi	r20, 0xEA	; 234
    1c4a:	5f 4f       	sbci	r21, 0xFF	; 255
    1c4c:	86 e0       	ldi	r24, 0x06	; 6
    1c4e:	f9 01       	movw	r30, r18
    1c50:	da 01       	movw	r26, r20
    1c52:	98 2f       	mov	r25, r24
    1c54:	0d 90       	ld	r0, X+
    1c56:	01 92       	st	Z+, r0
    1c58:	9a 95       	dec	r25
    1c5a:	e1 f7       	brne	.-8      	; 0x1c54 <uip_arp_arpin+0x9e>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    1c5c:	67 e9       	ldi	r22, 0x97	; 151
    1c5e:	71 e0       	ldi	r23, 0x01	; 1
    1c60:	da 01       	movw	r26, r20
    1c62:	fb 01       	movw	r30, r22
    1c64:	98 2f       	mov	r25, r24
    1c66:	01 90       	ld	r0, Z+
    1c68:	0d 92       	st	X+, r0
    1c6a:	9a 95       	dec	r25
    1c6c:	e1 f7       	brne	.-8      	; 0x1c66 <uip_arp_arpin+0xb0>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    1c6e:	26 96       	adiw	r28, 0x06	; 6
    1c70:	de 01       	movw	r26, r28
    1c72:	fb 01       	movw	r30, r22
    1c74:	98 2f       	mov	r25, r24
    1c76:	01 90       	ld	r0, Z+
    1c78:	0d 92       	st	X+, r0
    1c7a:	9a 95       	dec	r25
    1c7c:	e1 f7       	brne	.-8      	; 0x1c76 <uip_arp_arpin+0xc0>
    1c7e:	26 97       	sbiw	r28, 0x06	; 6
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    1c80:	d9 01       	movw	r26, r18
    1c82:	0d 90       	ld	r0, X+
    1c84:	09 92       	st	Y+, r0
    1c86:	8a 95       	dec	r24
    1c88:	e1 f7       	brne	.-8      	; 0x1c82 <uip_arp_arpin+0xcc>
      
      BUF->dipaddr[0] = BUF->sipaddr[0];
    1c8a:	80 91 9c 06 	lds	r24, 0x069C
    1c8e:	90 91 9d 06 	lds	r25, 0x069D
    1c92:	90 93 a7 06 	sts	0x06A7, r25
    1c96:	80 93 a6 06 	sts	0x06A6, r24
      BUF->dipaddr[1] = BUF->sipaddr[1];
    1c9a:	80 91 9e 06 	lds	r24, 0x069E
    1c9e:	90 91 9f 06 	lds	r25, 0x069F
    1ca2:	90 93 a9 06 	sts	0x06A9, r25
    1ca6:	80 93 a8 06 	sts	0x06A8, r24
      BUF->sipaddr[0] = uip_hostaddr[0];
    1caa:	80 91 a5 01 	lds	r24, 0x01A5
    1cae:	90 91 a6 01 	lds	r25, 0x01A6
    1cb2:	90 93 9d 06 	sts	0x069D, r25
    1cb6:	80 93 9c 06 	sts	0x069C, r24
      BUF->sipaddr[1] = uip_hostaddr[1];
    1cba:	80 91 a7 01 	lds	r24, 0x01A7
    1cbe:	90 91 a8 01 	lds	r25, 0x01A8
    1cc2:	90 93 9f 06 	sts	0x069F, r25
    1cc6:	80 93 9e 06 	sts	0x069E, r24

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    1cca:	88 e0       	ldi	r24, 0x08	; 8
    1ccc:	96 e0       	ldi	r25, 0x06	; 6
    1cce:	90 93 8d 06 	sts	0x068D, r25
    1cd2:	80 93 8c 06 	sts	0x068C, r24
      uip_len = sizeof(struct arp_hdr);
    1cd6:	8a e2       	ldi	r24, 0x2A	; 42
    1cd8:	90 e0       	ldi	r25, 0x00	; 0
    1cda:	90 93 6c 03 	sts	0x036C, r25
    1cde:	80 93 6b 03 	sts	0x036B, r24
    }
    break;
    1ce2:	1d c0       	rjmp	.+58     	; 0x1d1e <uip_arp_arpin+0x168>
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
    1ce4:	20 91 a6 06 	lds	r18, 0x06A6
    1ce8:	30 91 a7 06 	lds	r19, 0x06A7
    1cec:	80 91 a5 01 	lds	r24, 0x01A5
    1cf0:	90 91 a6 01 	lds	r25, 0x01A6
    1cf4:	28 17       	cp	r18, r24
    1cf6:	39 07       	cpc	r19, r25
    1cf8:	91 f4       	brne	.+36     	; 0x1d1e <uip_arp_arpin+0x168>
    1cfa:	20 91 a8 06 	lds	r18, 0x06A8
    1cfe:	30 91 a9 06 	lds	r19, 0x06A9
    1d02:	80 91 a7 01 	lds	r24, 0x01A7
    1d06:	90 91 a8 01 	lds	r25, 0x01A8
    1d0a:	28 17       	cp	r18, r24
    1d0c:	39 07       	cpc	r19, r25
    1d0e:	39 f4       	brne	.+14     	; 0x1d1e <uip_arp_arpin+0x168>
      uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
    1d10:	be 01       	movw	r22, r28
    1d12:	6a 5e       	subi	r22, 0xEA	; 234
    1d14:	7f 4f       	sbci	r23, 0xFF	; 255
    1d16:	ce 01       	movw	r24, r28
    1d18:	4c 96       	adiw	r24, 0x1c	; 28
    1d1a:	0e 94 3c 0d 	call	0x1a78 <uip_arp_update>
    1d1e:	df 91       	pop	r29
    1d20:	cf 91       	pop	r28
    1d22:	08 95       	ret

00001d24 <uip_arp_out>:
    }
    break;
  }

  return;
}
/*-----------------------------------------------------------------------------------*/
/**
 * Prepend Ethernet header to an outbound IP packet and see if we need
 * to send out an ARP request.
 *
 * This function should be called before sending out an IP packet. The
 * function checks the destination IP address of the IP packet to see
 * what Ethernet MAC address that should be used as a destination MAC
 * address on the Ethernet.
 *
 * If the destination IP address is in the local network (determined
 * by logical ANDing of netmask and our IP address), the function
 * checks the ARP cache to see if an entry for the destination IP
 * address is found. If so, an Ethernet header is prepended and the
 * function returns. If no ARP cache entry is found for the
 * destination IP address, the packet in the uip_buf[] is replaced by
 * an ARP request packet for the IP address. The IP packet is dropped
 * and it is assumed that they higher level protocols (e.g., TCP)
 * eventually will retransmit the dropped packet.
 *
 * If the destination IP address is not on the local network, the IP
 * address of the default router is used instead.
 *
 * When the function returns, a packet is present in the uip_buf[]
 * buffer, and the length of the packet is in the global variable
 * uip_len.
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
    1d24:	cf 93       	push	r28
    1d26:	df 93       	push	r29
  struct arp_entry *tabptr;
  
  /* Find the destination IP address in the ARP table and construct
     the Ethernet header. If the destination IP addres isn't on the
     local network, we use the default router's IP address instead.

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
    1d28:	60 91 9e 06 	lds	r22, 0x069E
    1d2c:	70 91 9f 06 	lds	r23, 0x069F
    1d30:	80 91 b9 02 	lds	r24, 0x02B9
    1d34:	90 91 ba 02 	lds	r25, 0x02BA
    1d38:	68 17       	cp	r22, r24
    1d3a:	79 07       	cpc	r23, r25
    1d3c:	a9 f4       	brne	.+42     	; 0x1d68 <uip_arp_out+0x44>
    1d3e:	20 91 a0 06 	lds	r18, 0x06A0
    1d42:	30 91 a1 06 	lds	r19, 0x06A1
    1d46:	80 91 bb 02 	lds	r24, 0x02BB
    1d4a:	90 91 bc 02 	lds	r25, 0x02BC
    1d4e:	28 17       	cp	r18, r24
    1d50:	39 07       	cpc	r19, r25
    1d52:	51 f4       	brne	.+20     	; 0x1d68 <uip_arp_out+0x44>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    1d54:	86 e0       	ldi	r24, 0x06	; 6
    1d56:	a3 eb       	ldi	r26, 0xB3	; 179
    1d58:	b2 e0       	ldi	r27, 0x02	; 2
    1d5a:	e0 e8       	ldi	r30, 0x80	; 128
    1d5c:	f6 e0       	ldi	r31, 0x06	; 6
    1d5e:	0d 90       	ld	r0, X+
    1d60:	01 92       	st	Z+, r0
    1d62:	8a 95       	dec	r24
    1d64:	e1 f7       	brne	.-8      	; 0x1d5e <uip_arp_out+0x3a>
    1d66:	cb c0       	rjmp	.+406    	; 0x1efe <uip_arp_out+0x1da>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
    1d68:	80 91 9d 01 	lds	r24, 0x019D
    1d6c:	90 91 9e 01 	lds	r25, 0x019E
    1d70:	ab 01       	movw	r20, r22
    1d72:	48 23       	and	r20, r24
    1d74:	59 23       	and	r21, r25
    1d76:	20 91 a5 01 	lds	r18, 0x01A5
    1d7a:	30 91 a6 01 	lds	r19, 0x01A6
    1d7e:	28 23       	and	r18, r24
    1d80:	39 23       	and	r19, r25
    1d82:	42 17       	cp	r20, r18
    1d84:	53 07       	cpc	r21, r19
    1d86:	a1 f4       	brne	.+40     	; 0x1db0 <uip_arp_out+0x8c>
    1d88:	e0 91 a0 06 	lds	r30, 0x06A0
    1d8c:	f0 91 a1 06 	lds	r31, 0x06A1
    1d90:	80 91 9f 01 	lds	r24, 0x019F
    1d94:	90 91 a0 01 	lds	r25, 0x01A0
    1d98:	af 01       	movw	r20, r30
    1d9a:	48 23       	and	r20, r24
    1d9c:	59 23       	and	r21, r25
    1d9e:	20 91 a7 01 	lds	r18, 0x01A7
    1da2:	30 91 a8 01 	lds	r19, 0x01A8
    1da6:	28 23       	and	r18, r24
    1da8:	39 23       	and	r19, r25
    1daa:	42 17       	cp	r20, r18
    1dac:	53 07       	cpc	r21, r19
    1dae:	89 f0       	breq	.+34     	; 0x1dd2 <uip_arp_out+0xae>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(ipaddr, uip_draddr);
    1db0:	80 91 a1 01 	lds	r24, 0x01A1
    1db4:	90 91 a2 01 	lds	r25, 0x01A2
    1db8:	90 93 61 03 	sts	0x0361, r25
    1dbc:	80 93 60 03 	sts	0x0360, r24
    1dc0:	80 91 a3 01 	lds	r24, 0x01A3
    1dc4:	90 91 a4 01 	lds	r25, 0x01A4
    1dc8:	90 93 63 03 	sts	0x0363, r25
    1dcc:	80 93 62 03 	sts	0x0362, r24
    1dd0:	08 c0       	rjmp	.+16     	; 0x1de2 <uip_arp_out+0xbe>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
    1dd2:	70 93 61 03 	sts	0x0361, r23
    1dd6:	60 93 60 03 	sts	0x0360, r22
    1dda:	f0 93 63 03 	sts	0x0363, r31
    1dde:	e0 93 62 03 	sts	0x0362, r30
    }
      
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    1de2:	10 92 64 03 	sts	0x0364, r1
    1de6:	3b e0       	ldi	r19, 0x0B	; 11
    1de8:	60 91 60 03 	lds	r22, 0x0360
    1dec:	70 91 61 03 	lds	r23, 0x0361
    1df0:	40 91 62 03 	lds	r20, 0x0362
    1df4:	50 91 63 03 	lds	r21, 0x0363
    1df8:	20 e0       	ldi	r18, 0x00	; 0
      tabptr = &arp_table[i];
    1dfa:	23 9f       	mul	r18, r19
    1dfc:	f0 01       	movw	r30, r0
    1dfe:	11 24       	eor	r1, r1
    1e00:	e6 5b       	subi	r30, 0xB6	; 182
    1e02:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
    1e04:	80 81       	ld	r24, Z
    1e06:	91 81       	ldd	r25, Z+1	; 0x01
    1e08:	68 17       	cp	r22, r24
    1e0a:	79 07       	cpc	r23, r25
    1e0c:	29 f4       	brne	.+10     	; 0x1e18 <uip_arp_out+0xf4>
    1e0e:	82 81       	ldd	r24, Z+2	; 0x02
    1e10:	93 81       	ldd	r25, Z+3	; 0x03
    1e12:	48 17       	cp	r20, r24
    1e14:	59 07       	cpc	r21, r25
    1e16:	19 f0       	breq	.+6      	; 0x1e1e <uip_arp_out+0xfa>
    1e18:	2f 5f       	subi	r18, 0xFF	; 255
    1e1a:	22 30       	cpi	r18, 0x02	; 2
    1e1c:	70 f3       	brcs	.-36     	; 0x1dfa <uip_arp_out+0xd6>
    1e1e:	20 93 64 03 	sts	0x0364, r18
    1e22:	c0 e8       	ldi	r28, 0x80	; 128
    1e24:	d6 e0       	ldi	r29, 0x06	; 6
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    1e26:	22 30       	cpi	r18, 0x02	; 2
    1e28:	09 f0       	breq	.+2      	; 0x1e2c <uip_arp_out+0x108>
    1e2a:	63 c0       	rjmp	.+198    	; 0x1ef2 <uip_arp_out+0x1ce>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    1e2c:	46 e0       	ldi	r20, 0x06	; 6
    1e2e:	50 e0       	ldi	r21, 0x00	; 0
    1e30:	6f ef       	ldi	r22, 0xFF	; 255
    1e32:	70 e0       	ldi	r23, 0x00	; 0
    1e34:	ce 01       	movw	r24, r28
    1e36:	0e 94 9a 16 	call	0x2d34 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    1e3a:	a0 96       	adiw	r28, 0x20	; 32
    1e3c:	26 e0       	ldi	r18, 0x06	; 6
    1e3e:	de 01       	movw	r26, r28
    1e40:	e2 2f       	mov	r30, r18
    1e42:	1d 92       	st	X+, r1
    1e44:	ea 95       	dec	r30
    1e46:	e9 f7       	brne	.-6      	; 0x1e42 <uip_arp_out+0x11e>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    1e48:	6a 97       	sbiw	r28, 0x1a	; 26
    1e4a:	47 e9       	ldi	r20, 0x97	; 151
    1e4c:	51 e0       	ldi	r21, 0x01	; 1
    1e4e:	de 01       	movw	r26, r28
    1e50:	fa 01       	movw	r30, r20
    1e52:	82 2f       	mov	r24, r18
    1e54:	01 90       	ld	r0, Z+
    1e56:	0d 92       	st	X+, r0
    1e58:	8a 95       	dec	r24
    1e5a:	e1 f7       	brne	.-8      	; 0x1e54 <uip_arp_out+0x130>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    1e5c:	60 96       	adiw	r28, 0x10	; 16
    1e5e:	de 01       	movw	r26, r28
    1e60:	fa 01       	movw	r30, r20
    1e62:	82 2f       	mov	r24, r18
    1e64:	01 90       	ld	r0, Z+
    1e66:	0d 92       	st	X+, r0
    1e68:	8a 95       	dec	r24
    1e6a:	e1 f7       	brne	.-8      	; 0x1e64 <uip_arp_out+0x140>
    
      uip_ipaddr_copy(BUF->dipaddr, ipaddr);
    1e6c:	80 91 60 03 	lds	r24, 0x0360
    1e70:	90 91 61 03 	lds	r25, 0x0361
    1e74:	90 93 a7 06 	sts	0x06A7, r25
    1e78:	80 93 a6 06 	sts	0x06A6, r24
    1e7c:	80 91 62 03 	lds	r24, 0x0362
    1e80:	90 91 63 03 	lds	r25, 0x0363
    1e84:	90 93 a9 06 	sts	0x06A9, r25
    1e88:	80 93 a8 06 	sts	0x06A8, r24
      uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
    1e8c:	80 91 a5 01 	lds	r24, 0x01A5
    1e90:	90 91 a6 01 	lds	r25, 0x01A6
    1e94:	90 93 9d 06 	sts	0x069D, r25
    1e98:	80 93 9c 06 	sts	0x069C, r24
    1e9c:	80 91 a7 01 	lds	r24, 0x01A7
    1ea0:	90 91 a8 01 	lds	r25, 0x01A8
    1ea4:	90 93 9f 06 	sts	0x069F, r25
    1ea8:	80 93 9e 06 	sts	0x069E, r24
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    1eac:	80 e0       	ldi	r24, 0x00	; 0
    1eae:	91 e0       	ldi	r25, 0x01	; 1
    1eb0:	90 93 95 06 	sts	0x0695, r25
    1eb4:	80 93 94 06 	sts	0x0694, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    1eb8:	90 93 8f 06 	sts	0x068F, r25
    1ebc:	80 93 8e 06 	sts	0x068E, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    1ec0:	88 e0       	ldi	r24, 0x08	; 8
    1ec2:	90 e0       	ldi	r25, 0x00	; 0
    1ec4:	90 93 91 06 	sts	0x0691, r25
    1ec8:	80 93 90 06 	sts	0x0690, r24
      BUF->hwlen = 6;
    1ecc:	20 93 92 06 	sts	0x0692, r18
      BUF->protolen = 4;
    1ed0:	84 e0       	ldi	r24, 0x04	; 4
    1ed2:	80 93 93 06 	sts	0x0693, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    1ed6:	88 e0       	ldi	r24, 0x08	; 8
    1ed8:	96 e0       	ldi	r25, 0x06	; 6
    1eda:	90 93 8d 06 	sts	0x068D, r25
    1ede:	80 93 8c 06 	sts	0x068C, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    1ee2:	a0 96       	adiw	r28, 0x20	; 32
    1ee4:	d0 93 75 03 	sts	0x0375, r29
    1ee8:	c0 93 74 03 	sts	0x0374, r28
    
      uip_len = sizeof(struct arp_hdr);
    1eec:	8a e2       	ldi	r24, 0x2A	; 42
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	1a c0       	rjmp	.+52     	; 0x1f26 <uip_arp_out+0x202>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    1ef2:	34 96       	adiw	r30, 0x04	; 4
    1ef4:	86 e0       	ldi	r24, 0x06	; 6
    1ef6:	01 90       	ld	r0, Z+
    1ef8:	09 92       	st	Y+, r0
    1efa:	8a 95       	dec	r24
    1efc:	e1 f7       	brne	.-8      	; 0x1ef6 <uip_arp_out+0x1d2>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    1efe:	86 e0       	ldi	r24, 0x06	; 6
    1f00:	a7 e9       	ldi	r26, 0x97	; 151
    1f02:	b1 e0       	ldi	r27, 0x01	; 1
    1f04:	e6 e8       	ldi	r30, 0x86	; 134
    1f06:	f6 e0       	ldi	r31, 0x06	; 6
    1f08:	0d 90       	ld	r0, X+
    1f0a:	01 92       	st	Z+, r0
    1f0c:	8a 95       	dec	r24
    1f0e:	e1 f7       	brne	.-8      	; 0x1f08 <uip_arp_out+0x1e4>
  
  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    1f10:	88 e0       	ldi	r24, 0x08	; 8
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	90 93 8d 06 	sts	0x068D, r25
    1f18:	80 93 8c 06 	sts	0x068C, r24

  uip_len += sizeof(struct uip_eth_hdr);
    1f1c:	80 91 6b 03 	lds	r24, 0x036B
    1f20:	90 91 6c 03 	lds	r25, 0x036C
    1f24:	0e 96       	adiw	r24, 0x0e	; 14
    1f26:	90 93 6c 03 	sts	0x036C, r25
    1f2a:	80 93 6b 03 	sts	0x036B, r24
    1f2e:	df 91       	pop	r29
    1f30:	cf 91       	pop	r28
    1f32:	08 95       	ret

00001f34 <buf_setup>:
/*---------------------------------------------------------------------------*/
static void
buf_setup(struct psock_buf *buf,
	  u8_t *bufptr, u16_t bufsize)
{
    1f34:	fc 01       	movw	r30, r24
  buf->ptr = bufptr;
    1f36:	71 83       	std	Z+1, r23	; 0x01
    1f38:	60 83       	st	Z, r22
  buf->left = bufsize;
    1f3a:	53 83       	std	Z+3, r21	; 0x03
    1f3c:	42 83       	std	Z+2, r20	; 0x02
    1f3e:	08 95       	ret

00001f40 <send_data>:
}
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufdata(struct psock_buf *buf, u16_t len,
	    u8_t **dataptr, u16_t *datalen)
{
  if(*datalen < buf->left) {
    memcpy(buf->ptr, *dataptr, *datalen);
    buf->ptr += *datalen;
    buf->left -= *datalen;
    *dataptr += *datalen;
    *datalen = 0;
    return BUF_NOT_FULL;
  } else if(*datalen == buf->left) {
    memcpy(buf->ptr, *dataptr, *datalen);
    buf->ptr += *datalen;
    buf->left = 0;
    *dataptr += *datalen;
    *datalen = 0;
    return BUF_FULL;
  } else {
    memcpy(buf->ptr, *dataptr, buf->left);
    buf->ptr += buf->left;
    *datalen -= buf->left;
    *dataptr += buf->left;
    buf->left = 0;
    return BUF_FULL;
  }
}
/*---------------------------------------------------------------------------*/
static u8_t
buf_bufto(register struct psock_buf *buf, u8_t endmarker,
	  register u8_t **dataptr, register u16_t *datalen)
{
  u8_t c;
  while(buf->left > 0 && *datalen > 0) {
    c = *buf->ptr = **dataptr;
    ++*dataptr;
    ++buf->ptr;
    --*datalen;
    --buf->left;
    
    if(c == endmarker) {
      return BUF_FOUND;
    }
  }

  if(*datalen == 0) {
    return BUF_NOT_FOUND;
  }

  while(*datalen > 0) {
    c = **dataptr;
    --*datalen;
    ++*dataptr;
    
    if(c == endmarker) {
      return BUF_FOUND | BUF_FULL;
    }
  }
  
  return BUF_FULL;
}
/*---------------------------------------------------------------------------*/
static char
send_data(register struct psock *s)
{
    1f40:	cf 93       	push	r28
    1f42:	df 93       	push	r29
    1f44:	ec 01       	movw	r28, r24
  if(s->state != STATE_DATA_SENT || uip_rexmit()) {
    1f46:	8c 89       	ldd	r24, Y+20	; 0x14
    1f48:	86 30       	cpi	r24, 0x06	; 6
    1f4a:	41 f4       	brne	.+16     	; 0x1f5c <send_data+0x1c>
    1f4c:	80 91 73 03 	lds	r24, 0x0373
    1f50:	99 27       	eor	r25, r25
    1f52:	9c 01       	movw	r18, r24
    1f54:	24 70       	andi	r18, 0x04	; 4
    1f56:	30 70       	andi	r19, 0x00	; 0
    1f58:	82 ff       	sbrs	r24, 2
    1f5a:	15 c0       	rjmp	.+42     	; 0x1f86 <send_data+0x46>
    if(s->sendlen > uip_mss()) {
    1f5c:	e0 91 76 03 	lds	r30, 0x0376
    1f60:	f0 91 77 03 	lds	r31, 0x0377
    1f64:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f66:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f68:	62 89       	ldd	r22, Z+18	; 0x12
    1f6a:	73 89       	ldd	r23, Z+19	; 0x13
    1f6c:	68 17       	cp	r22, r24
    1f6e:	79 07       	cpc	r23, r25
    1f70:	08 f0       	brcs	.+2      	; 0x1f74 <send_data+0x34>
      uip_send(s->sendptr, uip_mss());
    } else {
      uip_send(s->sendptr, s->sendlen);
    1f72:	bc 01       	movw	r22, r24
    1f74:	8c 81       	ldd	r24, Y+4	; 0x04
    1f76:	9d 81       	ldd	r25, Y+5	; 0x05
    1f78:	0e 94 ad 0c 	call	0x195a <uip_send>
    }
    s->state = STATE_DATA_SENT;
    1f7c:	86 e0       	ldi	r24, 0x06	; 6
    1f7e:	8c 8b       	std	Y+20, r24	; 0x14
    return 1;
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	90 e0       	ldi	r25, 0x00	; 0
    1f84:	01 c0       	rjmp	.+2      	; 0x1f88 <send_data+0x48>
  }
  return 0;
    1f86:	c9 01       	movw	r24, r18
    1f88:	df 91       	pop	r29
    1f8a:	cf 91       	pop	r28
    1f8c:	08 95       	ret

00001f8e <data_acked>:
}
/*---------------------------------------------------------------------------*/
static char
data_acked(register struct psock *s)
{
    1f8e:	cf 93       	push	r28
    1f90:	df 93       	push	r29
    1f92:	fc 01       	movw	r30, r24
  if(s->state == STATE_DATA_SENT && uip_acked()) {
    1f94:	84 89       	ldd	r24, Z+20	; 0x14
    1f96:	86 30       	cpi	r24, 0x06	; 6
    1f98:	41 f5       	brne	.+80     	; 0x1fea <data_acked+0x5c>
    1f9a:	80 91 73 03 	lds	r24, 0x0373
    1f9e:	80 ff       	sbrs	r24, 0
    1fa0:	24 c0       	rjmp	.+72     	; 0x1fea <data_acked+0x5c>
    if(s->sendlen > uip_mss()) {
    1fa2:	a0 91 76 03 	lds	r26, 0x0376
    1fa6:	b0 91 77 03 	lds	r27, 0x0377
    1faa:	82 85       	ldd	r24, Z+10	; 0x0a
    1fac:	93 85       	ldd	r25, Z+11	; 0x0b
    1fae:	ed 01       	movw	r28, r26
    1fb0:	4a 89       	ldd	r20, Y+18	; 0x12
    1fb2:	5b 89       	ldd	r21, Y+19	; 0x13
    1fb4:	24 81       	ldd	r18, Z+4	; 0x04
    1fb6:	35 81       	ldd	r19, Z+5	; 0x05
    1fb8:	48 17       	cp	r20, r24
    1fba:	59 07       	cpc	r21, r25
    1fbc:	58 f4       	brcc	.+22     	; 0x1fd4 <data_acked+0x46>
      s->sendlen -= uip_mss();
    1fbe:	84 1b       	sub	r24, r20
    1fc0:	95 0b       	sbc	r25, r21
    1fc2:	93 87       	std	Z+11, r25	; 0x0b
    1fc4:	82 87       	std	Z+10, r24	; 0x0a
      s->sendptr += uip_mss();
    1fc6:	8a 89       	ldd	r24, Y+18	; 0x12
    1fc8:	9b 89       	ldd	r25, Y+19	; 0x13
    1fca:	28 0f       	add	r18, r24
    1fcc:	39 1f       	adc	r19, r25
    1fce:	35 83       	std	Z+5, r19	; 0x05
    1fd0:	24 83       	std	Z+4, r18	; 0x04
    1fd2:	06 c0       	rjmp	.+12     	; 0x1fe0 <data_acked+0x52>
    } else {
      s->sendptr += s->sendlen;
    1fd4:	28 0f       	add	r18, r24
    1fd6:	39 1f       	adc	r19, r25
    1fd8:	35 83       	std	Z+5, r19	; 0x05
    1fda:	24 83       	std	Z+4, r18	; 0x04
      s->sendlen = 0;
    1fdc:	13 86       	std	Z+11, r1	; 0x0b
    1fde:	12 86       	std	Z+10, r1	; 0x0a
    }
    s->state = STATE_ACKED;
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	84 8b       	std	Z+20, r24	; 0x14
    return 1;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <data_acked+0x60>
  }
  return 0;
    1fea:	80 e0       	ldi	r24, 0x00	; 0
    1fec:	90 e0       	ldi	r25, 0x00	; 0
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	08 95       	ret

00001ff4 <psock_send>:
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_send(register struct psock *s, const char *buf,
		     unsigned int len))
{
    1ff4:	1f 93       	push	r17
    1ff6:	cf 93       	push	r28
    1ff8:	df 93       	push	r29
    1ffa:	ec 01       	movw	r28, r24
  PT_BEGIN(&s->psockpt);
    1ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffe:	9b 81       	ldd	r25, Y+3	; 0x03
    2000:	00 97       	sbiw	r24, 0x00	; 0
    2002:	21 f0       	breq	.+8      	; 0x200c <psock_send+0x18>
    2004:	8f 3c       	cpi	r24, 0xCF	; 207
    2006:	91 05       	cpc	r25, r1
    2008:	a9 f0       	breq	.+42     	; 0x2034 <psock_send+0x40>
    200a:	22 c0       	rjmp	.+68     	; 0x2050 <psock_send+0x5c>

  /* If there is no data to send, we exit immediately. */
  if(len == 0) {
    200c:	41 15       	cp	r20, r1
    200e:	51 05       	cpc	r21, r1
    2010:	41 f4       	brne	.+16     	; 0x2022 <psock_send+0x2e>
    PT_EXIT(&s->psockpt);
    2012:	5b 83       	std	Y+3, r21	; 0x03
    2014:	4a 83       	std	Y+2, r20	; 0x02
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	1e c0       	rjmp	.+60     	; 0x2058 <psock_send+0x64>
  }

  /* Save the length of and a pointer to the data that is to be
     sent. */
  s->sendptr = buf;
  s->sendlen = len;

  s->state = STATE_NONE;

  /* We loop here until all data is sent. The s->sendlen variable is
     updated by the data_sent() function. */
  while(s->sendlen > 0) {

    /*
     * The condition for this PT_WAIT_UNTIL is a little tricky: the
     * protothread will wait here until all data has been acknowledged
     * (data_acked() returns true) and until all data has been sent
     * (send_data() returns true). The two functions data_acked() and
     * send_data() must be called in succession to ensure that all
     * data is sent. Therefore the & operator is used instead of the
     * && operator, which would cause only the data_acked() function
     * to be called when it returns false.
     */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    201c:	80 e0       	ldi	r24, 0x00	; 0
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	1b c0       	rjmp	.+54     	; 0x2058 <psock_send+0x64>
    2022:	7d 83       	std	Y+5, r23	; 0x05
    2024:	6c 83       	std	Y+4, r22	; 0x04
    2026:	5b 87       	std	Y+11, r21	; 0x0b
    2028:	4a 87       	std	Y+10, r20	; 0x0a
    202a:	1c 8a       	std	Y+20, r1	; 0x14
    202c:	8f ec       	ldi	r24, 0xCF	; 207
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	9b 83       	std	Y+3, r25	; 0x03
    2032:	8a 83       	std	Y+2, r24	; 0x02
    2034:	ce 01       	movw	r24, r28
    2036:	0e 94 c7 0f 	call	0x1f8e <data_acked>
    203a:	18 2f       	mov	r17, r24
    203c:	ce 01       	movw	r24, r28
    203e:	0e 94 a0 0f 	call	0x1f40 <send_data>
    2042:	18 23       	and	r17, r24
    2044:	59 f3       	breq	.-42     	; 0x201c <psock_send+0x28>
    2046:	8a 85       	ldd	r24, Y+10	; 0x0a
    2048:	9b 85       	ldd	r25, Y+11	; 0x0b
    204a:	89 2b       	or	r24, r25
    204c:	79 f7       	brne	.-34     	; 0x202c <psock_send+0x38>
  }

  s->state = STATE_NONE;
    204e:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    2050:	1b 82       	std	Y+3, r1	; 0x03
    2052:	1a 82       	std	Y+2, r1	; 0x02
    2054:	82 e0       	ldi	r24, 0x02	; 2
    2056:	90 e0       	ldi	r25, 0x00	; 0
    2058:	df 91       	pop	r29
    205a:	cf 91       	pop	r28
    205c:	1f 91       	pop	r17
    205e:	08 95       	ret

00002060 <psock_generator_send>:
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_generator_send(register struct psock *s,
			       unsigned short (*generate)(void *), void *arg))
{
    2060:	cf 92       	push	r12
    2062:	df 92       	push	r13
    2064:	ef 92       	push	r14
    2066:	ff 92       	push	r15
    2068:	1f 93       	push	r17
    206a:	cf 93       	push	r28
    206c:	df 93       	push	r29
    206e:	ec 01       	movw	r28, r24
    2070:	7b 01       	movw	r14, r22
    2072:	6a 01       	movw	r12, r20
  PT_BEGIN(&s->psockpt);
    2074:	8a 81       	ldd	r24, Y+2	; 0x02
    2076:	9b 81       	ldd	r25, Y+3	; 0x03
    2078:	00 97       	sbiw	r24, 0x00	; 0
    207a:	21 f0       	breq	.+8      	; 0x2084 <psock_generator_send+0x24>
    207c:	8e 3e       	cpi	r24, 0xEE	; 238
    207e:	91 05       	cpc	r25, r1
    2080:	19 f1       	breq	.+70     	; 0x20c8 <psock_generator_send+0x68>
    2082:	30 c0       	rjmp	.+96     	; 0x20e4 <psock_generator_send+0x84>

  /* Ensure that there is a generator function to call. */
  if(generate == NULL) {
    2084:	61 15       	cp	r22, r1
    2086:	71 05       	cpc	r23, r1
    2088:	41 f4       	brne	.+16     	; 0x209a <psock_generator_send+0x3a>
    PT_EXIT(&s->psockpt);
    208a:	7b 83       	std	Y+3, r23	; 0x03
    208c:	6a 83       	std	Y+2, r22	; 0x02
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	2c c0       	rjmp	.+88     	; 0x20ec <psock_generator_send+0x8c>
  }

  /* Call the generator function to generate the data in the
     uip_appdata buffer. */
  s->sendlen = generate(arg);
  s->sendptr = uip_appdata;

  s->state = STATE_NONE;  
  do {
    /* Call the generator function again if we are called to perform a
       retransmission. */
    if(uip_rexmit()) {
      generate(arg);
    }
    /* Wait until all data is sent and acknowledged. */
    PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
    2094:	80 e0       	ldi	r24, 0x00	; 0
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	29 c0       	rjmp	.+82     	; 0x20ec <psock_generator_send+0x8c>
    209a:	ca 01       	movw	r24, r20
    209c:	fb 01       	movw	r30, r22
    209e:	09 95       	icall
    20a0:	9b 87       	std	Y+11, r25	; 0x0b
    20a2:	8a 87       	std	Y+10, r24	; 0x0a
    20a4:	80 91 74 03 	lds	r24, 0x0374
    20a8:	90 91 75 03 	lds	r25, 0x0375
    20ac:	9d 83       	std	Y+5, r25	; 0x05
    20ae:	8c 83       	std	Y+4, r24	; 0x04
    20b0:	1c 8a       	std	Y+20, r1	; 0x14
    20b2:	80 91 73 03 	lds	r24, 0x0373
    20b6:	82 ff       	sbrs	r24, 2
    20b8:	03 c0       	rjmp	.+6      	; 0x20c0 <psock_generator_send+0x60>
    20ba:	c6 01       	movw	r24, r12
    20bc:	f7 01       	movw	r30, r14
    20be:	09 95       	icall
    20c0:	8e ee       	ldi	r24, 0xEE	; 238
    20c2:	90 e0       	ldi	r25, 0x00	; 0
    20c4:	9b 83       	std	Y+3, r25	; 0x03
    20c6:	8a 83       	std	Y+2, r24	; 0x02
    20c8:	ce 01       	movw	r24, r28
    20ca:	0e 94 c7 0f 	call	0x1f8e <data_acked>
    20ce:	18 2f       	mov	r17, r24
    20d0:	ce 01       	movw	r24, r28
    20d2:	0e 94 a0 0f 	call	0x1f40 <send_data>
    20d6:	18 23       	and	r17, r24
    20d8:	e9 f2       	breq	.-70     	; 0x2094 <psock_generator_send+0x34>
  } while(s->sendlen > 0);
    20da:	8a 85       	ldd	r24, Y+10	; 0x0a
    20dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    20de:	89 2b       	or	r24, r25
    20e0:	41 f7       	brne	.-48     	; 0x20b2 <psock_generator_send+0x52>
  
  s->state = STATE_NONE;
    20e2:	1c 8a       	std	Y+20, r1	; 0x14
  
  PT_END(&s->psockpt);
    20e4:	1b 82       	std	Y+3, r1	; 0x03
    20e6:	1a 82       	std	Y+2, r1	; 0x02
    20e8:	82 e0       	ldi	r24, 0x02	; 2
    20ea:	90 e0       	ldi	r25, 0x00	; 0
    20ec:	df 91       	pop	r29
    20ee:	cf 91       	pop	r28
    20f0:	1f 91       	pop	r17
    20f2:	ff 90       	pop	r15
    20f4:	ef 90       	pop	r14
    20f6:	df 90       	pop	r13
    20f8:	cf 90       	pop	r12
    20fa:	08 95       	ret

000020fc <psock_datalen>:
}
/*---------------------------------------------------------------------------*/
u16_t
psock_datalen(struct psock *psock)
{
    20fc:	fc 01       	movw	r30, r24
  return psock->bufsize - psock->buf.left;
    20fe:	22 89       	ldd	r18, Z+18	; 0x12
    2100:	33 89       	ldd	r19, Z+19	; 0x13
    2102:	80 89       	ldd	r24, Z+16	; 0x10
    2104:	91 89       	ldd	r25, Z+17	; 0x11
}
    2106:	28 1b       	sub	r18, r24
    2108:	39 0b       	sbc	r19, r25
    210a:	c9 01       	movw	r24, r18
    210c:	08 95       	ret

0000210e <psock_newdata>:
/*---------------------------------------------------------------------------*/
char
psock_newdata(struct psock *s)
{
    210e:	fc 01       	movw	r30, r24
  if(s->readlen > 0) {
    2110:	24 85       	ldd	r18, Z+12	; 0x0c
    2112:	35 85       	ldd	r19, Z+13	; 0x0d
    2114:	21 15       	cp	r18, r1
    2116:	31 05       	cpc	r19, r1
    2118:	79 f4       	brne	.+30     	; 0x2138 <psock_newdata+0x2a>
    /* There is data in the uip_appdata buffer that has not yet been
       read with the PSOCK_READ functions. */
    return 1;
  } else if(s->state == STATE_READ) {
    211a:	84 89       	ldd	r24, Z+20	; 0x14
    211c:	82 30       	cpi	r24, 0x02	; 2
    211e:	21 f4       	brne	.+8      	; 0x2128 <psock_newdata+0x1a>
    /* All data in uip_appdata buffer already consumed. */
    s->state = STATE_BLOCKED_NEWDATA;
    2120:	83 e0       	ldi	r24, 0x03	; 3
    2122:	84 8b       	std	Z+20, r24	; 0x14
    return 0;
    2124:	c9 01       	movw	r24, r18
    2126:	08 95       	ret
  } else if(uip_newdata()) {
    2128:	80 91 73 03 	lds	r24, 0x0373
    212c:	99 27       	eor	r25, r25
    212e:	9c 01       	movw	r18, r24
    2130:	22 70       	andi	r18, 0x02	; 2
    2132:	30 70       	andi	r19, 0x00	; 0
    2134:	81 ff       	sbrs	r24, 1
    2136:	03 c0       	rjmp	.+6      	; 0x213e <psock_newdata+0x30>
    /* There is new data that has not been consumed. */
    return 1;
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	08 95       	ret
  } else {
    /* There is no new data. */
    return 0;
    213e:	c9 01       	movw	r24, r18
  }
}
    2140:	08 95       	ret

00002142 <psock_readto>:
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
{
    2142:	df 92       	push	r13
    2144:	ef 92       	push	r14
    2146:	ff 92       	push	r15
    2148:	0f 93       	push	r16
    214a:	1f 93       	push	r17
    214c:	cf 93       	push	r28
    214e:	df 93       	push	r29
    2150:	ec 01       	movw	r28, r24
    2152:	d6 2e       	mov	r13, r22
  PT_BEGIN(&psock->psockpt);
    2154:	8a 81       	ldd	r24, Y+2	; 0x02
    2156:	9b 81       	ldd	r25, Y+3	; 0x03
    2158:	00 97       	sbiw	r24, 0x00	; 0
    215a:	21 f0       	breq	.+8      	; 0x2164 <psock_readto+0x22>
    215c:	8b 51       	subi	r24, 0x1B	; 27
    215e:	91 40       	sbci	r25, 0x01	; 1
    2160:	89 f0       	breq	.+34     	; 0x2184 <psock_readto+0x42>
    2162:	90 c0       	rjmp	.+288    	; 0x2284 <psock_readto+0x142>

  buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
    2164:	4a 89       	ldd	r20, Y+18	; 0x12
    2166:	5b 89       	ldd	r21, Y+19	; 0x13
    2168:	68 85       	ldd	r22, Y+8	; 0x08
    216a:	79 85       	ldd	r23, Y+9	; 0x09
    216c:	ce 01       	movw	r24, r28
    216e:	0e 96       	adiw	r24, 0x0e	; 14
    2170:	0e 94 9a 0f 	call	0x1f34 <buf_setup>
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    2174:	8c 85       	ldd	r24, Y+12	; 0x0c
    2176:	9d 85       	ldd	r25, Y+13	; 0x0d
    2178:	89 2b       	or	r24, r25
    217a:	c1 f4       	brne	.+48     	; 0x21ac <psock_readto+0x6a>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    217c:	8b e1       	ldi	r24, 0x1B	; 27
    217e:	91 e0       	ldi	r25, 0x01	; 1
    2180:	9b 83       	std	Y+3, r25	; 0x03
    2182:	8a 83       	std	Y+2, r24	; 0x02
    2184:	ce 01       	movw	r24, r28
    2186:	0e 94 87 10 	call	0x210e <psock_newdata>
    218a:	88 23       	and	r24, r24
    218c:	09 f4       	brne	.+2      	; 0x2190 <psock_readto+0x4e>
    218e:	77 c0       	rjmp	.+238    	; 0x227e <psock_readto+0x13c>
      psock->state = STATE_READ;
    2190:	82 e0       	ldi	r24, 0x02	; 2
    2192:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    2194:	80 91 74 03 	lds	r24, 0x0374
    2198:	90 91 75 03 	lds	r25, 0x0375
    219c:	9f 83       	std	Y+7, r25	; 0x07
    219e:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    21a0:	80 91 6b 03 	lds	r24, 0x036B
    21a4:	90 91 6c 03 	lds	r25, 0x036C
    21a8:	9d 87       	std	Y+13, r25	; 0x0d
    21aa:	8c 87       	std	Y+12, r24	; 0x0c
    21ac:	be 01       	movw	r22, r28
    21ae:	62 5f       	subi	r22, 0xF2	; 242
    21b0:	7f 4f       	sbci	r23, 0xFF	; 255
    21b2:	86 e0       	ldi	r24, 0x06	; 6
    21b4:	e8 2e       	mov	r14, r24
    21b6:	f1 2c       	mov	r15, r1
    21b8:	ec 0e       	add	r14, r28
    21ba:	fd 1e       	adc	r15, r29
    21bc:	8e 01       	movw	r16, r28
    21be:	04 5f       	subi	r16, 0xF4	; 244
    21c0:	1f 4f       	sbci	r17, 0xFF	; 255
    21c2:	fb 01       	movw	r30, r22
    21c4:	82 81       	ldd	r24, Z+2	; 0x02
    21c6:	93 81       	ldd	r25, Z+3	; 0x03
    21c8:	89 2b       	or	r24, r25
    21ca:	69 f1       	breq	.+90     	; 0x2226 <psock_readto+0xe4>
    21cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    21ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    21d0:	89 2b       	or	r24, r25
    21d2:	49 f1       	breq	.+82     	; 0x2226 <psock_readto+0xe4>
    21d4:	fb 01       	movw	r30, r22
    21d6:	a0 81       	ld	r26, Z
    21d8:	b1 81       	ldd	r27, Z+1	; 0x01
    21da:	f7 01       	movw	r30, r14
    21dc:	80 81       	ld	r24, Z
    21de:	91 81       	ldd	r25, Z+1	; 0x01
    21e0:	fc 01       	movw	r30, r24
    21e2:	20 81       	ld	r18, Z
    21e4:	2c 93       	st	X, r18
    21e6:	d7 01       	movw	r26, r14
    21e8:	8d 91       	ld	r24, X+
    21ea:	9c 91       	ld	r25, X
    21ec:	11 97       	sbiw	r26, 0x01	; 1
    21ee:	01 96       	adiw	r24, 0x01	; 1
    21f0:	8d 93       	st	X+, r24
    21f2:	9c 93       	st	X, r25
    21f4:	fb 01       	movw	r30, r22
    21f6:	80 81       	ld	r24, Z
    21f8:	91 81       	ldd	r25, Z+1	; 0x01
    21fa:	01 96       	adiw	r24, 0x01	; 1
    21fc:	91 83       	std	Z+1, r25	; 0x01
    21fe:	80 83       	st	Z, r24
    2200:	d8 01       	movw	r26, r16
    2202:	4d 91       	ld	r20, X+
    2204:	5c 91       	ld	r21, X
    2206:	11 97       	sbiw	r26, 0x01	; 1
    2208:	41 50       	subi	r20, 0x01	; 1
    220a:	50 40       	sbci	r21, 0x00	; 0
    220c:	4d 93       	st	X+, r20
    220e:	5c 93       	st	X, r21
    2210:	82 81       	ldd	r24, Z+2	; 0x02
    2212:	93 81       	ldd	r25, Z+3	; 0x03
    2214:	01 97       	sbiw	r24, 0x01	; 1
    2216:	93 83       	std	Z+3, r25	; 0x03
    2218:	82 83       	std	Z+2, r24	; 0x02
    221a:	2d 15       	cp	r18, r13
    221c:	51 f0       	breq	.+20     	; 0x2232 <psock_readto+0xf0>
    221e:	89 2b       	or	r24, r25
    2220:	11 f0       	breq	.+4      	; 0x2226 <psock_readto+0xe4>
    2222:	45 2b       	or	r20, r21
    2224:	b9 f6       	brne	.-82     	; 0x21d4 <psock_readto+0x92>
    2226:	f8 01       	movw	r30, r16
    2228:	80 81       	ld	r24, Z
    222a:	91 81       	ldd	r25, Z+1	; 0x01
    222c:	00 97       	sbiw	r24, 0x00	; 0
    222e:	39 f4       	brne	.+14     	; 0x223e <psock_readto+0xfc>
    2230:	1b c0       	rjmp	.+54     	; 0x2268 <psock_readto+0x126>
    2232:	82 e0       	ldi	r24, 0x02	; 2
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	18 c0       	rjmp	.+48     	; 0x2268 <psock_readto+0x126>
    2238:	83 e0       	ldi	r24, 0x03	; 3
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	15 c0       	rjmp	.+42     	; 0x2268 <psock_readto+0x126>
    223e:	d7 01       	movw	r26, r14
    2240:	ed 91       	ld	r30, X+
    2242:	fc 91       	ld	r31, X
    2244:	81 91       	ld	r24, Z+
    2246:	d8 01       	movw	r26, r16
    2248:	2d 91       	ld	r18, X+
    224a:	3c 91       	ld	r19, X
    224c:	11 97       	sbiw	r26, 0x01	; 1
    224e:	21 50       	subi	r18, 0x01	; 1
    2250:	30 40       	sbci	r19, 0x00	; 0
    2252:	2d 93       	st	X+, r18
    2254:	3c 93       	st	X, r19
    2256:	d7 01       	movw	r26, r14
    2258:	ed 93       	st	X+, r30
    225a:	fc 93       	st	X, r31
    225c:	8d 15       	cp	r24, r13
    225e:	61 f3       	breq	.-40     	; 0x2238 <psock_readto+0xf6>
    2260:	23 2b       	or	r18, r19
    2262:	69 f7       	brne	.-38     	; 0x223e <psock_readto+0xfc>
    2264:	81 e0       	ldi	r24, 0x01	; 1
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	81 ff       	sbrs	r24, 1
    226a:	84 cf       	rjmp	.-248    	; 0x2174 <psock_readto+0x32>
    }
  } while((buf_bufto(&psock->buf, c,
		     &psock->readptr,
		     &psock->readlen) & BUF_FOUND) == 0);
  
  if(psock_datalen(psock) == 0) {
    226c:	ce 01       	movw	r24, r28
    226e:	0e 94 7e 10 	call	0x20fc <psock_datalen>
    2272:	00 97       	sbiw	r24, 0x00	; 0
    2274:	39 f4       	brne	.+14     	; 0x2284 <psock_readto+0x142>
    psock->state = STATE_NONE;
    2276:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    2278:	9b 83       	std	Y+3, r25	; 0x03
    227a:	8a 83       	std	Y+2, r24	; 0x02
    227c:	07 c0       	rjmp	.+14     	; 0x228c <psock_readto+0x14a>
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	90 e0       	ldi	r25, 0x00	; 0
    2282:	04 c0       	rjmp	.+8      	; 0x228c <psock_readto+0x14a>
  }
  PT_END(&psock->psockpt);
    2284:	1b 82       	std	Y+3, r1	; 0x03
    2286:	1a 82       	std	Y+2, r1	; 0x02
    2288:	82 e0       	ldi	r24, 0x02	; 2
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	1f 91       	pop	r17
    2292:	0f 91       	pop	r16
    2294:	ff 90       	pop	r15
    2296:	ef 90       	pop	r14
    2298:	df 90       	pop	r13
    229a:	08 95       	ret

0000229c <psock_readbuf>:
}
/*---------------------------------------------------------------------------*/
PT_THREAD(psock_readbuf(register struct psock *psock))
{
    229c:	0f 93       	push	r16
    229e:	1f 93       	push	r17
    22a0:	cf 93       	push	r28
    22a2:	df 93       	push	r29
    22a4:	ec 01       	movw	r28, r24
  PT_BEGIN(&psock->psockpt);
    22a6:	8a 81       	ldd	r24, Y+2	; 0x02
    22a8:	9b 81       	ldd	r25, Y+3	; 0x03
    22aa:	00 97       	sbiw	r24, 0x00	; 0
    22ac:	21 f0       	breq	.+8      	; 0x22b6 <psock_readbuf+0x1a>
    22ae:	86 53       	subi	r24, 0x36	; 54
    22b0:	91 40       	sbci	r25, 0x01	; 1
    22b2:	89 f0       	breq	.+34     	; 0x22d6 <psock_readbuf+0x3a>
    22b4:	95 c0       	rjmp	.+298    	; 0x23e0 <psock_readbuf+0x144>

  buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
    22b6:	4a 89       	ldd	r20, Y+18	; 0x12
    22b8:	5b 89       	ldd	r21, Y+19	; 0x13
    22ba:	68 85       	ldd	r22, Y+8	; 0x08
    22bc:	79 85       	ldd	r23, Y+9	; 0x09
    22be:	ce 01       	movw	r24, r28
    22c0:	0e 96       	adiw	r24, 0x0e	; 14
    22c2:	0e 94 9a 0f 	call	0x1f34 <buf_setup>
  
  /* XXX: Should add buf_checkmarker() before do{} loop, if
     incoming data has been handled while waiting for a write. */

  do {
    if(psock->readlen == 0) {
    22c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    22c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    22ca:	89 2b       	or	r24, r25
    22cc:	e1 f4       	brne	.+56     	; 0x2306 <psock_readbuf+0x6a>
      PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
    22ce:	86 e3       	ldi	r24, 0x36	; 54
    22d0:	91 e0       	ldi	r25, 0x01	; 1
    22d2:	9b 83       	std	Y+3, r25	; 0x03
    22d4:	8a 83       	std	Y+2, r24	; 0x02
    22d6:	ce 01       	movw	r24, r28
    22d8:	0e 94 87 10 	call	0x210e <psock_newdata>
    22dc:	88 23       	and	r24, r24
    22de:	09 f4       	brne	.+2      	; 0x22e2 <psock_readbuf+0x46>
    22e0:	7c c0       	rjmp	.+248    	; 0x23da <psock_readbuf+0x13e>
      printf("Waited for newdata\n");
    22e2:	8d eb       	ldi	r24, 0xBD	; 189
    22e4:	92 e0       	ldi	r25, 0x02	; 2
    22e6:	0e 94 c1 16 	call	0x2d82 <puts>
      psock->state = STATE_READ;
    22ea:	82 e0       	ldi	r24, 0x02	; 2
    22ec:	8c 8b       	std	Y+20, r24	; 0x14
      psock->readptr = (u8_t *)uip_appdata;
    22ee:	80 91 74 03 	lds	r24, 0x0374
    22f2:	90 91 75 03 	lds	r25, 0x0375
    22f6:	9f 83       	std	Y+7, r25	; 0x07
    22f8:	8e 83       	std	Y+6, r24	; 0x06
      psock->readlen = uip_datalen();
    22fa:	80 91 6b 03 	lds	r24, 0x036B
    22fe:	90 91 6c 03 	lds	r25, 0x036C
    2302:	9d 87       	std	Y+13, r25	; 0x0d
    2304:	8c 87       	std	Y+12, r24	; 0x0c
    2306:	8e 01       	movw	r16, r28
    2308:	02 5f       	subi	r16, 0xF2	; 242
    230a:	1f 4f       	sbci	r17, 0xFF	; 255
    230c:	2c 85       	ldd	r18, Y+12	; 0x0c
    230e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2310:	f8 01       	movw	r30, r16
    2312:	42 81       	ldd	r20, Z+2	; 0x02
    2314:	53 81       	ldd	r21, Z+3	; 0x03
    2316:	24 17       	cp	r18, r20
    2318:	35 07       	cpc	r19, r21
    231a:	00 f5       	brcc	.+64     	; 0x235c <psock_readbuf+0xc0>
    231c:	8e 81       	ldd	r24, Y+6	; 0x06
    231e:	9f 81       	ldd	r25, Y+7	; 0x07
    2320:	a9 01       	movw	r20, r18
    2322:	bc 01       	movw	r22, r24
    2324:	8e 85       	ldd	r24, Y+14	; 0x0e
    2326:	9f 85       	ldd	r25, Y+15	; 0x0f
    2328:	0e 94 8d 16 	call	0x2d1a <memcpy>
    232c:	8e 85       	ldd	r24, Y+14	; 0x0e
    232e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2330:	2c 85       	ldd	r18, Y+12	; 0x0c
    2332:	3d 85       	ldd	r19, Y+13	; 0x0d
    2334:	82 0f       	add	r24, r18
    2336:	93 1f       	adc	r25, r19
    2338:	9f 87       	std	Y+15, r25	; 0x0f
    233a:	8e 87       	std	Y+14, r24	; 0x0e
    233c:	f8 01       	movw	r30, r16
    233e:	82 81       	ldd	r24, Z+2	; 0x02
    2340:	93 81       	ldd	r25, Z+3	; 0x03
    2342:	82 1b       	sub	r24, r18
    2344:	93 0b       	sbc	r25, r19
    2346:	93 83       	std	Z+3, r25	; 0x03
    2348:	82 83       	std	Z+2, r24	; 0x02
    234a:	8e 81       	ldd	r24, Y+6	; 0x06
    234c:	9f 81       	ldd	r25, Y+7	; 0x07
    234e:	82 0f       	add	r24, r18
    2350:	93 1f       	adc	r25, r19
    2352:	9f 83       	std	Y+7, r25	; 0x07
    2354:	8e 83       	std	Y+6, r24	; 0x06
    2356:	1d 86       	std	Y+13, r1	; 0x0d
    2358:	1c 86       	std	Y+12, r1	; 0x0c
    235a:	b5 cf       	rjmp	.-150    	; 0x22c6 <psock_readbuf+0x2a>
    235c:	6e 81       	ldd	r22, Y+6	; 0x06
    235e:	7f 81       	ldd	r23, Y+7	; 0x07
    2360:	8e 85       	ldd	r24, Y+14	; 0x0e
    2362:	9f 85       	ldd	r25, Y+15	; 0x0f
    2364:	24 17       	cp	r18, r20
    2366:	35 07       	cpc	r19, r21
    2368:	b1 f4       	brne	.+44     	; 0x2396 <psock_readbuf+0xfa>
    236a:	0e 94 8d 16 	call	0x2d1a <memcpy>
    236e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2370:	9f 85       	ldd	r25, Y+15	; 0x0f
    2372:	2c 85       	ldd	r18, Y+12	; 0x0c
    2374:	3d 85       	ldd	r19, Y+13	; 0x0d
    2376:	82 0f       	add	r24, r18
    2378:	93 1f       	adc	r25, r19
    237a:	9f 87       	std	Y+15, r25	; 0x0f
    237c:	8e 87       	std	Y+14, r24	; 0x0e
    237e:	f8 01       	movw	r30, r16
    2380:	13 82       	std	Z+3, r1	; 0x03
    2382:	12 82       	std	Z+2, r1	; 0x02
    2384:	8e 81       	ldd	r24, Y+6	; 0x06
    2386:	9f 81       	ldd	r25, Y+7	; 0x07
    2388:	82 0f       	add	r24, r18
    238a:	93 1f       	adc	r25, r19
    238c:	9f 83       	std	Y+7, r25	; 0x07
    238e:	8e 83       	std	Y+6, r24	; 0x06
    2390:	1d 86       	std	Y+13, r1	; 0x0d
    2392:	1c 86       	std	Y+12, r1	; 0x0c
    2394:	19 c0       	rjmp	.+50     	; 0x23c8 <psock_readbuf+0x12c>
    2396:	0e 94 8d 16 	call	0x2d1a <memcpy>
    239a:	8e 85       	ldd	r24, Y+14	; 0x0e
    239c:	9f 85       	ldd	r25, Y+15	; 0x0f
    239e:	f8 01       	movw	r30, r16
    23a0:	22 81       	ldd	r18, Z+2	; 0x02
    23a2:	33 81       	ldd	r19, Z+3	; 0x03
    23a4:	82 0f       	add	r24, r18
    23a6:	93 1f       	adc	r25, r19
    23a8:	9f 87       	std	Y+15, r25	; 0x0f
    23aa:	8e 87       	std	Y+14, r24	; 0x0e
    23ac:	8c 85       	ldd	r24, Y+12	; 0x0c
    23ae:	9d 85       	ldd	r25, Y+13	; 0x0d
    23b0:	82 1b       	sub	r24, r18
    23b2:	93 0b       	sbc	r25, r19
    23b4:	9d 87       	std	Y+13, r25	; 0x0d
    23b6:	8c 87       	std	Y+12, r24	; 0x0c
    23b8:	8e 81       	ldd	r24, Y+6	; 0x06
    23ba:	9f 81       	ldd	r25, Y+7	; 0x07
    23bc:	82 0f       	add	r24, r18
    23be:	93 1f       	adc	r25, r19
    23c0:	9f 83       	std	Y+7, r25	; 0x07
    23c2:	8e 83       	std	Y+6, r24	; 0x06
    23c4:	13 82       	std	Z+3, r1	; 0x03
    23c6:	12 82       	std	Z+2, r1	; 0x02
    }
  } while(buf_bufdata(&psock->buf, psock->bufsize,
			 &psock->readptr,
			 &psock->readlen) != BUF_FULL);

  if(psock_datalen(psock) == 0) {
    23c8:	ce 01       	movw	r24, r28
    23ca:	0e 94 7e 10 	call	0x20fc <psock_datalen>
    23ce:	00 97       	sbiw	r24, 0x00	; 0
    23d0:	39 f4       	brne	.+14     	; 0x23e0 <psock_readbuf+0x144>
    psock->state = STATE_NONE;
    23d2:	1c 8a       	std	Y+20, r1	; 0x14
    PT_RESTART(&psock->psockpt);
    23d4:	9b 83       	std	Y+3, r25	; 0x03
    23d6:	8a 83       	std	Y+2, r24	; 0x02
    23d8:	07 c0       	rjmp	.+14     	; 0x23e8 <psock_readbuf+0x14c>
    23da:	80 e0       	ldi	r24, 0x00	; 0
    23dc:	90 e0       	ldi	r25, 0x00	; 0
    23de:	04 c0       	rjmp	.+8      	; 0x23e8 <psock_readbuf+0x14c>
  }
  PT_END(&psock->psockpt);
    23e0:	1b 82       	std	Y+3, r1	; 0x03
    23e2:	1a 82       	std	Y+2, r1	; 0x02
    23e4:	82 e0       	ldi	r24, 0x02	; 2
    23e6:	90 e0       	ldi	r25, 0x00	; 0
    23e8:	df 91       	pop	r29
    23ea:	cf 91       	pop	r28
    23ec:	1f 91       	pop	r17
    23ee:	0f 91       	pop	r16
    23f0:	08 95       	ret

000023f2 <psock_init>:
}
/*---------------------------------------------------------------------------*/
void
psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
{
    23f2:	0f 93       	push	r16
    23f4:	1f 93       	push	r17
    23f6:	8c 01       	movw	r16, r24
  psock->state = STATE_NONE;
    23f8:	f8 01       	movw	r30, r16
    23fa:	14 8a       	std	Z+20, r1	; 0x14
  psock->readlen = 0;
    23fc:	15 86       	std	Z+13, r1	; 0x0d
    23fe:	14 86       	std	Z+12, r1	; 0x0c
  psock->bufptr = buffer;
    2400:	71 87       	std	Z+9, r23	; 0x09
    2402:	60 87       	std	Z+8, r22	; 0x08
  psock->bufsize = buffersize;
    2404:	53 8b       	std	Z+19, r21	; 0x13
    2406:	42 8b       	std	Z+18, r20	; 0x12
  buf_setup(&psock->buf, buffer, buffersize);
    2408:	c8 01       	movw	r24, r16
    240a:	0e 96       	adiw	r24, 0x0e	; 14
    240c:	0e 94 9a 0f 	call	0x1f34 <buf_setup>
  PT_INIT(&psock->pt);
    2410:	f8 01       	movw	r30, r16
    2412:	11 82       	std	Z+1, r1	; 0x01
    2414:	10 82       	st	Z, r1
  PT_INIT(&psock->psockpt);
    2416:	13 82       	std	Z+3, r1	; 0x03
    2418:	12 82       	std	Z+2, r1	; 0x02
    241a:	1f 91       	pop	r17
    241c:	0f 91       	pop	r16
    241e:	08 95       	ret

00002420 <memb_init>:

/*---------------------------------------------------------------------------*/
void
memb_init(struct memb_blocks *m)
{
    2420:	0f 93       	push	r16
    2422:	1f 93       	push	r17
    2424:	8c 01       	movw	r16, r24
  memset(m->count, 0, m->num);
    2426:	fc 01       	movw	r30, r24
    2428:	82 81       	ldd	r24, Z+2	; 0x02
    242a:	93 81       	ldd	r25, Z+3	; 0x03
    242c:	ac 01       	movw	r20, r24
    242e:	60 e0       	ldi	r22, 0x00	; 0
    2430:	70 e0       	ldi	r23, 0x00	; 0
    2432:	84 81       	ldd	r24, Z+4	; 0x04
    2434:	95 81       	ldd	r25, Z+5	; 0x05
    2436:	0e 94 9a 16 	call	0x2d34 <memset>
  memset(m->mem, 0, m->size * m->num);
    243a:	f8 01       	movw	r30, r16
    243c:	20 81       	ld	r18, Z
    243e:	31 81       	ldd	r19, Z+1	; 0x01
    2440:	82 81       	ldd	r24, Z+2	; 0x02
    2442:	93 81       	ldd	r25, Z+3	; 0x03
    2444:	28 9f       	mul	r18, r24
    2446:	a0 01       	movw	r20, r0
    2448:	29 9f       	mul	r18, r25
    244a:	50 0d       	add	r21, r0
    244c:	38 9f       	mul	r19, r24
    244e:	50 0d       	add	r21, r0
    2450:	11 24       	eor	r1, r1
    2452:	60 e0       	ldi	r22, 0x00	; 0
    2454:	70 e0       	ldi	r23, 0x00	; 0
    2456:	86 81       	ldd	r24, Z+6	; 0x06
    2458:	97 81       	ldd	r25, Z+7	; 0x07
    245a:	0e 94 9a 16 	call	0x2d34 <memset>
    245e:	1f 91       	pop	r17
    2460:	0f 91       	pop	r16
    2462:	08 95       	ret

00002464 <memb_alloc>:
}
/*---------------------------------------------------------------------------*/
void *
memb_alloc(struct memb_blocks *m)
{
    2464:	cf 93       	push	r28
    2466:	df 93       	push	r29
    2468:	dc 01       	movw	r26, r24
  int i;

  for(i = 0; i < m->num; ++i) {
    246a:	20 e0       	ldi	r18, 0x00	; 0
    246c:	30 e0       	ldi	r19, 0x00	; 0
    246e:	ec 01       	movw	r28, r24
    2470:	4a 81       	ldd	r20, Y+2	; 0x02
    2472:	5b 81       	ldd	r21, Y+3	; 0x03
    2474:	24 17       	cp	r18, r20
    2476:	35 07       	cpc	r19, r21
    2478:	d8 f4       	brcc	.+54     	; 0x24b0 <memb_alloc+0x4c>
    if(m->count[i] == 0) {
    247a:	ed 01       	movw	r28, r26
    247c:	ec 81       	ldd	r30, Y+4	; 0x04
    247e:	fd 81       	ldd	r31, Y+5	; 0x05
    2480:	e2 0f       	add	r30, r18
    2482:	f3 1f       	adc	r31, r19
    2484:	80 81       	ld	r24, Z
    2486:	88 23       	and	r24, r24
    2488:	81 f4       	brne	.+32     	; 0x24aa <memb_alloc+0x46>
      /* If this block was unused, we increase the reference count to
	 indicate that it now is used and return a pointer to the
	 memory block. */
      ++(m->count[i]);
    248a:	81 e0       	ldi	r24, 0x01	; 1
    248c:	80 83       	st	Z, r24
      return (void *)((char *)m->mem + (i * m->size));
    248e:	8d 91       	ld	r24, X+
    2490:	9c 91       	ld	r25, X
    2492:	28 9f       	mul	r18, r24
    2494:	f0 01       	movw	r30, r0
    2496:	29 9f       	mul	r18, r25
    2498:	f0 0d       	add	r31, r0
    249a:	38 9f       	mul	r19, r24
    249c:	f0 0d       	add	r31, r0
    249e:	11 24       	eor	r1, r1
    24a0:	2e 81       	ldd	r18, Y+6	; 0x06
    24a2:	3f 81       	ldd	r19, Y+7	; 0x07
    24a4:	2e 0f       	add	r18, r30
    24a6:	3f 1f       	adc	r19, r31
    24a8:	05 c0       	rjmp	.+10     	; 0x24b4 <memb_alloc+0x50>
    24aa:	2f 5f       	subi	r18, 0xFF	; 255
    24ac:	3f 4f       	sbci	r19, 0xFF	; 255
    24ae:	e2 cf       	rjmp	.-60     	; 0x2474 <memb_alloc+0x10>
    }
  }

  /* No free block was found, so we return NULL to indicate failure to
     allocate block. */
  return NULL;
    24b0:	20 e0       	ldi	r18, 0x00	; 0
    24b2:	30 e0       	ldi	r19, 0x00	; 0
}
    24b4:	c9 01       	movw	r24, r18
    24b6:	df 91       	pop	r29
    24b8:	cf 91       	pop	r28
    24ba:	08 95       	ret

000024bc <memb_free>:
/*---------------------------------------------------------------------------*/
char
memb_free(struct memb_blocks *m, void *ptr)
{
    24bc:	cf 93       	push	r28
    24be:	df 93       	push	r29
    24c0:	ec 01       	movw	r28, r24
  int i;
  char *ptr2;

  /* Walk through the list of blocks and try to find the block to
     which the pointer "ptr" points to. */
  ptr2 = (char *)m->mem;
    24c2:	2e 81       	ldd	r18, Y+6	; 0x06
    24c4:	3f 81       	ldd	r19, Y+7	; 0x07
  for(i = 0; i < m->num; ++i) {
    24c6:	a0 e0       	ldi	r26, 0x00	; 0
    24c8:	b0 e0       	ldi	r27, 0x00	; 0
    24ca:	4a 81       	ldd	r20, Y+2	; 0x02
    24cc:	5b 81       	ldd	r21, Y+3	; 0x03
    24ce:	a4 17       	cp	r26, r20
    24d0:	b5 07       	cpc	r27, r21
    24d2:	c8 f4       	brcc	.+50     	; 0x2506 <memb_free+0x4a>
    
    if(ptr2 == (char *)ptr) {
    24d4:	26 17       	cp	r18, r22
    24d6:	37 07       	cpc	r19, r23
    24d8:	81 f4       	brne	.+32     	; 0x24fa <memb_free+0x3e>
      /* We've found to block to which "ptr" points so we decrease the
	 reference count and return the new value of it. */
      if(m->count[i] > 0) {
    24da:	ec 81       	ldd	r30, Y+4	; 0x04
    24dc:	fd 81       	ldd	r31, Y+5	; 0x05
    24de:	ea 0f       	add	r30, r26
    24e0:	fb 1f       	adc	r31, r27
    24e2:	80 81       	ld	r24, Z
    24e4:	88 23       	and	r24, r24
    24e6:	11 f0       	breq	.+4      	; 0x24ec <memb_free+0x30>
	/* Make sure that we don't deallocate free memory. */
	--(m->count[i]);
    24e8:	81 50       	subi	r24, 0x01	; 1
    24ea:	80 83       	st	Z, r24
      }
      return m->count[i];
    24ec:	8c 81       	ldd	r24, Y+4	; 0x04
    24ee:	9d 81       	ldd	r25, Y+5	; 0x05
    24f0:	a8 0f       	add	r26, r24
    24f2:	b9 1f       	adc	r27, r25
    24f4:	8c 91       	ld	r24, X
    24f6:	99 27       	eor	r25, r25
    24f8:	08 c0       	rjmp	.+16     	; 0x250a <memb_free+0x4e>
    }
    ptr2 += m->size;
    24fa:	88 81       	ld	r24, Y
    24fc:	99 81       	ldd	r25, Y+1	; 0x01
    24fe:	28 0f       	add	r18, r24
    2500:	39 1f       	adc	r19, r25
    2502:	11 96       	adiw	r26, 0x01	; 1
    2504:	e4 cf       	rjmp	.-56     	; 0x24ce <memb_free+0x12>
  }
  return -1;
    2506:	8f ef       	ldi	r24, 0xFF	; 255
    2508:	90 e0       	ldi	r25, 0x00	; 0
    250a:	df 91       	pop	r29
    250c:	cf 91       	pop	r28
    250e:	08 95       	ret

00002510 <clock_time>:
;*****************************************************************************************************
;*/
clock_time_t clock_time(void)
{
  return UIP_Ticks;
    2510:	80 91 28 08 	lds	r24, 0x0828
    2514:	90 91 29 08 	lds	r25, 0x0829
    2518:	08 95       	ret

0000251a <__vector_11>:
}

/*
;*****************************************************************************************************
;* 函数名称 : SIGNAL(SIG_OVERFLOW0)
;* 描    述 : 系统定时器中断服务子程序
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
SIGNAL(SIG_OVERFLOW0) 
{
    251a:	1f 92       	push	r1
    251c:	0f 92       	push	r0
    251e:	0f b6       	in	r0, 0x3f	; 63
    2520:	0f 92       	push	r0
    2522:	11 24       	eor	r1, r1
    2524:	8f 93       	push	r24
    2526:	9f 93       	push	r25
	TCNT0 = 0x80;
    2528:	80 e8       	ldi	r24, 0x80	; 128
    252a:	82 bf       	out	0x32, r24	; 50

	UIP_Ticks++;							/* 系统嗒嘀加一	*/			
    252c:	80 91 28 08 	lds	r24, 0x0828
    2530:	90 91 29 08 	lds	r25, 0x0829
    2534:	01 96       	adiw	r24, 0x01	; 1
    2536:	90 93 29 08 	sts	0x0829, r25
    253a:	80 93 28 08 	sts	0x0828, r24
    253e:	9f 91       	pop	r25
    2540:	8f 91       	pop	r24
    2542:	0f 90       	pop	r0
    2544:	0f be       	out	0x3f, r0	; 63
    2546:	0f 90       	pop	r0
    2548:	1f 90       	pop	r1
    254a:	18 95       	reti

0000254c <UIP_Clock_Init>:
}

/*
;*****************************************************************************************************
;* 函数名称 : UIP_Clock_Init
;* 描    述 : 初始化系统定时器
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void UIP_Clock_Init(void) 
{
	TCCR0 = 0; 
    254c:	13 be       	out	0x33, r1	; 51

	TCCR0 |= (1 << CS02);   				/* 256预分频 */
    254e:	83 b7       	in	r24, 0x33	; 51
    2550:	84 60       	ori	r24, 0x04	; 4
    2552:	83 bf       	out	0x33, r24	; 51
	
	TIMSK |= (1 << TOIE0);  				/* 允许Timer0溢出中断 */
    2554:	89 b7       	in	r24, 0x39	; 57
    2556:	81 60       	ori	r24, 0x01	; 1
    2558:	89 bf       	out	0x39, r24	; 57
	
	TCNT0 = 0x80;							/* 置Timer0计数初值 */
    255a:	80 e8       	ldi	r24, 0x80	; 128
    255c:	82 bf       	out	0x32, r24	; 50
	
	UIP_Ticks = 0;
    255e:	10 92 29 08 	sts	0x0829, r1
    2562:	10 92 28 08 	sts	0x0828, r1
    2566:	08 95       	ret

00002568 <tapdev_init>:
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void tapdev_init(void)
{
    2568:	cf 93       	push	r28
    256a:	df 93       	push	r29
    256c:	cd b7       	in	r28, 0x3d	; 61
    256e:	de b7       	in	r29, 0x3e	; 62
    2570:	26 97       	sbiw	r28, 0x06	; 6
    2572:	0f b6       	in	r0, 0x3f	; 63
    2574:	f8 94       	cli
    2576:	de bf       	out	0x3e, r29	; 62
    2578:	0f be       	out	0x3f, r0	; 63
    257a:	cd bf       	out	0x3d, r28	; 61
#if UIP_FIXEDETHADDR == 0
	extern char avr_mac[];
#else
	char avr_mac[] = {UIP_ETHADDR0,UIP_ETHADDR1,UIP_ETHADDR2, UIP_ETHADDR3, UIP_ETHADDR4, UIP_ETHADDR5};
    257c:	ae 01       	movw	r20, r28
    257e:	4f 5f       	subi	r20, 0xFF	; 255
    2580:	5f 4f       	sbci	r21, 0xFF	; 255
    2582:	86 e0       	ldi	r24, 0x06	; 6
    2584:	20 ed       	ldi	r18, 0xD0	; 208
    2586:	32 e0       	ldi	r19, 0x02	; 2
    2588:	da 01       	movw	r26, r20
    258a:	f9 01       	movw	r30, r18
    258c:	01 90       	ld	r0, Z+
    258e:	0d 92       	st	X+, r0
    2590:	8a 95       	dec	r24
    2592:	e1 f7       	brne	.-8      	; 0x258c <tapdev_init+0x24>
#endif

	enc28j60_init(avr_mac);
    2594:	ca 01       	movw	r24, r20
    2596:	0e 94 c5 13 	call	0x278a <enc28j60_init>
	plen = 0;
    259a:	10 92 2b 08 	sts	0x082B, r1
    259e:	10 92 2a 08 	sts	0x082A, r1
	
#ifdef ENC28J60_RX_ISR	
	GICR |= 0x01 << 6;
    25a2:	8b b7       	in	r24, 0x3b	; 59
    25a4:	80 64       	ori	r24, 0x40	; 64
    25a6:	8b bf       	out	0x3b, r24	; 59
    25a8:	26 96       	adiw	r28, 0x06	; 6
    25aa:	0f b6       	in	r0, 0x3f	; 63
    25ac:	f8 94       	cli
    25ae:	de bf       	out	0x3e, r29	; 62
    25b0:	0f be       	out	0x3f, r0	; 63
    25b2:	cd bf       	out	0x3d, r28	; 61
    25b4:	df 91       	pop	r29
    25b6:	cf 91       	pop	r28
    25b8:	08 95       	ret

000025ba <tapdev_read>:
#endif
}

/*
;*****************************************************************************************************
;* 函数名称 : tapdev_read
;* 描    述 : 从网络设备读回一个数据报
;* 输　	 入 : 无
;*        
;* 输　	 出 : 数据报长度
;*****************************************************************************************************
;*/
unsigned int tapdev_read(void)
{
#ifdef ENC28J60_RX_ISR
	unsigned int temp;
	extern volatile clock_time_t UIP_Ticks;
	
	temp = UIP_Ticks;
    25ba:	20 91 28 08 	lds	r18, 0x0828
    25be:	30 91 29 08 	lds	r19, 0x0829
	
	while (plen == 0 && temp == UIP_Ticks)
    25c2:	80 91 2a 08 	lds	r24, 0x082A
    25c6:	90 91 2b 08 	lds	r25, 0x082B
    25ca:	89 2b       	or	r24, r25
    25cc:	39 f4       	brne	.+14     	; 0x25dc <tapdev_read+0x22>
    25ce:	80 91 28 08 	lds	r24, 0x0828
    25d2:	90 91 29 08 	lds	r25, 0x0829
    25d6:	28 17       	cp	r18, r24
    25d8:	39 07       	cpc	r19, r25
    25da:	99 f3       	breq	.-26     	; 0x25c2 <tapdev_read+0x8>
	;
	
	temp = plen;
    25dc:	20 91 2a 08 	lds	r18, 0x082A
    25e0:	30 91 2b 08 	lds	r19, 0x082B
	
	plen = 0;
    25e4:	10 92 2b 08 	sts	0x082B, r1
    25e8:	10 92 2a 08 	sts	0x082A, r1

	return temp;
#else
	return enc28j60_packet_receive(uip_buf, UIP_BUFSIZE );	
#endif
}
    25ec:	c9 01       	movw	r24, r18
    25ee:	08 95       	ret

000025f0 <__vector_1>:

/*
;*****************************************************************************************************
;* 函数名称 : SIGNAL(SIG_INTERRUPT0) 
;* 描    述 : 网络设备接收到一个数据报后的中断处理程序
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
#ifdef ENC28J60_RX_ISR
SIGNAL(SIG_INTERRUPT0)  
{
    25f0:	1f 92       	push	r1
    25f2:	0f 92       	push	r0
    25f4:	0f b6       	in	r0, 0x3f	; 63
    25f6:	0f 92       	push	r0
    25f8:	11 24       	eor	r1, r1
    25fa:	2f 93       	push	r18
    25fc:	3f 93       	push	r19
    25fe:	4f 93       	push	r20
    2600:	5f 93       	push	r21
    2602:	6f 93       	push	r22
    2604:	7f 93       	push	r23
    2606:	8f 93       	push	r24
    2608:	9f 93       	push	r25
    260a:	af 93       	push	r26
    260c:	bf 93       	push	r27
    260e:	ef 93       	push	r30
    2610:	ff 93       	push	r31
	// get new packet
	plen = enc28j60_packet_receive(uip_buf, UIP_BUFSIZE );	
    2612:	64 ea       	ldi	r22, 0xA4	; 164
    2614:	71 e0       	ldi	r23, 0x01	; 1
    2616:	80 e8       	ldi	r24, 0x80	; 128
    2618:	96 e0       	ldi	r25, 0x06	; 6
    261a:	0e 94 d7 14 	call	0x29ae <enc28j60_packet_receive>
    261e:	90 93 2b 08 	sts	0x082B, r25
    2622:	80 93 2a 08 	sts	0x082A, r24
    2626:	ff 91       	pop	r31
    2628:	ef 91       	pop	r30
    262a:	bf 91       	pop	r27
    262c:	af 91       	pop	r26
    262e:	9f 91       	pop	r25
    2630:	8f 91       	pop	r24
    2632:	7f 91       	pop	r23
    2634:	6f 91       	pop	r22
    2636:	5f 91       	pop	r21
    2638:	4f 91       	pop	r20
    263a:	3f 91       	pop	r19
    263c:	2f 91       	pop	r18
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	0f 90       	pop	r0
    2644:	1f 90       	pop	r1
    2646:	18 95       	reti

00002648 <tapdev_send>:
}
#endif

/*
;*****************************************************************************************************
;* 函数名称 : tapdev_send
;* 描    述 : 利用网络设备发送一个数据报到网络
;* 输　	 入 : 无
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void tapdev_send(void)
{
	enc28j60_packet_send(uip_buf, uip_len);
    2648:	60 91 6b 03 	lds	r22, 0x036B
    264c:	70 91 6c 03 	lds	r23, 0x036C
    2650:	80 e8       	ldi	r24, 0x80	; 128
    2652:	96 e0       	ldi	r25, 0x06	; 6
    2654:	0e 94 90 14 	call	0x2920 <enc28j60_packet_send>
    2658:	08 95       	ret

0000265a <enc28j60ReadOp>:
//*******************************************************************************************
BYTE enc28j60ReadOp(BYTE op, BYTE address)
{
	// activate CS
	CSACTIVE;
    265a:	c4 98       	cbi	0x18, 4	; 24
	// issue read command
	SPDR = op | (address & ADDR_MASK);
    265c:	96 2f       	mov	r25, r22
    265e:	9f 71       	andi	r25, 0x1F	; 31
    2660:	98 2b       	or	r25, r24
    2662:	9f b9       	out	0x0f, r25	; 15
	waitspi();
    2664:	77 9b       	sbis	0x0e, 7	; 14
    2666:	fe cf       	rjmp	.-4      	; 0x2664 <enc28j60ReadOp+0xa>
	// read data
	SPDR = 0x00;
    2668:	1f b8       	out	0x0f, r1	; 15
	waitspi();
    266a:	77 9b       	sbis	0x0e, 7	; 14
    266c:	fe cf       	rjmp	.-4      	; 0x266a <enc28j60ReadOp+0x10>
	// do dummy read if needed (for mac and mii, see datasheet page 29)
	if(address & 0x80)
    266e:	67 ff       	sbrs	r22, 7
    2670:	03 c0       	rjmp	.+6      	; 0x2678 <enc28j60ReadOp+0x1e>
	{
		SPDR = 0x00;
    2672:	1f b8       	out	0x0f, r1	; 15
		waitspi();
    2674:	77 9b       	sbis	0x0e, 7	; 14
    2676:	fe cf       	rjmp	.-4      	; 0x2674 <enc28j60ReadOp+0x1a>
	}
	// release CS
	CSPASSIVE;
    2678:	c4 9a       	sbi	0x18, 4	; 24
	return(SPDR);
    267a:	8f b1       	in	r24, 0x0f	; 15
}
    267c:	99 27       	eor	r25, r25
    267e:	08 95       	ret

00002680 <enc28j60WriteOp>:

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60WriteOp(BYTE op, BYTE address, BYTE data)
{
    2680:	96 2f       	mov	r25, r22
	CSACTIVE;
    2682:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = op | (address & ADDR_MASK);
    2684:	9f 71       	andi	r25, 0x1F	; 31
    2686:	98 2b       	or	r25, r24
    2688:	9f b9       	out	0x0f, r25	; 15
	waitspi();
    268a:	77 9b       	sbis	0x0e, 7	; 14
    268c:	fe cf       	rjmp	.-4      	; 0x268a <enc28j60WriteOp+0xa>
	// write data
	SPDR = data;
    268e:	4f b9       	out	0x0f, r20	; 15
	waitspi();
    2690:	77 9b       	sbis	0x0e, 7	; 14
    2692:	fe cf       	rjmp	.-4      	; 0x2690 <enc28j60WriteOp+0x10>
	CSPASSIVE;
    2694:	c4 9a       	sbi	0x18, 4	; 24
    2696:	08 95       	ret

00002698 <enc28j60SetBank>:
}

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60SetBank(BYTE address)
{
    2698:	1f 93       	push	r17
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	18 2f       	mov	r17, r24
	// set the bank (if needed)
	if((address & BANK_MASK) != Enc28j60Bank)
    26a0:	c8 2f       	mov	r28, r24
    26a2:	dd 27       	eor	r29, r29
    26a4:	c0 76       	andi	r28, 0x60	; 96
    26a6:	d0 70       	andi	r29, 0x00	; 0
    26a8:	80 91 68 03 	lds	r24, 0x0368
    26ac:	99 27       	eor	r25, r25
    26ae:	c8 17       	cp	r28, r24
    26b0:	d9 07       	cpc	r29, r25
    26b2:	91 f0       	breq	.+36     	; 0x26d8 <enc28j60SetBank+0x40>
	{
		// set the bank
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
    26b4:	43 e0       	ldi	r20, 0x03	; 3
    26b6:	6f e1       	ldi	r22, 0x1F	; 31
    26b8:	80 ea       	ldi	r24, 0xA0	; 160
    26ba:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
		enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
    26be:	85 e0       	ldi	r24, 0x05	; 5
    26c0:	d5 95       	asr	r29
    26c2:	c7 95       	ror	r28
    26c4:	8a 95       	dec	r24
    26c6:	e1 f7       	brne	.-8      	; 0x26c0 <enc28j60SetBank+0x28>
    26c8:	4c 2f       	mov	r20, r28
    26ca:	6f e1       	ldi	r22, 0x1F	; 31
    26cc:	80 e8       	ldi	r24, 0x80	; 128
    26ce:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
		Enc28j60Bank = (address & BANK_MASK);
    26d2:	10 76       	andi	r17, 0x60	; 96
    26d4:	10 93 68 03 	sts	0x0368, r17
    26d8:	df 91       	pop	r29
    26da:	cf 91       	pop	r28
    26dc:	1f 91       	pop	r17
    26de:	08 95       	ret

000026e0 <enc28j60Read>:
	}
}

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
BYTE enc28j60Read(BYTE address)
{
    26e0:	1f 93       	push	r17
    26e2:	18 2f       	mov	r17, r24
	// select bank to read
	enc28j60SetBank(address);
    26e4:	0e 94 4c 13 	call	0x2698 <enc28j60SetBank>
	
	// do the read
	return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
    26e8:	61 2f       	mov	r22, r17
    26ea:	80 e0       	ldi	r24, 0x00	; 0
    26ec:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
}
    26f0:	99 27       	eor	r25, r25
    26f2:	1f 91       	pop	r17
    26f4:	08 95       	ret

000026f6 <enc28j60Write>:

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60Write(BYTE address, BYTE data)
{
    26f6:	0f 93       	push	r16
    26f8:	1f 93       	push	r17
    26fa:	08 2f       	mov	r16, r24
    26fc:	16 2f       	mov	r17, r22
	// select bank to write
	enc28j60SetBank(address);
    26fe:	0e 94 4c 13 	call	0x2698 <enc28j60SetBank>

	// do the write
	enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
    2702:	41 2f       	mov	r20, r17
    2704:	60 2f       	mov	r22, r16
    2706:	80 e4       	ldi	r24, 0x40	; 64
    2708:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
    270c:	1f 91       	pop	r17
    270e:	0f 91       	pop	r16
    2710:	08 95       	ret

00002712 <enc28j60_read_phyreg>:
}

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
WORD enc28j60_read_phyreg(BYTE address)
{
    2712:	0f 93       	push	r16
    2714:	1f 93       	push	r17
	WORD data;
	
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
    2716:	68 2f       	mov	r22, r24
    2718:	84 ed       	ldi	r24, 0xD4	; 212
    271a:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MICMD, MICMD_MIIRD);
    271e:	61 e0       	ldi	r22, 0x01	; 1
    2720:	82 ed       	ldi	r24, 0xD2	; 210
    2722:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// Loop to wait until the PHY register has been read through the MII
	// This requires 10.24us
	while( (enc28j60Read(MISTAT) & MISTAT_BUSY) );
    2726:	8a ee       	ldi	r24, 0xEA	; 234
    2728:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    272c:	80 fd       	sbrc	r24, 0
    272e:	fb cf       	rjmp	.-10     	; 0x2726 <enc28j60_read_phyreg+0x14>
	
	// Stop reading
	enc28j60Write(MICMD, MICMD_MIIRD);
    2730:	61 e0       	ldi	r22, 0x01	; 1
    2732:	82 ed       	ldi	r24, 0xD2	; 210
    2734:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// Obtain results and return
	data = enc28j60Read ( MIRDL );
    2738:	88 ed       	ldi	r24, 0xD8	; 216
    273a:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    273e:	08 2f       	mov	r16, r24
    2740:	11 27       	eor	r17, r17
	data |= enc28j60Read ( MIRDH );
    2742:	89 ed       	ldi	r24, 0xD9	; 217
    2744:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    2748:	99 27       	eor	r25, r25

	return data;
}
    274a:	80 2b       	or	r24, r16
    274c:	91 2b       	or	r25, r17
    274e:	1f 91       	pop	r17
    2750:	0f 91       	pop	r16
    2752:	08 95       	ret

00002754 <enc28j60PhyWrite>:

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60PhyWrite(BYTE address, WORD_BYTES data)
{
    2754:	0f 93       	push	r16
    2756:	1f 93       	push	r17
    2758:	8b 01       	movw	r16, r22
	// set the PHY register address
	enc28j60Write(MIREGADR, address);
    275a:	68 2f       	mov	r22, r24
    275c:	84 ed       	ldi	r24, 0xD4	; 212
    275e:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// write the PHY data
	enc28j60Write(MIWRL, data.byte.low);
    2762:	60 2f       	mov	r22, r16
    2764:	86 ed       	ldi	r24, 0xD6	; 214
    2766:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MIWRH, data.byte.high);
    276a:	61 2f       	mov	r22, r17
    276c:	87 ed       	ldi	r24, 0xD7	; 215
    276e:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// wait until the PHY write completes
	while(enc28j60Read(MISTAT) & MISTAT_BUSY)
    2772:	03 c0       	rjmp	.+6      	; 0x277a <enc28j60PhyWrite+0x26>
		__ticks = 1;
	else if (__tmp > 255)
		__ticks = 0;	/* i.e. 256 */
	else
		__ticks = (uint8_t)__tmp;
    2774:	80 e5       	ldi	r24, 0x50	; 80
    2776:	8a 95       	dec	r24
    2778:	f1 f7       	brne	.-4      	; 0x2776 <enc28j60PhyWrite+0x22>
    277a:	8a ee       	ldi	r24, 0xEA	; 234
    277c:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    2780:	80 fd       	sbrc	r24, 0
    2782:	f8 cf       	rjmp	.-16     	; 0x2774 <enc28j60PhyWrite+0x20>
    2784:	1f 91       	pop	r17
    2786:	0f 91       	pop	r16
    2788:	08 95       	ret

0000278a <enc28j60_init>:
	{
		_delay_us(15);
	}
}

//*******************************************************************************************
//
// Function : icmp_send_request
// Description : Send ARP request packet to destination.
//
//*******************************************************************************************
void enc28j60_init( BYTE *avr_mac)
{
    278a:	ef 92       	push	r14
    278c:	ff 92       	push	r15
    278e:	0f 93       	push	r16
    2790:	1f 93       	push	r17
    2792:	7c 01       	movw	r14, r24
	// enable PB0, reset as output 
	ENC28J60_DDR |= _BV(ENC28J60_RESET_PIN_DDR);
    2794:	8b 9a       	sbi	0x11, 3	; 17

	// enable PD2/INT0, as input
	ENC28J60_DDR &= ~_BV(ENC28J60_INT_PIN_DDR);
    2796:	8a 98       	cbi	0x11, 2	; 17
	ENC28J60_PORT |= _BV(ENC28J60_INT_PIN);
    2798:	92 9a       	sbi	0x12, 2	; 18

	// set output to gnd, reset the ethernet chip
	ENC28J60_PORT &= ~_BV(ENC28J60_RESET_PIN);
    279a:	93 98       	cbi	0x12, 3	; 18
		__ticks = 1;
	else if (__tmp > 65535)
		__ticks = 0;	/* i.e. 65536 */
	else
		__ticks = (uint16_t)__tmp;
    279c:	80 e4       	ldi	r24, 0x40	; 64
    279e:	9c e9       	ldi	r25, 0x9C	; 156
    27a0:	01 97       	sbiw	r24, 0x01	; 1
    27a2:	f1 f7       	brne	.-4      	; 0x27a0 <enc28j60_init+0x16>
	_delay_ms(10);

	// set output to Vcc, reset inactive
	ENC28J60_PORT |= _BV(ENC28J60_RESET_PIN);
    27a4:	93 9a       	sbi	0x12, 3	; 18
	double __tmp = ((F_CPU) / 4e3) * __ms;
	if (__tmp < 1.0)
		__ticks = 1;
	else if (__tmp > 65535)
		__ticks = 0;	/* i.e. 65536 */
    27a6:	00 e0       	ldi	r16, 0x00	; 0
    27a8:	10 e0       	ldi	r17, 0x00	; 0
    27aa:	c8 01       	movw	r24, r16
    27ac:	01 97       	sbiw	r24, 0x01	; 1
    27ae:	f1 f7       	brne	.-4      	; 0x27ac <enc28j60_init+0x22>
	_delay_ms(200);

	DDRB  |= _BV( DDB4 ) | _BV( DDB5 ) | _BV( DDB7 ); // mosi, sck, ss output
    27b0:	87 b3       	in	r24, 0x17	; 23
    27b2:	80 6b       	ori	r24, 0xB0	; 176
    27b4:	87 bb       	out	0x17, r24	; 23

	CSPASSIVE;
    27b6:	c4 9a       	sbi	0x18, 4	; 24
	PORTB &= ~(_BV( PB5 ) | _BV( PB7 ) );
    27b8:	88 b3       	in	r24, 0x18	; 24
    27ba:	8f 75       	andi	r24, 0x5F	; 95
    27bc:	88 bb       	out	0x18, r24	; 24

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = _BV( SPE ) | _BV( MSTR );
    27be:	80 e5       	ldi	r24, 0x50	; 80
    27c0:	8d b9       	out	0x0d, r24	; 13
    SPSR |= _BV( SPI2X );
    27c2:	70 9a       	sbi	0x0e, 0	; 14

	// perform system reset
	enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
    27c4:	4f ef       	ldi	r20, 0xFF	; 255
    27c6:	60 e0       	ldi	r22, 0x00	; 0
    27c8:	84 2f       	mov	r24, r20
    27ca:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    27ce:	c8 01       	movw	r24, r16
    27d0:	01 97       	sbiw	r24, 0x01	; 1
    27d2:	f1 f7       	brne	.-4      	; 0x27d0 <enc28j60_init+0x46>
	_delay_ms(50);

	// check CLKRDY bit to see if reset is complete
	// The CLKRDY does not work. See Rev. B4 Silicon Errata point. Just wait.
	// while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
	// do bank 0 stuff
	// initialize receive buffer
	// 16-bit transfers, must write low byte first
	// set receive buffer start address
	next_packet_ptr.word = RXSTART_INIT;
    27d4:	10 93 6a 03 	sts	0x036A, r17
    27d8:	00 93 69 03 	sts	0x0369, r16
    // Rx start
	enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);
    27dc:	60 e0       	ldi	r22, 0x00	; 0
    27de:	88 e0       	ldi	r24, 0x08	; 8
    27e0:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ERXSTH, RXSTART_INIT>>8);
    27e4:	60 e0       	ldi	r22, 0x00	; 0
    27e6:	89 e0       	ldi	r24, 0x09	; 9
    27e8:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// set receive pointer address
	enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
    27ec:	60 e0       	ldi	r22, 0x00	; 0
    27ee:	8c e0       	ldi	r24, 0x0C	; 12
    27f0:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
    27f4:	60 e0       	ldi	r22, 0x00	; 0
    27f6:	8d e0       	ldi	r24, 0x0D	; 13
    27f8:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// RX end
	enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
    27fc:	63 e2       	ldi	r22, 0x23	; 35
    27fe:	8a e0       	ldi	r24, 0x0A	; 10
    2800:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
    2804:	6a e1       	ldi	r22, 0x1A	; 26
    2806:	8b e0       	ldi	r24, 0x0B	; 11
    2808:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// TX start
	enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
    280c:	64 e2       	ldi	r22, 0x24	; 36
    280e:	84 e0       	ldi	r24, 0x04	; 4
    2810:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ETXSTH, TXSTART_INIT>>8);
    2814:	6a e1       	ldi	r22, 0x1A	; 26
    2816:	85 e0       	ldi	r24, 0x05	; 5
    2818:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	// TX end
	enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
    281c:	60 e0       	ldi	r22, 0x00	; 0
    281e:	86 e0       	ldi	r24, 0x06	; 6
    2820:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
    2824:	60 e2       	ldi	r22, 0x20	; 32
    2826:	87 e0       	ldi	r24, 0x07	; 7
    2828:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// do bank 2 stuff
	// enable MAC receive
	enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
    282c:	6d e0       	ldi	r22, 0x0D	; 13
    282e:	80 ec       	ldi	r24, 0xC0	; 192
    2830:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// bring MAC out of reset
	//enc28j60Write(MACON2, 0x00);

	// enable automatic padding to 60bytes and CRC operations
	enc28j60Write(MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN);
    2834:	62 e3       	ldi	r22, 0x32	; 50
    2836:	82 ec       	ldi	r24, 0xC2	; 194
    2838:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// Allow infinite deferals if the medium is continuously busy 
    // (do not time out a transmission if the half duplex medium is 
    // completely saturated with other people's data)
    enc28j60Write(MACON4, MACON4_DEFER);
    283c:	60 e4       	ldi	r22, 0x40	; 64
    283e:	83 ec       	ldi	r24, 0xC3	; 195
    2840:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter)
	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
	// collisions will occur less often with a larger number.
    enc28j60Write(MACLCON2, 63);
    2844:	6f e3       	ldi	r22, 0x3F	; 63
    2846:	89 ec       	ldi	r24, 0xC9	; 201
    2848:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
	// later.
	enc28j60Write(MAIPGL, 0x12);
    284c:	62 e1       	ldi	r22, 0x12	; 18
    284e:	86 ec       	ldi	r24, 0xC6	; 198
    2850:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAIPGH, 0x0C);
    2854:	6c e0       	ldi	r22, 0x0C	; 12
    2856:	87 ec       	ldi	r24, 0xC7	; 199
    2858:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// Set the maximum packet size which the controller will accept
    // Do not send packets longer than MAX_FRAMELEN:
	enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
    285c:	64 ea       	ldi	r22, 0xA4	; 164
    285e:	8a ec       	ldi	r24, 0xCA	; 202
    2860:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
    2864:	61 e0       	ldi	r22, 0x01	; 1
    2866:	8b ec       	ldi	r24, 0xCB	; 203
    2868:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// do bank 3 stuff
    // write MAC address
	// NOTE: MAC address in ENC28J60 is byte-backward
	// ENC28J60 is big-endian avr gcc is little-endian
	enc28j60Write(MAADR5, avr_mac[0]);
    286c:	f7 01       	movw	r30, r14
    286e:	60 81       	ld	r22, Z
    2870:	84 ee       	ldi	r24, 0xE4	; 228
    2872:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAADR4, avr_mac[1]);
    2876:	f7 01       	movw	r30, r14
    2878:	61 81       	ldd	r22, Z+1	; 0x01
    287a:	85 ee       	ldi	r24, 0xE5	; 229
    287c:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAADR3, avr_mac[2]);
    2880:	f7 01       	movw	r30, r14
    2882:	62 81       	ldd	r22, Z+2	; 0x02
    2884:	82 ee       	ldi	r24, 0xE2	; 226
    2886:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAADR2, avr_mac[3]);
    288a:	f7 01       	movw	r30, r14
    288c:	63 81       	ldd	r22, Z+3	; 0x03
    288e:	83 ee       	ldi	r24, 0xE3	; 227
    2890:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAADR1, avr_mac[4]);
    2894:	f7 01       	movw	r30, r14
    2896:	64 81       	ldd	r22, Z+4	; 0x04
    2898:	80 ee       	ldi	r24, 0xE0	; 224
    289a:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(MAADR0, avr_mac[5]);
    289e:	f7 01       	movw	r30, r14
    28a0:	65 81       	ldd	r22, Z+5	; 0x05
    28a2:	81 ee       	ldi	r24, 0xE1	; 225
    28a4:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// no loopback of transmitted frames
	enc28j60PhyWrite(PHCON2, (WORD_BYTES){PHCON2_HDLDIS});
    28a8:	60 e0       	ldi	r22, 0x00	; 0
    28aa:	71 e0       	ldi	r23, 0x01	; 1
    28ac:	80 e1       	ldi	r24, 0x10	; 16
    28ae:	0e 94 aa 13 	call	0x2754 <enc28j60PhyWrite>
	
	// Magjack leds configuration, see enc28j60 datasheet, page 11
	// 0x476 is PHLCON LEDA=links status, LEDB=receive/transmit
	// enc28j60PhyWrite(PHLCON,0b0000 0100 0111 00 10);
	enc28j60PhyWrite(PHLCON,(WORD_BYTES){0x0472});
    28b2:	62 e7       	ldi	r22, 0x72	; 114
    28b4:	74 e0       	ldi	r23, 0x04	; 4
    28b6:	84 e1       	ldi	r24, 0x14	; 20
    28b8:	0e 94 aa 13 	call	0x2754 <enc28j60PhyWrite>

	// do bank 1 stuff, packet filter:
	// For broadcast packets we allow only ARP packtets
	// All other packets should be unicast only for our mac (MAADR)
	//
	// The pattern to match on is therefore
	// Type     ETH.DST
	// ARP      BROADCAST
 	// 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
	// in binary these poitions are:11 0000 0011 1111
	// This is hex 303F->EPMM0=0x3f,EPMM1=0x30
	enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
    28bc:	60 eb       	ldi	r22, 0xB0	; 176
    28be:	88 e3       	ldi	r24, 0x38	; 56
    28c0:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(EPMM0, 0x3f);
    28c4:	6f e3       	ldi	r22, 0x3F	; 63
    28c6:	88 e2       	ldi	r24, 0x28	; 40
    28c8:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(EPMM1, 0x30);
    28cc:	60 e3       	ldi	r22, 0x30	; 48
    28ce:	89 e2       	ldi	r24, 0x29	; 41
    28d0:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(EPMCSL, 0xf9);
    28d4:	69 ef       	ldi	r22, 0xF9	; 249
    28d6:	80 e3       	ldi	r24, 0x30	; 48
    28d8:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(EPMCSH, 0xf7);
    28dc:	67 ef       	ldi	r22, 0xF7	; 247
    28de:	81 e3       	ldi	r24, 0x31	; 49
    28e0:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// set inter-frame gap (back-to-back)
	enc28j60Write(MABBIPG, 0x12);
    28e4:	62 e1       	ldi	r22, 0x12	; 18
    28e6:	84 ec       	ldi	r24, 0xC4	; 196
    28e8:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	
	// switch to bank 0
	enc28j60SetBank(ECON1);
    28ec:	8f e1       	ldi	r24, 0x1F	; 31
    28ee:	0e 94 4c 13 	call	0x2698 <enc28j60SetBank>

	// enable interrutps
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
    28f2:	40 ec       	ldi	r20, 0xC0	; 192
    28f4:	6b e1       	ldi	r22, 0x1B	; 27
    28f6:	80 e8       	ldi	r24, 0x80	; 128
    28f8:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>

	// enable packet reception
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
    28fc:	44 e0       	ldi	r20, 0x04	; 4
    28fe:	6f e1       	ldi	r22, 0x1F	; 31
    2900:	80 e8       	ldi	r24, 0x80	; 128
    2902:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2906:	c8 01       	movw	r24, r16
    2908:	01 97       	sbiw	r24, 0x01	; 1
    290a:	f1 f7       	brne	.-4      	; 0x2908 <enc28j60_init+0x17e>
    290c:	1f 91       	pop	r17
    290e:	0f 91       	pop	r16
    2910:	ff 90       	pop	r15
    2912:	ef 90       	pop	r14
    2914:	08 95       	ret

00002916 <enc28j60getrev>:

	_delay_ms(20);
}

//*******************************************************************************************
//
// Function : enc28j60getrev
// Description : read the revision of the chip.
//
//*******************************************************************************************
BYTE enc28j60getrev(void)
{
	return(enc28j60Read(EREVID));
    2916:	82 e7       	ldi	r24, 0x72	; 114
    2918:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
}
    291c:	99 27       	eor	r25, r25
    291e:	08 95       	ret

00002920 <enc28j60_packet_send>:

//*******************************************************************************************
//
// Function : enc28j60_packet_send
// Description : Send packet to network.
//
//*******************************************************************************************
void enc28j60_packet_send ( BYTE *buffer, WORD length )
{
    2920:	0f 93       	push	r16
    2922:	1f 93       	push	r17
    2924:	cf 93       	push	r28
    2926:	df 93       	push	r29
    2928:	8c 01       	movw	r16, r24
    292a:	eb 01       	movw	r28, r22
	//Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, LOW(TXSTART_INIT) );
    292c:	64 e2       	ldi	r22, 0x24	; 36
    292e:	82 e0       	ldi	r24, 0x02	; 2
    2930:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(EWRPTH, HIGH(TXSTART_INIT) );
    2934:	6a e1       	ldi	r22, 0x1A	; 26
    2936:	83 e0       	ldi	r24, 0x03	; 3
    2938:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, LOW((TXSTART_INIT+length)) );
    293c:	8c 2f       	mov	r24, r28
    293e:	8c 5d       	subi	r24, 0xDC	; 220
    2940:	68 2f       	mov	r22, r24
    2942:	86 e0       	ldi	r24, 0x06	; 6
    2944:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ETXNDH, HIGH((TXSTART_INIT+length)) );
    2948:	cc 5d       	subi	r28, 0xDC	; 220
    294a:	d5 4e       	sbci	r29, 0xE5	; 229
    294c:	8d 2f       	mov	r24, r29
    294e:	99 27       	eor	r25, r25
    2950:	c4 52       	subi	r28, 0x24	; 36
    2952:	da 41       	sbci	r29, 0x1A	; 26
    2954:	68 2f       	mov	r22, r24
    2956:	87 e0       	ldi	r24, 0x07	; 7
    2958:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    295c:	40 e0       	ldi	r20, 0x00	; 0
    295e:	64 2f       	mov	r22, r20
    2960:	8a e7       	ldi	r24, 0x7A	; 122
    2962:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>

	CSACTIVE;
    2966:	c4 98       	cbi	0x18, 4	; 24
	// issue write command
	SPDR = ENC28J60_WRITE_BUF_MEM;
    2968:	8a e7       	ldi	r24, 0x7A	; 122
    296a:	8f b9       	out	0x0f, r24	; 15
	waitspi();
    296c:	77 9b       	sbis	0x0e, 7	; 14
    296e:	fe cf       	rjmp	.-4      	; 0x296c <enc28j60_packet_send+0x4c>
	while(length)
	{
		length--;
		// write data
		SPDR = *buffer++;
		waitspi();
    2970:	20 97       	sbiw	r28, 0x00	; 0
    2972:	41 f0       	breq	.+16     	; 0x2984 <enc28j60_packet_send+0x64>
    2974:	21 97       	sbiw	r28, 0x01	; 1
    2976:	f8 01       	movw	r30, r16
    2978:	81 91       	ld	r24, Z+
    297a:	8f 01       	movw	r16, r30
    297c:	8f b9       	out	0x0f, r24	; 15
    297e:	77 9b       	sbis	0x0e, 7	; 14
    2980:	fe cf       	rjmp	.-4      	; 0x297e <enc28j60_packet_send+0x5e>
    2982:	f6 cf       	rjmp	.-20     	; 0x2970 <enc28j60_packet_send+0x50>
	}
	CSPASSIVE;
    2984:	c4 9a       	sbi	0x18, 4	; 24
	
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    2986:	48 e0       	ldi	r20, 0x08	; 8
    2988:	6f e1       	ldi	r22, 0x1F	; 31
    298a:	80 e8       	ldi	r24, 0x80	; 128
    298c:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>

	// Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) )
    2990:	8c e1       	ldi	r24, 0x1C	; 28
    2992:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    2996:	81 ff       	sbrs	r24, 1
    2998:	05 c0       	rjmp	.+10     	; 0x29a4 <enc28j60_packet_send+0x84>
	{
		enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
    299a:	48 e0       	ldi	r20, 0x08	; 8
    299c:	6f e1       	ldi	r22, 0x1F	; 31
    299e:	80 ea       	ldi	r24, 0xA0	; 160
    29a0:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>
    29a4:	df 91       	pop	r29
    29a6:	cf 91       	pop	r28
    29a8:	1f 91       	pop	r17
    29aa:	0f 91       	pop	r16
    29ac:	08 95       	ret

000029ae <enc28j60_packet_receive>:
	}
}

//*******************************************************************************************
//
// Function : enc28j60_packet_receive
// Description : check received packet and return length of data
//
//*******************************************************************************************
//WORD data_length;
WORD enc28j60_packet_receive ( BYTE *rxtx_buffer, WORD max_length )
{
    29ae:	cf 92       	push	r12
    29b0:	df 92       	push	r13
    29b2:	ef 92       	push	r14
    29b4:	ff 92       	push	r15
    29b6:	0f 93       	push	r16
    29b8:	1f 93       	push	r17
    29ba:	cf 93       	push	r28
    29bc:	df 93       	push	r29
    29be:	00 e0       	ldi	r16, 0x00	; 0
    29c0:	10 e0       	ldi	r17, 0x00	; 0
    29c2:	e8 01       	movw	r28, r16
    29c4:	6c 01       	movw	r12, r24
    29c6:	7b 01       	movw	r14, r22
	WORD_BYTES rx_status, data_length;
	
	// check if a packet has been received and buffered
	// if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
	// The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) == 0 )
    29c8:	89 e3       	ldi	r24, 0x39	; 57
    29ca:	0e 94 70 13 	call	0x26e0 <enc28j60Read>
    29ce:	88 23       	and	r24, r24
    29d0:	09 f4       	brne	.+2      	; 0x29d4 <enc28j60_packet_receive+0x26>
    29d2:	5a c0       	rjmp	.+180    	; 0x2a88 <enc28j60_packet_receive+0xda>
	{
		return 0;
	}

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, next_packet_ptr.bytes[0]);
    29d4:	60 91 69 03 	lds	r22, 0x0369
    29d8:	80 e0       	ldi	r24, 0x00	; 0
    29da:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ERDPTH, next_packet_ptr.bytes[1]);
    29de:	60 91 6a 03 	lds	r22, 0x036A
    29e2:	81 e0       	ldi	r24, 0x01	; 1
    29e4:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// read the next packet pointer
	next_packet_ptr.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    29e8:	60 e0       	ldi	r22, 0x00	; 0
    29ea:	8a e3       	ldi	r24, 0x3A	; 58
    29ec:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
    29f0:	80 93 69 03 	sts	0x0369, r24
	next_packet_ptr.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    29f4:	60 e0       	ldi	r22, 0x00	; 0
    29f6:	8a e3       	ldi	r24, 0x3A	; 58
    29f8:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
    29fc:	80 93 6a 03 	sts	0x036A, r24

	// read the packet length (see datasheet page 43)
	data_length.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    2a00:	60 e0       	ldi	r22, 0x00	; 0
    2a02:	8a e3       	ldi	r24, 0x3A	; 58
    2a04:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
    2a08:	c8 2f       	mov	r28, r24
	data_length.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    2a0a:	60 e0       	ldi	r22, 0x00	; 0
    2a0c:	8a e3       	ldi	r24, 0x3A	; 58
    2a0e:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
    2a12:	d8 2f       	mov	r29, r24
	data_length.word -=4; //remove the CRC count
    2a14:	24 97       	sbiw	r28, 0x04	; 4
	
	// read the receive status (see datasheet page 43)
	rx_status.bytes[0] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    2a16:	60 e0       	ldi	r22, 0x00	; 0
    2a18:	8a e3       	ldi	r24, 0x3A	; 58
    2a1a:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
    2a1e:	08 2f       	mov	r16, r24
	rx_status.bytes[1] = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    2a20:	60 e0       	ldi	r22, 0x00	; 0
    2a22:	8a e3       	ldi	r24, 0x3A	; 58
    2a24:	0e 94 2d 13 	call	0x265a <enc28j60ReadOp>
	
	if ( data_length.word > (max_length-1) )
    2a28:	b7 01       	movw	r22, r14
    2a2a:	61 50       	subi	r22, 0x01	; 1
    2a2c:	70 40       	sbci	r23, 0x00	; 0
    2a2e:	6c 17       	cp	r22, r28
    2a30:	7d 07       	cpc	r23, r29
    2a32:	08 f4       	brcc	.+2      	; 0x2a36 <enc28j60_packet_receive+0x88>
	{
		data_length.word = max_length-1;
    2a34:	eb 01       	movw	r28, r22
	}
	
	// check CRC and symbol errors (see datasheet page 44, table 7-3):
	// The ERXFCON.CRCEN is set by default. Normally we should not
	// need to check this.
	if ( (rx_status.word & 0x80)==0 )
    2a36:	07 fd       	sbrc	r16, 7
    2a38:	03 c0       	rjmp	.+6      	; 0x2a40 <enc28j60_packet_receive+0x92>
	{
		// invalid
		data_length.word = 0;
    2a3a:	c0 e0       	ldi	r28, 0x00	; 0
    2a3c:	d0 e0       	ldi	r29, 0x00	; 0
    2a3e:	15 c0       	rjmp	.+42     	; 0x2a6a <enc28j60_packet_receive+0xbc>
	}
	else
	{
		// read data from rx buffer and save to rxtx_buffer
		rx_status.word = data_length.word;
    2a40:	8e 01       	movw	r16, r28
		CSACTIVE;
    2a42:	c4 98       	cbi	0x18, 4	; 24
		// issue read command
		SPDR = ENC28J60_READ_BUF_MEM;
    2a44:	8a e3       	ldi	r24, 0x3A	; 58
    2a46:	8f b9       	out	0x0f, r24	; 15
		waitspi();
    2a48:	77 9b       	sbis	0x0e, 7	; 14
    2a4a:	fe cf       	rjmp	.-4      	; 0x2a48 <enc28j60_packet_receive+0x9a>
		while(rx_status.word)
		{
			rx_status.word--;
			SPDR = 0x00;
			waitspi();
			*rxtx_buffer++ = SPDR;
    2a4c:	20 97       	sbiw	r28, 0x00	; 0
    2a4e:	61 f0       	breq	.+24     	; 0x2a68 <enc28j60_packet_receive+0xba>
    2a50:	01 50       	subi	r16, 0x01	; 1
    2a52:	10 40       	sbci	r17, 0x00	; 0
    2a54:	1f b8       	out	0x0f, r1	; 15
    2a56:	77 9b       	sbis	0x0e, 7	; 14
    2a58:	fe cf       	rjmp	.-4      	; 0x2a56 <enc28j60_packet_receive+0xa8>
    2a5a:	8f b1       	in	r24, 0x0f	; 15
    2a5c:	f6 01       	movw	r30, r12
    2a5e:	81 93       	st	Z+, r24
    2a60:	6f 01       	movw	r12, r30
    2a62:	01 15       	cp	r16, r1
    2a64:	11 05       	cpc	r17, r1
    2a66:	a1 f7       	brne	.-24     	; 0x2a50 <enc28j60_packet_receive+0xa2>
		}
		CSPASSIVE;
    2a68:	c4 9a       	sbi	0x18, 4	; 24
	}
	
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, next_packet_ptr.bytes[0]);
    2a6a:	60 91 69 03 	lds	r22, 0x0369
    2a6e:	8c e0       	ldi	r24, 0x0C	; 12
    2a70:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>
	enc28j60Write(ERXRDPTH, next_packet_ptr.bytes[1]);
    2a74:	60 91 6a 03 	lds	r22, 0x036A
    2a78:	8d e0       	ldi	r24, 0x0D	; 13
    2a7a:	0e 94 7b 13 	call	0x26f6 <enc28j60Write>

	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    2a7e:	40 e4       	ldi	r20, 0x40	; 64
    2a80:	6e e1       	ldi	r22, 0x1E	; 30
    2a82:	80 e8       	ldi	r24, 0x80	; 128
    2a84:	0e 94 40 13 	call	0x2680 <enc28j60WriteOp>

	return( data_length.word );
    2a88:	ce 01       	movw	r24, r28
    2a8a:	df 91       	pop	r29
    2a8c:	cf 91       	pop	r28
    2a8e:	1f 91       	pop	r17
    2a90:	0f 91       	pop	r16
    2a92:	ff 90       	pop	r15
    2a94:	ef 90       	pop	r14
    2a96:	df 90       	pop	r13
    2a98:	cf 90       	pop	r12
    2a9a:	08 95       	ret

00002a9c <RS232_Init>:
{  
	// 晶振频率 : 16.0MHz
	// 通信参数: 8 Data, 1 Stop, No Parity 
	// 波特率:   19200
	 UCSRB = 0x00; //disable while setting baud rate
    2a9c:	1a b8       	out	0x0a, r1	; 10
	 UCSRA = 0x00;
    2a9e:	1b b8       	out	0x0b, r1	; 11
	 UCSRC = 0x06;
    2aa0:	86 e0       	ldi	r24, 0x06	; 6
    2aa2:	80 bd       	out	0x20, r24	; 32
	 UBRRL = 0x33; //set baud rate lo
    2aa4:	83 e3       	ldi	r24, 0x33	; 51
    2aa6:	89 b9       	out	0x09, r24	; 9
	 UBRRH = 0x00; //set baud rate hi
    2aa8:	10 bc       	out	0x20, r1	; 32
	 UCSRB = 0x18;
    2aaa:	88 e1       	ldi	r24, 0x18	; 24
    2aac:	8a b9       	out	0x0a, r24	; 10

    return TRUE;
}
    2aae:	81 e0       	ldi	r24, 0x01	; 1
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	08 95       	ret

00002ab4 <RS232_SendByte>:

/*
;*****************************************************************************************************
;* 函数名称 : RS232_SendByte
;* 描    述 : 串口发送一字节数据，并等待发送完成
;* 输　	 入 : data: 要发送的数据
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void RS232_SendByte(uint8 data)
{  
   	if (data == '\n')
    2ab4:	8a 30       	cpi	r24, 0x0A	; 10
    2ab6:	11 f4       	brne	.+4      	; 0x2abc <RS232_SendByte+0x8>
   	{
		data = '\r';				
    2ab8:	8d e0       	ldi	r24, 0x0D	; 13
    2aba:	09 c0       	rjmp	.+18     	; 0x2ace <RS232_SendByte+0x1a>
	}	
	else
	if (data == '\t')
    2abc:	89 30       	cpi	r24, 0x09	; 9
    2abe:	39 f4       	brne	.+14     	; 0x2ace <RS232_SendByte+0x1a>
	{		
		data = ' ';
    2ac0:	80 e2       	ldi	r24, 0x20	; 32
	
		// 检测是否可以发送, UDRE = 1 寄存器为空
		while ( !( UCSRA & (1 << UDRE)) )
    2ac2:	5d 9b       	sbis	0x0b, 5	; 11
    2ac4:	fe cf       	rjmp	.-4      	; 0x2ac2 <RS232_SendByte+0xe>
			   ;
		UDR = data;
    2ac6:	8c b9       	out	0x0c, r24	; 12
	
		// 检测是否可以发送, UDRE = 1 寄存器为空
		while ( !( UCSRA & (1 << UDRE)) )
    2ac8:	5d 9b       	sbis	0x0b, 5	; 11
    2aca:	fe cf       	rjmp	.-4      	; 0x2ac8 <RS232_SendByte+0x14>
			   ;
		UDR = data;
    2acc:	8c b9       	out	0x0c, r24	; 12
	
	}
	// 检测是否可以发送, UDRE = 1 寄存器为空
    while ( !( UCSRA & (1 << UDRE)) )
    2ace:	5d 9b       	sbis	0x0b, 5	; 11
    2ad0:	fe cf       	rjmp	.-4      	; 0x2ace <RS232_SendByte+0x1a>
           ;
    UDR = data;
    2ad2:	8c b9       	out	0x0c, r24	; 12
    2ad4:	08 95       	ret

00002ad6 <RS232_RecvByte>:
}

/*
;*****************************************************************************************************
;* 函数名称 : RS232_RecvByte
;* 描    述 : 从串口接收一字节数据
;* 输　	 入 : 无
;*        
;* 输　	 出 : 接收到的数据
;*****************************************************************************************************
;*/
uint8 RS232_RecvByte(void)
{  
	while (!(UCSRA & (1 << RXC)))
    2ad6:	5f 9b       	sbis	0x0b, 7	; 11
    2ad8:	fe cf       	rjmp	.-4      	; 0x2ad6 <RS232_RecvByte>
	{
		//OSTimeDly(1);
	}
	
    return UDR;
    2ada:	8c b1       	in	r24, 0x0c	; 12
}
    2adc:	99 27       	eor	r25, r25
    2ade:	08 95       	ret

00002ae0 <RS232_SendStr>:

/*
;*****************************************************************************************************
;* 函数名称 : RS232_SendStr
;* 描    述 : 串口发送一字符串
;* 输　	 入 : str: 要发送的字符串
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void RS232_SendStr(char const *str)
{  
    2ae0:	cf 93       	push	r28
    2ae2:	df 93       	push	r29
    2ae4:	ec 01       	movw	r28, r24
	char ch;

    if ((ch = *str++) != '\0')
    2ae6:	89 91       	ld	r24, Y+
    2ae8:	88 23       	and	r24, r24
    2aea:	41 f0       	breq	.+16     	; 0x2afc <RS232_SendStr+0x1c>
    {
        do
        {
            RS232_SendByte(ch); 
    2aec:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>

        } while((ch = *str++) != '\0');
    2af0:	89 91       	ld	r24, Y+
    2af2:	88 23       	and	r24, r24
    2af4:	d9 f7       	brne	.-10     	; 0x2aec <RS232_SendStr+0xc>

        RS232_SendByte('\n'); 
    2af6:	8a e0       	ldi	r24, 0x0A	; 10
    2af8:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
    2afc:	df 91       	pop	r29
    2afe:	cf 91       	pop	r28
    2b00:	08 95       	ret

00002b02 <RS232_RecvStr>:
    }
}

/*
;*****************************************************************************************************
;* 函数名称 : RS232_RecvStr
;* 描    述 : 从串口接收一字符串
;* 输　	 入 : str: 字符串
;*   
;* 输　	 出 : 无 
;*****************************************************************************************************
;*/
void RS232_RecvStr(char *str)
{
    2b02:	ff 92       	push	r15
    2b04:	0f 93       	push	r16
    2b06:	1f 93       	push	r17
    2b08:	cf 93       	push	r28
    2b0a:	8c 01       	movw	r16, r24
    char ch;
    uint8 i = 0;
    2b0c:	ff 24       	eor	r15, r15

	
    if (str != 0)
    2b0e:	89 2b       	or	r24, r25
    2b10:	31 f1       	breq	.+76     	; 0x2b5e <RS232_RecvStr+0x5c>
    { 
        while (1)
        {
            ch = RS232_RecvByte();                           	//  接收1个字符
    2b12:	0e 94 6b 15 	call	0x2ad6 <RS232_RecvByte>
    2b16:	c8 2f       	mov	r28, r24
            
            if (ch == '\r')                         			//  如果接收回车符，则跳出
    2b18:	8d 30       	cpi	r24, 0x0D	; 13
    2b1a:	39 f4       	brne	.+14     	; 0x2b2a <RS232_RecvStr+0x28>
            {
                RS232_SendByte(ch);                           	//  回显该字符
    2b1c:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
                str[i] = '\0';                                  //  添加字符串结束标志                
    2b20:	0f 0d       	add	r16, r15
    2b22:	11 1d       	adc	r17, r1
    2b24:	f8 01       	movw	r30, r16
    2b26:	10 82       	st	Z, r1
                break;
    2b28:	1a c0       	rjmp	.+52     	; 0x2b5e <RS232_RecvStr+0x5c>
            }
#define BACK_KEY 0x08
			if (ch == BACK_KEY)
    2b2a:	88 30       	cpi	r24, 0x08	; 8
    2b2c:	81 f4       	brne	.+32     	; 0x2b4e <RS232_RecvStr+0x4c>
#undef  BACK_KEY
			{					
				if (i)
    2b2e:	ff 20       	and	r15, r15
    2b30:	41 f0       	breq	.+16     	; 0x2b42 <RS232_RecvStr+0x40>
				{
					RS232_SendByte(ch);
    2b32:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
					RS232_SendByte(' ');
    2b36:	80 e2       	ldi	r24, 0x20	; 32
    2b38:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
					RS232_SendByte(ch);	
    2b3c:	8c 2f       	mov	r24, r28
    2b3e:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
				}
				i -= i ? 1 : 0;	
    2b42:	8f 2d       	mov	r24, r15
    2b44:	99 27       	eor	r25, r25
    2b46:	f1 10       	cpse	r15, r1
    2b48:	01 97       	sbiw	r24, 0x01	; 1
    2b4a:	f8 2e       	mov	r15, r24
    2b4c:	e2 cf       	rjmp	.-60     	; 0x2b12 <RS232_RecvStr+0x10>
			}             
			else                                            	//  接收到的是可打印字符
			{
				str[i++] = ch;                                 	//  保存到缓冲区
    2b4e:	f8 01       	movw	r30, r16
    2b50:	ef 0d       	add	r30, r15
    2b52:	f1 1d       	adc	r31, r1
    2b54:	80 83       	st	Z, r24
    2b56:	f3 94       	inc	r15
				RS232_SendByte(ch);                           	//  回显该字符
    2b58:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
    2b5c:	da cf       	rjmp	.-76     	; 0x2b12 <RS232_RecvStr+0x10>
    2b5e:	cf 91       	pop	r28
    2b60:	1f 91       	pop	r17
    2b62:	0f 91       	pop	r16
    2b64:	ff 90       	pop	r15
    2b66:	08 95       	ret

00002b68 <RS232_Printf>:
			}
        }
    } 
}

/*
;*****************************************************************************************************
;* 函数名称 : RS232_Printf
;* 描    述 : 串口格式化输出数据
;* 输　	 入 : char *fmt, ...
;*        
;* 输　	 出 : 无
;*****************************************************************************************************
;*/
void RS232_Printf (char *fmt, ...)
{
    2b68:	9f 92       	push	r9
    2b6a:	af 92       	push	r10
    2b6c:	bf 92       	push	r11
    2b6e:	cf 92       	push	r12
    2b70:	df 92       	push	r13
    2b72:	ef 92       	push	r14
    2b74:	ff 92       	push	r15
    2b76:	0f 93       	push	r16
    2b78:	1f 93       	push	r17
    2b7a:	cf 93       	push	r28
    2b7c:	df 93       	push	r29
    2b7e:	cd b7       	in	r28, 0x3d	; 61
    2b80:	de b7       	in	r29, 0x3e	; 62
    2b82:	26 97       	sbiw	r28, 0x06	; 6
    2b84:	0f b6       	in	r0, 0x3f	; 63
    2b86:	f8 94       	cli
    2b88:	de bf       	out	0x3e, r29	; 62
    2b8a:	0f be       	out	0x3f, r0	; 63
    2b8c:	cd bf       	out	0x3d, r28	; 61
    2b8e:	e4 e1       	ldi	r30, 0x14	; 20
    2b90:	ae 2e       	mov	r10, r30
    2b92:	b1 2c       	mov	r11, r1
    2b94:	ac 0e       	add	r10, r28
    2b96:	bd 1e       	adc	r11, r29
	va_list ap; 						//参数变量定义
	char strval[6];     
	char *str;
	char *p; 
	int nval; 
    int8 i = 0;
    2b98:	99 24       	eor	r9, r9

	
	va_start(ap, fmt); 					//设置第一个参数为fmt
	
	for(p = fmt; *p; p++) 
    2b9a:	f5 01       	movw	r30, r10
    2b9c:	c1 90       	ld	r12, Z+
    2b9e:	d1 90       	ld	r13, Z+
    2ba0:	5f 01       	movw	r10, r30
    2ba2:	f6 01       	movw	r30, r12
    2ba4:	80 81       	ld	r24, Z
    2ba6:	88 23       	and	r24, r24
    2ba8:	09 f4       	brne	.+2      	; 0x2bac <RS232_Printf+0x44>
    2baa:	a5 c0       	rjmp	.+330    	; 0x2cf6 <RS232_Printf+0x18e>
	{ 
		if (*p != '%') 
    2bac:	f6 01       	movw	r30, r12
    2bae:	80 81       	ld	r24, Z
    2bb0:	85 32       	cpi	r24, 0x25	; 37
    2bb2:	09 f0       	breq	.+2      	; 0x2bb6 <RS232_Printf+0x4e>
    2bb4:	6e c0       	rjmp	.+220    	; 0x2c92 <RS232_Printf+0x12a>
		{
			RS232_SendByte(*p);
			continue; 
		} 
		
		p++; 
    2bb6:	08 94       	sec
    2bb8:	c1 1c       	adc	r12, r1
    2bba:	d1 1c       	adc	r13, r1
		
		switch (*p) 
    2bbc:	f6 01       	movw	r30, r12
    2bbe:	80 81       	ld	r24, Z
    2bc0:	99 27       	eor	r25, r25
    2bc2:	84 36       	cpi	r24, 0x64	; 100
    2bc4:	91 05       	cpc	r25, r1
    2bc6:	81 f0       	breq	.+32     	; 0x2be8 <RS232_Printf+0x80>
    2bc8:	85 36       	cpi	r24, 0x65	; 101
    2bca:	91 05       	cpc	r25, r1
    2bcc:	2c f4       	brge	.+10     	; 0x2bd8 <RS232_Printf+0x70>
    2bce:	83 36       	cpi	r24, 0x63	; 99
    2bd0:	91 05       	cpc	r25, r1
    2bd2:	09 f4       	brne	.+2      	; 0x2bd6 <RS232_Printf+0x6e>
    2bd4:	56 c0       	rjmp	.+172    	; 0x2c82 <RS232_Printf+0x11a>
    2bd6:	75 c0       	rjmp	.+234    	; 0x2cc2 <RS232_Printf+0x15a>
    2bd8:	83 37       	cpi	r24, 0x73	; 115
    2bda:	91 05       	cpc	r25, r1
    2bdc:	09 f4       	brne	.+2      	; 0x2be0 <RS232_Printf+0x78>
    2bde:	5c c0       	rjmp	.+184    	; 0x2c98 <RS232_Printf+0x130>
    2be0:	88 37       	cpi	r24, 0x78	; 120
    2be2:	91 05       	cpc	r25, r1
    2be4:	19 f1       	breq	.+70     	; 0x2c2c <RS232_Printf+0xc4>
    2be6:	6d c0       	rjmp	.+218    	; 0x2cc2 <RS232_Printf+0x15a>
		{ 
			case 'd': 
				nval = va_arg(ap, int); //按类型获取下一个参数
    2be8:	f5 01       	movw	r30, r10
    2bea:	82 e0       	ldi	r24, 0x02	; 2
    2bec:	90 e0       	ldi	r25, 0x00	; 0
    2bee:	a8 0e       	add	r10, r24
    2bf0:	b9 1e       	adc	r11, r25
    2bf2:	00 81       	ld	r16, Z
    2bf4:	11 81       	ldd	r17, Z+1	; 0x01
				i = 0;
    2bf6:	99 24       	eor	r9, r9
    2bf8:	9e 01       	movw	r18, r28
    2bfa:	2f 5f       	subi	r18, 0xFF	; 255
    2bfc:	3f 4f       	sbci	r19, 0xFF	; 255
				do
				{
					strval[i] = nval % 10;
    2bfe:	e9 2d       	mov	r30, r9
    2c00:	ff 27       	eor	r31, r31
    2c02:	e7 fd       	sbrc	r30, 7
    2c04:	f0 95       	com	r31
    2c06:	e2 0f       	add	r30, r18
    2c08:	f3 1f       	adc	r31, r19
    2c0a:	c8 01       	movw	r24, r16
    2c0c:	6a e0       	ldi	r22, 0x0A	; 10
    2c0e:	70 e0       	ldi	r23, 0x00	; 0
    2c10:	0e 94 f7 16 	call	0x2dee <__divmodhi4>
    2c14:	80 83       	st	Z, r24
					nval /= 10;
    2c16:	c8 01       	movw	r24, r16
    2c18:	6a e0       	ldi	r22, 0x0A	; 10
    2c1a:	70 e0       	ldi	r23, 0x00	; 0
    2c1c:	0e 94 f7 16 	call	0x2dee <__divmodhi4>
    2c20:	8b 01       	movw	r16, r22
					i++;
    2c22:	93 94       	inc	r9
				} while (nval > 0);
    2c24:	16 16       	cp	r1, r22
    2c26:	17 06       	cpc	r1, r23
    2c28:	54 f3       	brlt	.-44     	; 0x2bfe <RS232_Printf+0x96>
    2c2a:	29 c0       	rjmp	.+82     	; 0x2c7e <RS232_Printf+0x116>
				i--;
				break; 
				
			case 'x': 
				nval = va_arg(ap, int); //按类型获取下一个参数
    2c2c:	f5 01       	movw	r30, r10
    2c2e:	82 e0       	ldi	r24, 0x02	; 2
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	a8 0e       	add	r10, r24
    2c34:	b9 1e       	adc	r11, r25
    2c36:	00 81       	ld	r16, Z
    2c38:	11 81       	ldd	r17, Z+1	; 0x01
				i = 0;
    2c3a:	99 24       	eor	r9, r9
    2c3c:	ae 01       	movw	r20, r28
    2c3e:	4f 5f       	subi	r20, 0xFF	; 255
    2c40:	5f 4f       	sbci	r21, 0xFF	; 255
				do
				{
					strval[i] = nval % 16;
    2c42:	e9 2d       	mov	r30, r9
    2c44:	ff 27       	eor	r31, r31
    2c46:	e7 fd       	sbrc	r30, 7
    2c48:	f0 95       	com	r31
    2c4a:	e4 0f       	add	r30, r20
    2c4c:	f5 1f       	adc	r31, r21
    2c4e:	98 01       	movw	r18, r16
    2c50:	17 ff       	sbrs	r17, 7
    2c52:	02 c0       	rjmp	.+4      	; 0x2c58 <RS232_Printf+0xf0>
    2c54:	21 5f       	subi	r18, 0xF1	; 241
    2c56:	3f 4f       	sbci	r19, 0xFF	; 255
    2c58:	74 e0       	ldi	r23, 0x04	; 4
    2c5a:	35 95       	asr	r19
    2c5c:	27 95       	ror	r18
    2c5e:	7a 95       	dec	r23
    2c60:	e1 f7       	brne	.-8      	; 0x2c5a <RS232_Printf+0xf2>
    2c62:	c9 01       	movw	r24, r18
    2c64:	64 e0       	ldi	r22, 0x04	; 4
    2c66:	88 0f       	add	r24, r24
    2c68:	99 1f       	adc	r25, r25
    2c6a:	6a 95       	dec	r22
    2c6c:	e1 f7       	brne	.-8      	; 0x2c66 <RS232_Printf+0xfe>
    2c6e:	08 1b       	sub	r16, r24
    2c70:	19 0b       	sbc	r17, r25
    2c72:	00 83       	st	Z, r16
					nval /= 16;
    2c74:	89 01       	movw	r16, r18
					i++;
    2c76:	93 94       	inc	r9
				} while (nval > 0);
    2c78:	12 16       	cp	r1, r18
    2c7a:	13 06       	cpc	r1, r19
    2c7c:	14 f3       	brlt	.-60     	; 0x2c42 <RS232_Printf+0xda>
				i--;
    2c7e:	9a 94       	dec	r9
				break; 
    2c80:	20 c0       	rjmp	.+64     	; 0x2cc2 <RS232_Printf+0x15a>
				
			case 'c': 
				 i = -1;
    2c82:	9f ef       	ldi	r25, 0xFF	; 255
    2c84:	99 2e       	mov	r9, r25
				 nval = va_arg(ap, int);							
    2c86:	f5 01       	movw	r30, r10
    2c88:	82 e0       	ldi	r24, 0x02	; 2
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	a8 0e       	add	r10, r24
    2c8e:	b9 1e       	adc	r11, r25
				 RS232_SendByte(nval);			  
    2c90:	80 81       	ld	r24, Z
    2c92:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
				 break;	
    2c96:	27 c0       	rjmp	.+78     	; 0x2ce6 <RS232_Printf+0x17e>
				 
		    case 's':
		    	i = -1;
    2c98:	8f ef       	ldi	r24, 0xFF	; 255
    2c9a:	98 2e       	mov	r9, r24
				str = (char *)va_arg(ap, int);
    2c9c:	f5 01       	movw	r30, r10
    2c9e:	82 e0       	ldi	r24, 0x02	; 2
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	a8 0e       	add	r10, r24
    2ca4:	b9 1e       	adc	r11, r25
    2ca6:	e0 80       	ld	r14, Z
    2ca8:	f1 80       	ldd	r15, Z+1	; 0x01
				do
				{
					nval = *str++;
    2caa:	f7 01       	movw	r30, r14
    2cac:	81 91       	ld	r24, Z+
    2cae:	7f 01       	movw	r14, r30
    2cb0:	08 2f       	mov	r16, r24
    2cb2:	11 27       	eor	r17, r17
					if (nval != 0)
    2cb4:	01 15       	cp	r16, r1
    2cb6:	11 05       	cpc	r17, r1
    2cb8:	b1 f0       	breq	.+44     	; 0x2ce6 <RS232_Printf+0x17e>
					{
						RS232_SendByte(nval);
    2cba:	80 2f       	mov	r24, r16
    2cbc:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
    2cc0:	f4 cf       	rjmp	.-24     	; 0x2caa <RS232_Printf+0x142>
					}
					else 
					{
						break;
					}
				} while (1);
				break;
				
			default: 
				break;	 
		} 
		
		for(; i >= 0; i--)
    2cc2:	97 fc       	sbrc	r9, 7
    2cc4:	10 c0       	rjmp	.+32     	; 0x2ce6 <RS232_Printf+0x17e>
    2cc6:	09 2d       	mov	r16, r9
    2cc8:	11 27       	eor	r17, r17
    2cca:	07 fd       	sbrc	r16, 7
    2ccc:	10 95       	com	r17
		{
			nval = strval[i] + '0';
    2cce:	fe 01       	movw	r30, r28
    2cd0:	e0 0f       	add	r30, r16
    2cd2:	f1 1f       	adc	r31, r17
    2cd4:	81 81       	ldd	r24, Z+1	; 0x01
			RS232_SendByte(nval);
    2cd6:	80 5d       	subi	r24, 0xD0	; 208
    2cd8:	0e 94 5a 15 	call	0x2ab4 <RS232_SendByte>
    2cdc:	9a 94       	dec	r9
    2cde:	01 50       	subi	r16, 0x01	; 1
    2ce0:	10 40       	sbci	r17, 0x00	; 0
    2ce2:	97 fe       	sbrs	r9, 7
    2ce4:	f4 cf       	rjmp	.-24     	; 0x2cce <RS232_Printf+0x166>
    2ce6:	08 94       	sec
    2ce8:	c1 1c       	adc	r12, r1
    2cea:	d1 1c       	adc	r13, r1
    2cec:	f6 01       	movw	r30, r12
    2cee:	80 81       	ld	r24, Z
    2cf0:	88 23       	and	r24, r24
    2cf2:	09 f0       	breq	.+2      	; 0x2cf6 <RS232_Printf+0x18e>
    2cf4:	5b cf       	rjmp	.-330    	; 0x2bac <RS232_Printf+0x44>
    2cf6:	26 96       	adiw	r28, 0x06	; 6
    2cf8:	0f b6       	in	r0, 0x3f	; 63
    2cfa:	f8 94       	cli
    2cfc:	de bf       	out	0x3e, r29	; 62
    2cfe:	0f be       	out	0x3f, r0	; 63
    2d00:	cd bf       	out	0x3d, r28	; 61
    2d02:	df 91       	pop	r29
    2d04:	cf 91       	pop	r28
    2d06:	1f 91       	pop	r17
    2d08:	0f 91       	pop	r16
    2d0a:	ff 90       	pop	r15
    2d0c:	ef 90       	pop	r14
    2d0e:	df 90       	pop	r13
    2d10:	cf 90       	pop	r12
    2d12:	bf 90       	pop	r11
    2d14:	af 90       	pop	r10
    2d16:	9f 90       	pop	r9
    2d18:	08 95       	ret

00002d1a <memcpy>:
    2d1a:	fb 01       	movw	r30, r22
    2d1c:	dc 01       	movw	r26, r24
    2d1e:	40 ff       	sbrs	r20, 0
    2d20:	05 c0       	rjmp	.+10     	; 0x2d2c <memcpy+0x12>
    2d22:	02 c0       	rjmp	.+4      	; 0x2d28 <memcpy+0xe>
    2d24:	01 90       	ld	r0, Z+
    2d26:	0d 92       	st	X+, r0
    2d28:	01 90       	ld	r0, Z+
    2d2a:	0d 92       	st	X+, r0
    2d2c:	42 50       	subi	r20, 0x02	; 2
    2d2e:	50 40       	sbci	r21, 0x00	; 0
    2d30:	c8 f7       	brcc	.-14     	; 0x2d24 <memcpy+0xa>
    2d32:	08 95       	ret

00002d34 <memset>:
    2d34:	dc 01       	movw	r26, r24
    2d36:	40 ff       	sbrs	r20, 0
    2d38:	03 c0       	rjmp	.+6      	; 0x2d40 <memset+0xc>
    2d3a:	01 c0       	rjmp	.+2      	; 0x2d3e <memset+0xa>
    2d3c:	6d 93       	st	X+, r22
    2d3e:	6d 93       	st	X+, r22
    2d40:	42 50       	subi	r20, 0x02	; 2
    2d42:	50 40       	sbci	r21, 0x00	; 0
    2d44:	d8 f7       	brcc	.-10     	; 0x2d3c <memset+0x8>
    2d46:	08 95       	ret

00002d48 <strncmp>:
    2d48:	fb 01       	movw	r30, r22
    2d4a:	dc 01       	movw	r26, r24
    2d4c:	41 50       	subi	r20, 0x01	; 1
    2d4e:	50 40       	sbci	r21, 0x00	; 0
    2d50:	30 f0       	brcs	.+12     	; 0x2d5e <strncmp+0x16>
    2d52:	8d 91       	ld	r24, X+
    2d54:	01 90       	ld	r0, Z+
    2d56:	80 19       	sub	r24, r0
    2d58:	19 f4       	brne	.+6      	; 0x2d60 <strncmp+0x18>
    2d5a:	00 20       	and	r0, r0
    2d5c:	b9 f7       	brne	.-18     	; 0x2d4c <strncmp+0x4>
    2d5e:	88 1b       	sub	r24, r24
    2d60:	99 0b       	sbc	r25, r25
    2d62:	08 95       	ret

00002d64 <strncpy>:
    2d64:	fb 01       	movw	r30, r22
    2d66:	dc 01       	movw	r26, r24
    2d68:	41 50       	subi	r20, 0x01	; 1
    2d6a:	50 40       	sbci	r21, 0x00	; 0
    2d6c:	48 f0       	brcs	.+18     	; 0x2d80 <strncpy+0x1c>
    2d6e:	01 90       	ld	r0, Z+
    2d70:	0d 92       	st	X+, r0
    2d72:	00 20       	and	r0, r0
    2d74:	c9 f7       	brne	.-14     	; 0x2d68 <strncpy+0x4>
    2d76:	01 c0       	rjmp	.+2      	; 0x2d7a <strncpy+0x16>
    2d78:	1d 92       	st	X+, r1
    2d7a:	41 50       	subi	r20, 0x01	; 1
    2d7c:	50 40       	sbci	r21, 0x00	; 0
    2d7e:	e0 f7       	brcc	.-8      	; 0x2d78 <strncpy+0x14>
    2d80:	08 95       	ret

00002d82 <puts>:
    2d82:	0f 93       	push	r16
    2d84:	1f 93       	push	r17
    2d86:	cf 93       	push	r28
    2d88:	df 93       	push	r29
    2d8a:	ec 01       	movw	r28, r24
    2d8c:	00 e0       	ldi	r16, 0x00	; 0
    2d8e:	10 e0       	ldi	r17, 0x00	; 0
    2d90:	e0 91 2e 08 	lds	r30, 0x082E
    2d94:	f0 91 2f 08 	lds	r31, 0x082F
    2d98:	83 81       	ldd	r24, Z+3	; 0x03
    2d9a:	81 fd       	sbrc	r24, 1
    2d9c:	03 c0       	rjmp	.+6      	; 0x2da4 <puts+0x22>
    2d9e:	8f ef       	ldi	r24, 0xFF	; 255
    2da0:	9f ef       	ldi	r25, 0xFF	; 255
    2da2:	20 c0       	rjmp	.+64     	; 0x2de4 <puts+0x62>
    2da4:	89 91       	ld	r24, Y+
    2da6:	88 23       	and	r24, r24
    2da8:	71 f0       	breq	.+28     	; 0x2dc6 <puts+0x44>
    2daa:	e0 91 2e 08 	lds	r30, 0x082E
    2dae:	f0 91 2f 08 	lds	r31, 0x082F
    2db2:	20 85       	ldd	r18, Z+8	; 0x08
    2db4:	31 85       	ldd	r19, Z+9	; 0x09
    2db6:	bf 01       	movw	r22, r30
    2db8:	f9 01       	movw	r30, r18
    2dba:	09 95       	icall
    2dbc:	89 2b       	or	r24, r25
    2dbe:	91 f3       	breq	.-28     	; 0x2da4 <puts+0x22>
    2dc0:	0f ef       	ldi	r16, 0xFF	; 255
    2dc2:	1f ef       	ldi	r17, 0xFF	; 255
    2dc4:	ef cf       	rjmp	.-34     	; 0x2da4 <puts+0x22>
    2dc6:	e0 91 2e 08 	lds	r30, 0x082E
    2dca:	f0 91 2f 08 	lds	r31, 0x082F
    2dce:	20 85       	ldd	r18, Z+8	; 0x08
    2dd0:	31 85       	ldd	r19, Z+9	; 0x09
    2dd2:	bf 01       	movw	r22, r30
    2dd4:	8a e0       	ldi	r24, 0x0A	; 10
    2dd6:	f9 01       	movw	r30, r18
    2dd8:	09 95       	icall
    2dda:	89 2b       	or	r24, r25
    2ddc:	11 f0       	breq	.+4      	; 0x2de2 <puts+0x60>
    2dde:	0f ef       	ldi	r16, 0xFF	; 255
    2de0:	1f ef       	ldi	r17, 0xFF	; 255
    2de2:	c8 01       	movw	r24, r16
    2de4:	df 91       	pop	r29
    2de6:	cf 91       	pop	r28
    2de8:	1f 91       	pop	r17
    2dea:	0f 91       	pop	r16
    2dec:	08 95       	ret

00002dee <__divmodhi4>:
    2dee:	97 fb       	bst	r25, 7
    2df0:	09 2e       	mov	r0, r25
    2df2:	07 26       	eor	r0, r23
    2df4:	0a d0       	rcall	.+20     	; 0x2e0a <__divmodhi4_neg1>
    2df6:	77 fd       	sbrc	r23, 7
    2df8:	04 d0       	rcall	.+8      	; 0x2e02 <__divmodhi4_neg2>
    2dfa:	0c d0       	rcall	.+24     	; 0x2e14 <__udivmodhi4>
    2dfc:	06 d0       	rcall	.+12     	; 0x2e0a <__divmodhi4_neg1>
    2dfe:	00 20       	and	r0, r0
    2e00:	1a f4       	brpl	.+6      	; 0x2e08 <__divmodhi4_exit>

00002e02 <__divmodhi4_neg2>:
    2e02:	70 95       	com	r23
    2e04:	61 95       	neg	r22
    2e06:	7f 4f       	sbci	r23, 0xFF	; 255

00002e08 <__divmodhi4_exit>:
    2e08:	08 95       	ret

00002e0a <__divmodhi4_neg1>:
    2e0a:	f6 f7       	brtc	.-4      	; 0x2e08 <__divmodhi4_exit>
    2e0c:	90 95       	com	r25
    2e0e:	81 95       	neg	r24
    2e10:	9f 4f       	sbci	r25, 0xFF	; 255
    2e12:	08 95       	ret

00002e14 <__udivmodhi4>:
    2e14:	aa 1b       	sub	r26, r26
    2e16:	bb 1b       	sub	r27, r27
    2e18:	51 e1       	ldi	r21, 0x11	; 17
    2e1a:	07 c0       	rjmp	.+14     	; 0x2e2a <__udivmodhi4_ep>

00002e1c <__udivmodhi4_loop>:
    2e1c:	aa 1f       	adc	r26, r26
    2e1e:	bb 1f       	adc	r27, r27
    2e20:	a6 17       	cp	r26, r22
    2e22:	b7 07       	cpc	r27, r23
    2e24:	10 f0       	brcs	.+4      	; 0x2e2a <__udivmodhi4_ep>
    2e26:	a6 1b       	sub	r26, r22
    2e28:	b7 0b       	sbc	r27, r23

00002e2a <__udivmodhi4_ep>:
    2e2a:	88 1f       	adc	r24, r24
    2e2c:	99 1f       	adc	r25, r25
    2e2e:	5a 95       	dec	r21
    2e30:	a9 f7       	brne	.-22     	; 0x2e1c <__udivmodhi4_loop>
    2e32:	80 95       	com	r24
    2e34:	90 95       	com	r25
    2e36:	bc 01       	movw	r22, r24
    2e38:	cd 01       	movw	r24, r26
    2e3a:	08 95       	ret
